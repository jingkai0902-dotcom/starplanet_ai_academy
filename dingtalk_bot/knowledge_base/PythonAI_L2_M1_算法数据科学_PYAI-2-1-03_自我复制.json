{
  "title": "[PYAI-2-1-03] 自我复制",
  "source": "C:\\Users\\Frank.J\\starplanet_ai_academy\\知识库\\萃取报告\\PythonAI\\L2\\M1_算法数据科学\\PYAI-2-1-03_自我复制.md",
  "sections": [
    {
      "title": "课程基本信息",
      "content": "| 项目 | 内容 |\n|------|------|\n| **课程编号** | 2-1-3 |\n| **课程名称** | 自我复制 |\n| **认知负荷** | 高 |\n| **核心技能** | 递归函数、递归终止条件、调用栈 |\n| **项目内容** | 阶乘与斐波那契 |\n\n---"
    },
    {
      "title": "详细教学流程",
      "content": "**步骤1：知识讲解（25分钟）** `#中负荷-操练` `#IFC-即时`\n\n**教师话术**\n> \"今天学习一个神奇的概念——**递归**：函数调用自己！\"\n>\n> \"想象俄罗斯套娃，打开一个娃娃里面还有一个，直到最小的那个。\n>\n> **递归三要素**：\n> 1. **递归调用**：函数调用自己\n> 2. **终止条件**：什么时候停止（最重要！）\n> 3. **问题缩小**：每次调用问题要变小\n>\n> **阶乘示例**：n! = n × (n-1)!\n> ```python\n> def factorial(n):\n>     # 终止条件\n>     if n <= 1:\n>         return 1\n>     # 递归调用\n>     return n * factorial(n - 1)\n>\n> print(factorial(5))  # 120 = 5×4×3×2×1\n> ```\n>\n> **斐波那契数列**：F(n) = F(n-1) + F(n-2)\n> ```python\n> def fibonacci(n):\n>     if n <= 1:\n>         return n\n>     return fibonacci(n-1) + fibonacci(n-2)\n>\n> # 0, 1, 1, 2, 3, 5, 8, 13, 21...\n> ```\"\n\n**步骤2：代码实践（35分钟）** `#高负荷-产出` `#IFC-即时`\n\n**教师话术**\n> \"用递归解决这些问题：\n> 1. 计算1+2+3+...+n的和\n> 2. 计算x的n次方\n> 3. 打印倒计时：5, 4, 3, 2, 1, 发射！\"\n\n---"
    },
    {
      "title": "变体示例",
      "content": "| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 无限递归 | 检查终止条件 | 确保有明确的停止条件 |\n| 不理解调用栈 | 画图演示 | 画出函数调用的层层嵌套 |\n| 斐波那契太慢 | 解释原因 | 重复计算太多，后面学优化 |\n\n---"
    },
    {
      "title": "核心代码模式",
      "content": "```python\ndef recursive_template(problem):\n    # 1. 终止条件（必须有！）\n    if is_base_case(problem):\n        return base_solution\n\n    # 2. 缩小问题\n    smaller_problem = reduce(problem)\n\n    # 3. 递归调用\n    sub_result = recursive_template(smaller_problem)\n\n    # 4. 组合结果\n    return combine(sub_result)\n```\n\n---"
    },
    {
      "title": "禁忌提醒",
      "content": "- 忘记终止条件——导致无限递归，程序崩溃\n- 问题没有缩小——同样导致无限递归\n- 递归层数太深——Python默认限制1000层\n\n---"
    },
    {
      "title": "核心知识点",
      "content": "- 递归函数：函数调用自己\n- 终止条件：递归必须有停止条件\n- 调用栈：递归调用的层层嵌套结构\n\n---\n\n`#执行层` `#测评项`\n[UID: PYAI-21-03-001]\n\n---\n\n[上一课](PYAI-2-1-02_笔走龙蛇.md) | [下一课](PYAI-2-1-04_分而治之.md) | [返回模块概览](_模块概览.md)"
    }
  ],
  "full_content": "# [PYAI-2-1-03] 自我复制\n\n> **模块**：L2-M1 算法数据科学\n> **认知负荷**：高\n> **核心技能**：递归函数、递归终止条件、调用栈\n> **UID**：PYAI-21-03-001\n\n---\n\n## 课程基本信息\n\n| 项目 | 内容 |\n|------|------|\n| **课程编号** | 2-1-3 |\n| **课程名称** | 自我复制 |\n| **认知负荷** | 高 |\n| **核心技能** | 递归函数、递归终止条件、调用栈 |\n| **项目内容** | 阶乘与斐波那契 |\n\n---\n\n## 详细教学流程\n\n**步骤1：知识讲解（25分钟）** `#中负荷-操练` `#IFC-即时`\n\n**教师话术**\n> \"今天学习一个神奇的概念——**递归**：函数调用自己！\"\n>\n> \"想象俄罗斯套娃，打开一个娃娃里面还有一个，直到最小的那个。\n>\n> **递归三要素**：\n> 1. **递归调用**：函数调用自己\n> 2. **终止条件**：什么时候停止（最重要！）\n> 3. **问题缩小**：每次调用问题要变小\n>\n> **阶乘示例**：n! = n × (n-1)!\n> ```python\n> def factorial(n):\n>     # 终止条件\n>     if n <= 1:\n>         return 1\n>     # 递归调用\n>     return n * factorial(n - 1)\n>\n> print(factorial(5))  # 120 = 5×4×3×2×1\n> ```\n>\n> **斐波那契数列**：F(n) = F(n-1) + F(n-2)\n> ```python\n> def fibonacci(n):\n>     if n <= 1:\n>         return n\n>     return fibonacci(n-1) + fibonacci(n-2)\n>\n> # 0, 1, 1, 2, 3, 5, 8, 13, 21...\n> ```\"\n\n**步骤2：代码实践（35分钟）** `#高负荷-产出` `#IFC-即时`\n\n**教师话术**\n> \"用递归解决这些问题：\n> 1. 计算1+2+3+...+n的和\n> 2. 计算x的n次方\n> 3. 打印倒计时：5, 4, 3, 2, 1, 发射！\"\n\n---\n\n## 变体示例\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 无限递归 | 检查终止条件 | 确保有明确的停止条件 |\n| 不理解调用栈 | 画图演示 | 画出函数调用的层层嵌套 |\n| 斐波那契太慢 | 解释原因 | 重复计算太多，后面学优化 |\n\n---\n\n## 核心代码模式\n\n```python\ndef recursive_template(problem):\n    # 1. 终止条件（必须有！）\n    if is_base_case(problem):\n        return base_solution\n\n    # 2. 缩小问题\n    smaller_problem = reduce(problem)\n\n    # 3. 递归调用\n    sub_result = recursive_template(smaller_problem)\n\n    # 4. 组合结果\n    return combine(sub_result)\n```\n\n---\n\n## 禁忌提醒\n\n- 忘记终止条件——导致无限递归，程序崩溃\n- 问题没有缩小——同样导致无限递归\n- 递归层数太深——Python默认限制1000层\n\n---\n\n## 核心知识点\n\n- 递归函数：函数调用自己\n- 终止条件：递归必须有停止条件\n- 调用栈：递归调用的层层嵌套结构\n\n---\n\n`#执行层` `#测评项`\n[UID: PYAI-21-03-001]\n\n---\n\n[上一课](PYAI-2-1-02_笔走龙蛇.md) | [下一课](PYAI-2-1-04_分而治之.md) | [返回模块概览](_模块概览.md)\n"
}