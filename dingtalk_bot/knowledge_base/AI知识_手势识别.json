{
  "title": "手势识别",
  "source": "C:\\Users\\Frank.J\\starplanet_ai_academy\\知识库\\02_知识点数据库\\AI知识库\\手势识别.md",
  "sections": [
    {
      "title": "一、技术概述",
      "content": "### 1.1 手势识别流程\n\n```\n图像采集 → 手部检测 → 关键点提取 → 手势分类 → 指令执行\n```\n\n### 1.2 跨课程出现\n\n| 课程编号 | 课程名称 | 具体内容 |\n|----------|---------|---------|\n| PYAI 2-3-7 | 手势识别基础 | MediaPipe Hands |\n| PYAI 2-3-8 | 手势控制游戏 | 手势映射 |\n| PYAI 2-3-9 | 手势绘画板 | 指尖追踪 |\n| PYAI 2-3-10 | 机械手游戏(1) | 石头剪刀布 |\n| PYAI 2-3-11 | 机械手游戏(2) | 策略优化 |\n\n---"
    },
    {
      "title": "二、MediaPipe Hands",
      "content": "### 2.1 简介\n\nMediaPipe Hands 可以检测21个手部关键点，支持单手或双手检测，用于手势识别、手语翻译等。\n\n### 2.2 安装\n\n```bash\npip install mediapipe\n```\n\n### 2.3 基本使用\n\n```python\nimport cv2\nimport mediapipe as mp\n\n# 初始化\nmp_hands = mp.solutions.hands\nhands = mp_hands.Hands(\n    static_image_mode=False,      # 视频模式\n    max_num_hands=2,              # 最多检测2只手\n    min_detection_confidence=0.7, # 检测置信度\n    min_tracking_confidence=0.5   # 追踪置信度\n)\n\n# 绘制工具\nmp_drawing = mp.solutions.drawing_utils\nmp_drawing_styles = mp.solutions.drawing_styles\n\ncap = cv2.VideoCapture(0)\n\nwhile True:\n    ret, frame = cap.read()\n    if not ret:\n        break\n\n    # 水平翻转（镜像效果）\n    frame = cv2.flip(frame, 1)\n\n    # 转换颜色空间（重要！）\n    rgb_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)\n\n    # 检测手部\n    results = hands.process(rgb_frame)\n\n    if results.multi_hand_landmarks:\n        for hand_landmarks in results.multi_hand_landmarks:\n            # 绘制关键点和连接线\n            mp_drawing.draw_landmarks(\n                frame,\n                hand_landmarks,\n                mp_hands.HAND_CONNECTIONS,\n                mp_drawing_styles.get_default_hand_landmarks_style(),\n                mp_drawing_styles.get_default_hand_connections_style()\n            )\n\n    cv2.imshow('Hand Detection', frame)\n    if cv2.waitKey(1) & 0xFF == ord('q'):\n        break\n\ncap.release()\ncv2.destroyAllWindows()\n```\n\n### 2.4 获取关键点坐标\n\n```python\nif results.multi_hand_landmarks:\n    hand_landmarks = results.multi_hand_landmarks[0]\n    landmarks = hand_landmarks.landmark\n\n    # 获取特定关键点\n    h, w, c = frame.shape\n    point = landmarks[8]  # 食指指尖\n    x = int(point.x * w)\n    y = int(point.y * h)\n    z = point.z  # 深度（相对值）\n```\n\n---"
    },
    {
      "title": "三、手部关键点索引",
      "content": "### 3.1 21个关键点分布\n\n```\n        8   12  16  20\n        |   |   |   |\n    4   7   11  15  19\n    |   |   |   |   |\n    3   6   10  14  18\n    |   |   |   |   |\n    2   5   9   13  17\n     \\   \\  |  /   /\n      \\   \\ | /   /\n       1----0----\n           手腕\n```\n\n### 3.2 关键点索引表\n\n| 索引 | 名称 | 说明 |\n|------|------|------|\n| 0 | WRIST | 手腕 |\n| 1 | THUMB_CMC | 拇指根部 |\n| 2 | THUMB_MCP | 拇指第一关节 |\n| 3 | THUMB_IP | 拇指第二关节 |\n| 4 | THUMB_TIP | 拇指指尖 |\n| 5 | INDEX_FINGER_MCP | 食指根部 |\n| 6 | INDEX_FINGER_PIP | 食指第一关节 |\n| 7 | INDEX_FINGER_DIP | 食指第二关节 |\n| 8 | INDEX_FINGER_TIP | 食指指尖 |\n| 9 | MIDDLE_FINGER_MCP | 中指根部 |\n| 10 | MIDDLE_FINGER_PIP | 中指第一关节 |\n| 11 | MIDDLE_FINGER_DIP | 中指第二关节 |\n| 12 | MIDDLE_FINGER_TIP | 中指指尖 |\n| 13 | RING_FINGER_MCP | 无名指根部 |\n| 14 | RING_FINGER_PIP | 无名指第一关节 |\n| 15 | RING_FINGER_DIP | 无名指第二关节 |\n| 16 | RING_FINGER_TIP | 无名指指尖 |\n| 17 | PINKY_MCP | 小拇指根部 |\n| 18 | PINKY_PIP | 小拇指第一关节 |\n| 19 | PINKY_DIP | 小拇指第二关节 |\n| 20 | PINKY_TIP | 小拇指指尖 |\n\n### 3.3 常用关键点组\n\n```python\n# 指尖索引\nFINGER_TIPS = [4, 8, 12, 16, 20]\n\n# 指根索引（MCP关节）\nFINGER_MCPS = [1, 5, 9, 13, 17]\n\n# 第二关节索引（PIP关节）\nFINGER_PIPS = [2, 6, 10, 14, 18]\n```\n\n---"
    },
    {
      "title": "四、手指状态检测",
      "content": "### 4.1 原理\n\n通过比较指尖和关节的位置判断手指是否伸直：\n- **四指**：指尖y坐标 < 第二关节y坐标 → 伸直\n- **拇指**：指尖x坐标与第一关节x坐标比较（需考虑左右手）\n\n### 4.2 跨课程出现\n\n| 课程编号 | 课程名称 | 具体内容 |\n|----------|---------|---------|\n| PYAI 2-3-7 | 手势识别基础 | 手指状态检测 |\n| PYAI 2-3-8 | 手势控制游戏 | 手势分类 |\n\n### 4.3 实现代码\n\n```python\ndef get_finger_states(landmarks, handedness='Right'):\n    \"\"\"\n    检测每根手指是否伸直\n    返回: [拇指, 食指, 中指, 无名指, 小拇指] 的状态列表\n    1 = 伸直, 0 = 弯曲\n    \"\"\"\n    fingers = []\n\n    # 拇指（需要考虑左右手）\n    if handedness == 'Right':\n        # 右手：指尖x < 第一关节x 表示伸直\n        if landmarks[4].x < landmarks[3].x:\n            fingers.append(1)\n        else:\n            fingers.append(0)\n    else:\n        # 左手：指尖x > 第一关节x 表示伸直\n        if landmarks[4].x > landmarks[3].x:\n            fingers.append(1)\n        else:\n            fingers.append(0)\n\n    # 其他四指：指尖y < 第二关节y 表示伸直\n    for tip_idx in [8, 12, 16, 20]:\n        pip_idx = tip_idx - 2  # 对应的第二关节\n        if landmarks[tip_idx].y < landmarks[pip_idx].y:\n            fingers.append(1)\n        else:\n            fingers.append(0)\n\n    return fingers\n```\n\n### 4.4 获取手的左右信息\n\n```python\nif results.multi_hand_landmarks and results.multi_handedness:\n    for hand_landmarks, handedness in zip(\n        results.multi_hand_landmarks,\n        results.multi_handedness\n    ):\n        # 获取左右手信息\n        hand_label = handedness.classification[0].label  # 'Left' 或 'Right'\n        confidence = handedness.classification[0].score\n\n        landmarks = hand_landmarks.landmark\n        fingers = get_finger_states(landmarks, hand_label)\n```\n\n---"
    },
    {
      "title": "五、手势分类",
      "content": "### 5.1 基本手势定义\n\n```python\n# 手势映射表\n# 格式: (拇指, 食指, 中指, 无名指, 小拇指) -> 手势名称\nGESTURE_MAP = {\n    (0, 0, 0, 0, 0): 'FIST',      # 握拳\n    (1, 1, 1, 1, 1): 'FIVE',      # 张开五指\n    (0, 1, 0, 0, 0): 'ONE',       # 数字1\n    (0, 1, 1, 0, 0): 'TWO',       # 数字2 / 剪刀\n    (0, 1, 1, 1, 0): 'THREE',     # 数字3\n    (0, 1, 1, 1, 1): 'FOUR',      # 数字4\n    (1, 0, 0, 0, 0): 'THUMB_UP',  # 点赞\n    (0, 1, 0, 0, 1): 'ROCK',      # 摇滚手势\n    (1, 1, 0, 0, 1): 'CALL',      # 打电话手势\n    (0, 0, 0, 0, 1): 'PINKY',     # 小拇指\n}\n\ndef classify_gesture(finger_states):\n    \"\"\"根据手指状态分类手势\"\"\"\n    return GESTURE_MAP.get(tuple(finger_states), 'UNKNOWN')\n```\n\n### 5.2 石头剪刀布识别\n\n```python\n# 石头剪刀布手势\nRPS_GESTURES = {\n    (0, 0, 0, 0, 0): 'ROCK',      # 石头 = 握拳\n    (0, 1, 1, 0, 0): 'SCISSORS',  # 剪刀 = 食指+中指\n    (1, 1, 1, 1, 1): 'PAPER',     # 布 = 五指张开\n}\n\ndef classify_rps(finger_states):\n    \"\"\"识别石头剪刀布手势\"\"\"\n    return RPS_GESTURES.get(tuple(finger_states), None)\n```\n\n### 5.3 跨课程出现\n\n| 课程编号 | 课程名称 | 具体内容 |\n|----------|---------|---------|\n| PYAI 2-3-10 | 机械手游戏(1) | 石头剪刀布识别 |\n| PYAI 2-3-11 | 机械手游戏(2) | 策略优化 |\n\n---"
    },
    {
      "title": "六、指尖追踪",
      "content": "### 6.1 基本追踪\n\n```python\ndef get_fingertip_position(landmarks, frame_shape, finger_idx=8):\n    \"\"\"\n    获取指尖在画面中的像素坐标\n    finger_idx: 4=拇指, 8=食指, 12=中指, 16=无名指, 20=小拇指\n    \"\"\"\n    h, w, c = frame_shape\n    tip = landmarks[finger_idx]\n    x = int(tip.x * w)\n    y = int(tip.y * h)\n    return x, y\n```\n\n### 6.2 空中绘画\n\n```python\nimport cv2\nimport mediapipe as mp\nimport numpy as np\n\nmp_hands = mp.solutions.hands\nhands = mp_hands.Hands(max_num_hands=1, min_detection_confidence=0.7)\n\ncap = cv2.VideoCapture(0)\n\n# 创建画布\ncanvas = None\nprev_x, prev_y = None, None\ndraw_color = (0, 255, 0)  # 绿色\nbrush_size = 5\n\nwhile True:\n    ret, frame = cap.read()\n    if not ret:\n        break\n\n    frame = cv2.flip(frame, 1)\n    h, w, c = frame.shape\n\n    # 初始化画布\n    if canvas is None:\n        canvas = np.zeros((h, w, 3), dtype=np.uint8)\n\n    rgb_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)\n    results = hands.process(rgb_frame)\n\n    if results.multi_hand_landmarks:\n        landmarks = results.multi_hand_landmarks[0].landmark\n\n        # 获取食指指尖位置\n        x = int(landmarks[8].x * w)\n        y = int(landmarks[8].y * h)\n\n        # 检测是否在绘画模式（食指伸直，其他弯曲）\n        fingers = get_finger_states(landmarks)\n        if fingers == [0, 1, 0, 0, 0]:  # 只伸食指\n            # 绘制轨迹\n            if prev_x is not None:\n                cv2.line(canvas, (prev_x, prev_y), (x, y), draw_color, brush_size)\n            prev_x, prev_y = x, y\n        else:\n            prev_x, prev_y = None, None\n\n        # 绘制指尖位置\n        cv2.circle(frame, (x, y), 10, (255, 0, 0), -1)\n\n    # 合并画布和摄像头画面\n    frame = cv2.addWeighted(frame, 1, canvas, 0.5, 0)\n\n    cv2.imshow('Air Drawing', frame)\n    if cv2.waitKey(1) & 0xFF == ord('q'):\n        break\n\ncap.release()\ncv2.destroyAllWindows()\n```\n\n### 6.3 跨课程出现\n\n| 课程编号 | 课程名称 | 具体内容 |\n|----------|---------|---------|\n| PYAI 2-3-9 | 手势绘画板 | 空中绘画 |\n\n---"
    },
    {
      "title": "七、手势控制应用",
      "content": "### 7.1 手势映射到游戏控制\n\n```python\nimport pygame\n\n# 手势到按键的映射\nGESTURE_TO_KEY = {\n    (0, 1, 0, 0, 0): pygame.K_UP,     # 食指 = 上\n    (0, 1, 1, 0, 0): pygame.K_DOWN,   # 食指+中指 = 下\n    (1, 0, 0, 0, 0): pygame.K_LEFT,   # 拇指 = 左\n    (0, 0, 0, 0, 1): pygame.K_RIGHT,  # 小拇指 = 右\n    (1, 1, 1, 1, 1): pygame.K_SPACE,  # 五指 = 空格\n}\n\ndef gesture_to_key(finger_states):\n    \"\"\"将手势转换为按键\"\"\"\n    return GESTURE_TO_KEY.get(tuple(finger_states), None)\n```\n\n### 7.2 手势控制LED\n\n```python\n# 假设使用GPIO控制LED\n# from gpiozero import LED\n\ndef gesture_control_led(finger_states, leds):\n    \"\"\"\n    根据手势控制LED\n    leds: [led1, led2, led3, led4, led5] 对应五根手指\n    \"\"\"\n    for i, state in enumerate(finger_states):\n        if state == 1:\n            leds[i].on()\n        else:\n            leds[i].off()\n```\n\n### 7.3 跨课程出现\n\n| 课程编号 | 课程名称 | 具体内容 |\n|----------|---------|---------|\n| PYAI 2-3-8 | 手势控制游戏 | 手势映射控制 |\n\n---"
    },
    {
      "title": "八、完整项目：石头剪刀布机器人",
      "content": "### 8.1 系统架构\n\n```\n摄像头 → 手势识别 → 游戏逻辑 → 结果显示\n                        ↓\n                   电脑随机出拳\n```\n\n### 8.2 核心代码\n\n```python\nimport cv2\nimport mediapipe as mp\nimport random\nimport time\n\nclass RPSGame:\n    def __init__(self):\n        self.mp_hands = mp.solutions.hands\n        self.hands = self.mp_hands.Hands(\n            max_num_hands=1,\n            min_detection_confidence=0.7\n        )\n        self.cap = cv2.VideoCapture(0)\n\n        self.player_score = 0\n        self.computer_score = 0\n        self.last_play_time = 0\n        self.cooldown = 2  # 2秒冷却\n\n    def get_finger_states(self, landmarks):\n        \"\"\"检测手指状态\"\"\"\n        fingers = []\n\n        # 拇指\n        if landmarks[4].x < landmarks[3].x:\n            fingers.append(1)\n        else:\n            fingers.append(0)\n\n        # 其他四指\n        for tip_idx in [8, 12, 16, 20]:\n            if landmarks[tip_idx].y < landmarks[tip_idx - 2].y:\n                fingers.append(1)\n            else:\n                fingers.append(0)\n\n        return fingers\n\n    def classify_rps(self, fingers):\n        \"\"\"识别石头剪刀布\"\"\"\n        if fingers == [0, 0, 0, 0, 0]:\n            return 'ROCK'\n        elif fingers == [0, 1, 1, 0, 0]:\n            return 'SCISSORS'\n        elif fingers == [1, 1, 1, 1, 1]:\n            return 'PAPER'\n        return None\n\n    def computer_play(self):\n        \"\"\"电脑随机出拳\"\"\"\n        return random.choice(['ROCK', 'SCISSORS', 'PAPER'])\n\n    def judge(self, player, computer):\n        \"\"\"判断胜负\"\"\"\n        if player == computer:\n            return 'TIE'\n        elif (player == 'ROCK' and computer == 'SCISSORS') or \\\n             (player == 'SCISSORS' and computer == 'PAPER') or \\\n             (player == 'PAPER' and computer == 'ROCK'):\n            return 'WIN'\n        else:\n            return 'LOSE'\n\n    def run(self):\n        \"\"\"运行游戏\"\"\"\n        while True:\n            ret, frame = self.cap.read()\n            if not ret:\n                break\n\n            frame = cv2.flip(frame, 1)\n            h, w, c = frame.shape\n\n            rgb_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)\n            results = self.hands.process(rgb_frame)\n\n            current_time = time.time()\n\n            if results.multi_hand_landmarks:\n                landmarks = results.multi_hand_landmarks[0].landmark\n                fingers = self.get_finger_states(landmarks)\n                player_gesture = self.classify_rps(fingers)\n\n                if player_gesture and current_time - self.last_play_time > self.cooldown:\n                    computer_gesture = self.computer_play()\n                    result = self.judge(player_gesture, computer_gesture)\n\n                    if result == 'WIN':\n                        self.player_score += 1\n                    elif result == 'LOSE':\n                        self.computer_score += 1\n\n                    self.last_play_time = current_time\n\n                    # 显示结果\n                    cv2.putText(frame, f\"You: {player_gesture}\", (10, 50),\n                                cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2)\n                    cv2.putText(frame, f\"Computer: {computer_gesture}\", (10, 100),\n                                cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 0, 255), 2)\n                    cv2.putText(frame, f\"Result: {result}\", (10, 150),\n                                cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 255, 0), 2)\n\n            # 显示分数\n            cv2.putText(frame, f\"Score - You: {self.player_score} Computer: {self.computer_score}\",\n                        (10, h - 20), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 255, 255), 2)\n\n            cv2.imshow('Rock Paper Scissors', frame)\n            if cv2.waitKey(1) & 0xFF == ord('q'):\n                break\n\n        self.cap.release()\n        cv2.destroyAllWindows()\n\n# 运行游戏\nif __name__ == '__main__':\n    game = RPSGame()\n    game.run()\n```\n\n### 8.3 跨课程出现\n\n| 课程编号 | 课程名称 | 具体内容 |\n|----------|---------|---------|\n| PYAI 2-3-10 | 机械手游戏(1) | 基础版 |\n| PYAI 2-3-11 | 机械手游戏(2) | 策略优化版 |\n\n---"
    },
    {
      "title": "九、常见错误与禁忌",
      "content": "| 错误 | 后果 | 正确做法 |\n|------|------|---------|\n| ❌ BGR直接传给MediaPipe | 检测失败 | 先转换为RGB |\n| ❌ 不翻转画面 | 左右颠倒 | 使用`cv2.flip(frame, 1)` |\n| ❌ 不区分左右手 | 拇指判断错误 | 检查handedness |\n| ❌ 阈值设置不当 | 手势误判 | 根据实际环境调整 |\n| ❌ 不处理检测失败 | 程序崩溃 | 检查`results.multi_hand_landmarks` |\n\n---"
    },
    {
      "title": "十、教学建议",
      "content": "### 10.1 认知进阶路线\n\n```\nPYAI 2-3-7          PYAI 2-3-8          PYAI 2-3-9          PYAI 2-3-10\n手部检测     →      手势分类     →      指尖追踪     →      游戏应用\n   ↓                   ↓                   ↓                   ↓\n 21关键点            手指状态            坐标转换            完整项目\n```\n\n### 10.2 常见教学难点\n\n| 难点 | 解决方案 |\n|------|---------|\n| 关键点索引记忆 | 提供手部关键点图示，只记指尖索引 |\n| 左右手判断 | 用镜像翻转简化，或明确说明左右手差异 |\n| 手势分类逻辑 | 先从简单手势开始（握拳、张开） |\n| 追踪抖动 | 添加平滑滤波或降低灵敏度 |\n\n### 10.3 教学话术\n\n> \"手势识别就像教电脑'看手语'。MediaPipe帮我们找到手上的21个关键点，就像在手上贴了21个小标签。通过比较这些标签的位置，我们就能知道哪根手指伸直了、哪根弯曲了。\"\n\n---\n\n**维护者**：知识库管理员\n**关联文件**：[AI知识总表.md](AI知识总表.md)、[人脸识别.md](人脸识别.md)"
    }
  ],
  "full_content": "# 手势识别\n\n> **用途**：手势检测与识别技术在各课程中的应用详解\n> **更新日期**：2026-02-10\n> **数据来源**：萃取报告/PythonAI/\n\n---\n\n## 一、技术概述\n\n### 1.1 手势识别流程\n\n```\n图像采集 → 手部检测 → 关键点提取 → 手势分类 → 指令执行\n```\n\n### 1.2 跨课程出现\n\n| 课程编号 | 课程名称 | 具体内容 |\n|----------|---------|---------|\n| PYAI 2-3-7 | 手势识别基础 | MediaPipe Hands |\n| PYAI 2-3-8 | 手势控制游戏 | 手势映射 |\n| PYAI 2-3-9 | 手势绘画板 | 指尖追踪 |\n| PYAI 2-3-10 | 机械手游戏(1) | 石头剪刀布 |\n| PYAI 2-3-11 | 机械手游戏(2) | 策略优化 |\n\n---\n\n## 二、MediaPipe Hands\n\n### 2.1 简介\n\nMediaPipe Hands 可以检测21个手部关键点，支持单手或双手检测，用于手势识别、手语翻译等。\n\n### 2.2 安装\n\n```bash\npip install mediapipe\n```\n\n### 2.3 基本使用\n\n```python\nimport cv2\nimport mediapipe as mp\n\n# 初始化\nmp_hands = mp.solutions.hands\nhands = mp_hands.Hands(\n    static_image_mode=False,      # 视频模式\n    max_num_hands=2,              # 最多检测2只手\n    min_detection_confidence=0.7, # 检测置信度\n    min_tracking_confidence=0.5   # 追踪置信度\n)\n\n# 绘制工具\nmp_drawing = mp.solutions.drawing_utils\nmp_drawing_styles = mp.solutions.drawing_styles\n\ncap = cv2.VideoCapture(0)\n\nwhile True:\n    ret, frame = cap.read()\n    if not ret:\n        break\n\n    # 水平翻转（镜像效果）\n    frame = cv2.flip(frame, 1)\n\n    # 转换颜色空间（重要！）\n    rgb_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)\n\n    # 检测手部\n    results = hands.process(rgb_frame)\n\n    if results.multi_hand_landmarks:\n        for hand_landmarks in results.multi_hand_landmarks:\n            # 绘制关键点和连接线\n            mp_drawing.draw_landmarks(\n                frame,\n                hand_landmarks,\n                mp_hands.HAND_CONNECTIONS,\n                mp_drawing_styles.get_default_hand_landmarks_style(),\n                mp_drawing_styles.get_default_hand_connections_style()\n            )\n\n    cv2.imshow('Hand Detection', frame)\n    if cv2.waitKey(1) & 0xFF == ord('q'):\n        break\n\ncap.release()\ncv2.destroyAllWindows()\n```\n\n### 2.4 获取关键点坐标\n\n```python\nif results.multi_hand_landmarks:\n    hand_landmarks = results.multi_hand_landmarks[0]\n    landmarks = hand_landmarks.landmark\n\n    # 获取特定关键点\n    h, w, c = frame.shape\n    point = landmarks[8]  # 食指指尖\n    x = int(point.x * w)\n    y = int(point.y * h)\n    z = point.z  # 深度（相对值）\n```\n\n---\n\n## 三、手部关键点索引\n\n### 3.1 21个关键点分布\n\n```\n        8   12  16  20\n        |   |   |   |\n    4   7   11  15  19\n    |   |   |   |   |\n    3   6   10  14  18\n    |   |   |   |   |\n    2   5   9   13  17\n     \\   \\  |  /   /\n      \\   \\ | /   /\n       1----0----\n           手腕\n```\n\n### 3.2 关键点索引表\n\n| 索引 | 名称 | 说明 |\n|------|------|------|\n| 0 | WRIST | 手腕 |\n| 1 | THUMB_CMC | 拇指根部 |\n| 2 | THUMB_MCP | 拇指第一关节 |\n| 3 | THUMB_IP | 拇指第二关节 |\n| 4 | THUMB_TIP | 拇指指尖 |\n| 5 | INDEX_FINGER_MCP | 食指根部 |\n| 6 | INDEX_FINGER_PIP | 食指第一关节 |\n| 7 | INDEX_FINGER_DIP | 食指第二关节 |\n| 8 | INDEX_FINGER_TIP | 食指指尖 |\n| 9 | MIDDLE_FINGER_MCP | 中指根部 |\n| 10 | MIDDLE_FINGER_PIP | 中指第一关节 |\n| 11 | MIDDLE_FINGER_DIP | 中指第二关节 |\n| 12 | MIDDLE_FINGER_TIP | 中指指尖 |\n| 13 | RING_FINGER_MCP | 无名指根部 |\n| 14 | RING_FINGER_PIP | 无名指第一关节 |\n| 15 | RING_FINGER_DIP | 无名指第二关节 |\n| 16 | RING_FINGER_TIP | 无名指指尖 |\n| 17 | PINKY_MCP | 小拇指根部 |\n| 18 | PINKY_PIP | 小拇指第一关节 |\n| 19 | PINKY_DIP | 小拇指第二关节 |\n| 20 | PINKY_TIP | 小拇指指尖 |\n\n### 3.3 常用关键点组\n\n```python\n# 指尖索引\nFINGER_TIPS = [4, 8, 12, 16, 20]\n\n# 指根索引（MCP关节）\nFINGER_MCPS = [1, 5, 9, 13, 17]\n\n# 第二关节索引（PIP关节）\nFINGER_PIPS = [2, 6, 10, 14, 18]\n```\n\n---\n\n## 四、手指状态检测\n\n### 4.1 原理\n\n通过比较指尖和关节的位置判断手指是否伸直：\n- **四指**：指尖y坐标 < 第二关节y坐标 → 伸直\n- **拇指**：指尖x坐标与第一关节x坐标比较（需考虑左右手）\n\n### 4.2 跨课程出现\n\n| 课程编号 | 课程名称 | 具体内容 |\n|----------|---------|---------|\n| PYAI 2-3-7 | 手势识别基础 | 手指状态检测 |\n| PYAI 2-3-8 | 手势控制游戏 | 手势分类 |\n\n### 4.3 实现代码\n\n```python\ndef get_finger_states(landmarks, handedness='Right'):\n    \"\"\"\n    检测每根手指是否伸直\n    返回: [拇指, 食指, 中指, 无名指, 小拇指] 的状态列表\n    1 = 伸直, 0 = 弯曲\n    \"\"\"\n    fingers = []\n\n    # 拇指（需要考虑左右手）\n    if handedness == 'Right':\n        # 右手：指尖x < 第一关节x 表示伸直\n        if landmarks[4].x < landmarks[3].x:\n            fingers.append(1)\n        else:\n            fingers.append(0)\n    else:\n        # 左手：指尖x > 第一关节x 表示伸直\n        if landmarks[4].x > landmarks[3].x:\n            fingers.append(1)\n        else:\n            fingers.append(0)\n\n    # 其他四指：指尖y < 第二关节y 表示伸直\n    for tip_idx in [8, 12, 16, 20]:\n        pip_idx = tip_idx - 2  # 对应的第二关节\n        if landmarks[tip_idx].y < landmarks[pip_idx].y:\n            fingers.append(1)\n        else:\n            fingers.append(0)\n\n    return fingers\n```\n\n### 4.4 获取手的左右信息\n\n```python\nif results.multi_hand_landmarks and results.multi_handedness:\n    for hand_landmarks, handedness in zip(\n        results.multi_hand_landmarks,\n        results.multi_handedness\n    ):\n        # 获取左右手信息\n        hand_label = handedness.classification[0].label  # 'Left' 或 'Right'\n        confidence = handedness.classification[0].score\n\n        landmarks = hand_landmarks.landmark\n        fingers = get_finger_states(landmarks, hand_label)\n```\n\n---\n\n## 五、手势分类\n\n### 5.1 基本手势定义\n\n```python\n# 手势映射表\n# 格式: (拇指, 食指, 中指, 无名指, 小拇指) -> 手势名称\nGESTURE_MAP = {\n    (0, 0, 0, 0, 0): 'FIST',      # 握拳\n    (1, 1, 1, 1, 1): 'FIVE',      # 张开五指\n    (0, 1, 0, 0, 0): 'ONE',       # 数字1\n    (0, 1, 1, 0, 0): 'TWO',       # 数字2 / 剪刀\n    (0, 1, 1, 1, 0): 'THREE',     # 数字3\n    (0, 1, 1, 1, 1): 'FOUR',      # 数字4\n    (1, 0, 0, 0, 0): 'THUMB_UP',  # 点赞\n    (0, 1, 0, 0, 1): 'ROCK',      # 摇滚手势\n    (1, 1, 0, 0, 1): 'CALL',      # 打电话手势\n    (0, 0, 0, 0, 1): 'PINKY',     # 小拇指\n}\n\ndef classify_gesture(finger_states):\n    \"\"\"根据手指状态分类手势\"\"\"\n    return GESTURE_MAP.get(tuple(finger_states), 'UNKNOWN')\n```\n\n### 5.2 石头剪刀布识别\n\n```python\n# 石头剪刀布手势\nRPS_GESTURES = {\n    (0, 0, 0, 0, 0): 'ROCK',      # 石头 = 握拳\n    (0, 1, 1, 0, 0): 'SCISSORS',  # 剪刀 = 食指+中指\n    (1, 1, 1, 1, 1): 'PAPER',     # 布 = 五指张开\n}\n\ndef classify_rps(finger_states):\n    \"\"\"识别石头剪刀布手势\"\"\"\n    return RPS_GESTURES.get(tuple(finger_states), None)\n```\n\n### 5.3 跨课程出现\n\n| 课程编号 | 课程名称 | 具体内容 |\n|----------|---------|---------|\n| PYAI 2-3-10 | 机械手游戏(1) | 石头剪刀布识别 |\n| PYAI 2-3-11 | 机械手游戏(2) | 策略优化 |\n\n---\n\n## 六、指尖追踪\n\n### 6.1 基本追踪\n\n```python\ndef get_fingertip_position(landmarks, frame_shape, finger_idx=8):\n    \"\"\"\n    获取指尖在画面中的像素坐标\n    finger_idx: 4=拇指, 8=食指, 12=中指, 16=无名指, 20=小拇指\n    \"\"\"\n    h, w, c = frame_shape\n    tip = landmarks[finger_idx]\n    x = int(tip.x * w)\n    y = int(tip.y * h)\n    return x, y\n```\n\n### 6.2 空中绘画\n\n```python\nimport cv2\nimport mediapipe as mp\nimport numpy as np\n\nmp_hands = mp.solutions.hands\nhands = mp_hands.Hands(max_num_hands=1, min_detection_confidence=0.7)\n\ncap = cv2.VideoCapture(0)\n\n# 创建画布\ncanvas = None\nprev_x, prev_y = None, None\ndraw_color = (0, 255, 0)  # 绿色\nbrush_size = 5\n\nwhile True:\n    ret, frame = cap.read()\n    if not ret:\n        break\n\n    frame = cv2.flip(frame, 1)\n    h, w, c = frame.shape\n\n    # 初始化画布\n    if canvas is None:\n        canvas = np.zeros((h, w, 3), dtype=np.uint8)\n\n    rgb_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)\n    results = hands.process(rgb_frame)\n\n    if results.multi_hand_landmarks:\n        landmarks = results.multi_hand_landmarks[0].landmark\n\n        # 获取食指指尖位置\n        x = int(landmarks[8].x * w)\n        y = int(landmarks[8].y * h)\n\n        # 检测是否在绘画模式（食指伸直，其他弯曲）\n        fingers = get_finger_states(landmarks)\n        if fingers == [0, 1, 0, 0, 0]:  # 只伸食指\n            # 绘制轨迹\n            if prev_x is not None:\n                cv2.line(canvas, (prev_x, prev_y), (x, y), draw_color, brush_size)\n            prev_x, prev_y = x, y\n        else:\n            prev_x, prev_y = None, None\n\n        # 绘制指尖位置\n        cv2.circle(frame, (x, y), 10, (255, 0, 0), -1)\n\n    # 合并画布和摄像头画面\n    frame = cv2.addWeighted(frame, 1, canvas, 0.5, 0)\n\n    cv2.imshow('Air Drawing', frame)\n    if cv2.waitKey(1) & 0xFF == ord('q'):\n        break\n\ncap.release()\ncv2.destroyAllWindows()\n```\n\n### 6.3 跨课程出现\n\n| 课程编号 | 课程名称 | 具体内容 |\n|----------|---------|---------|\n| PYAI 2-3-9 | 手势绘画板 | 空中绘画 |\n\n---\n\n## 七、手势控制应用\n\n### 7.1 手势映射到游戏控制\n\n```python\nimport pygame\n\n# 手势到按键的映射\nGESTURE_TO_KEY = {\n    (0, 1, 0, 0, 0): pygame.K_UP,     # 食指 = 上\n    (0, 1, 1, 0, 0): pygame.K_DOWN,   # 食指+中指 = 下\n    (1, 0, 0, 0, 0): pygame.K_LEFT,   # 拇指 = 左\n    (0, 0, 0, 0, 1): pygame.K_RIGHT,  # 小拇指 = 右\n    (1, 1, 1, 1, 1): pygame.K_SPACE,  # 五指 = 空格\n}\n\ndef gesture_to_key(finger_states):\n    \"\"\"将手势转换为按键\"\"\"\n    return GESTURE_TO_KEY.get(tuple(finger_states), None)\n```\n\n### 7.2 手势控制LED\n\n```python\n# 假设使用GPIO控制LED\n# from gpiozero import LED\n\ndef gesture_control_led(finger_states, leds):\n    \"\"\"\n    根据手势控制LED\n    leds: [led1, led2, led3, led4, led5] 对应五根手指\n    \"\"\"\n    for i, state in enumerate(finger_states):\n        if state == 1:\n            leds[i].on()\n        else:\n            leds[i].off()\n```\n\n### 7.3 跨课程出现\n\n| 课程编号 | 课程名称 | 具体内容 |\n|----------|---------|---------|\n| PYAI 2-3-8 | 手势控制游戏 | 手势映射控制 |\n\n---\n\n## 八、完整项目：石头剪刀布机器人\n\n### 8.1 系统架构\n\n```\n摄像头 → 手势识别 → 游戏逻辑 → 结果显示\n                        ↓\n                   电脑随机出拳\n```\n\n### 8.2 核心代码\n\n```python\nimport cv2\nimport mediapipe as mp\nimport random\nimport time\n\nclass RPSGame:\n    def __init__(self):\n        self.mp_hands = mp.solutions.hands\n        self.hands = self.mp_hands.Hands(\n            max_num_hands=1,\n            min_detection_confidence=0.7\n        )\n        self.cap = cv2.VideoCapture(0)\n\n        self.player_score = 0\n        self.computer_score = 0\n        self.last_play_time = 0\n        self.cooldown = 2  # 2秒冷却\n\n    def get_finger_states(self, landmarks):\n        \"\"\"检测手指状态\"\"\"\n        fingers = []\n\n        # 拇指\n        if landmarks[4].x < landmarks[3].x:\n            fingers.append(1)\n        else:\n            fingers.append(0)\n\n        # 其他四指\n        for tip_idx in [8, 12, 16, 20]:\n            if landmarks[tip_idx].y < landmarks[tip_idx - 2].y:\n                fingers.append(1)\n            else:\n                fingers.append(0)\n\n        return fingers\n\n    def classify_rps(self, fingers):\n        \"\"\"识别石头剪刀布\"\"\"\n        if fingers == [0, 0, 0, 0, 0]:\n            return 'ROCK'\n        elif fingers == [0, 1, 1, 0, 0]:\n            return 'SCISSORS'\n        elif fingers == [1, 1, 1, 1, 1]:\n            return 'PAPER'\n        return None\n\n    def computer_play(self):\n        \"\"\"电脑随机出拳\"\"\"\n        return random.choice(['ROCK', 'SCISSORS', 'PAPER'])\n\n    def judge(self, player, computer):\n        \"\"\"判断胜负\"\"\"\n        if player == computer:\n            return 'TIE'\n        elif (player == 'ROCK' and computer == 'SCISSORS') or \\\n             (player == 'SCISSORS' and computer == 'PAPER') or \\\n             (player == 'PAPER' and computer == 'ROCK'):\n            return 'WIN'\n        else:\n            return 'LOSE'\n\n    def run(self):\n        \"\"\"运行游戏\"\"\"\n        while True:\n            ret, frame = self.cap.read()\n            if not ret:\n                break\n\n            frame = cv2.flip(frame, 1)\n            h, w, c = frame.shape\n\n            rgb_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)\n            results = self.hands.process(rgb_frame)\n\n            current_time = time.time()\n\n            if results.multi_hand_landmarks:\n                landmarks = results.multi_hand_landmarks[0].landmark\n                fingers = self.get_finger_states(landmarks)\n                player_gesture = self.classify_rps(fingers)\n\n                if player_gesture and current_time - self.last_play_time > self.cooldown:\n                    computer_gesture = self.computer_play()\n                    result = self.judge(player_gesture, computer_gesture)\n\n                    if result == 'WIN':\n                        self.player_score += 1\n                    elif result == 'LOSE':\n                        self.computer_score += 1\n\n                    self.last_play_time = current_time\n\n                    # 显示结果\n                    cv2.putText(frame, f\"You: {player_gesture}\", (10, 50),\n                                cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2)\n                    cv2.putText(frame, f\"Computer: {computer_gesture}\", (10, 100),\n                                cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 0, 255), 2)\n                    cv2.putText(frame, f\"Result: {result}\", (10, 150),\n                                cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 255, 0), 2)\n\n            # 显示分数\n            cv2.putText(frame, f\"Score - You: {self.player_score} Computer: {self.computer_score}\",\n                        (10, h - 20), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 255, 255), 2)\n\n            cv2.imshow('Rock Paper Scissors', frame)\n            if cv2.waitKey(1) & 0xFF == ord('q'):\n                break\n\n        self.cap.release()\n        cv2.destroyAllWindows()\n\n# 运行游戏\nif __name__ == '__main__':\n    game = RPSGame()\n    game.run()\n```\n\n### 8.3 跨课程出现\n\n| 课程编号 | 课程名称 | 具体内容 |\n|----------|---------|---------|\n| PYAI 2-3-10 | 机械手游戏(1) | 基础版 |\n| PYAI 2-3-11 | 机械手游戏(2) | 策略优化版 |\n\n---\n\n## 九、常见错误与禁忌\n\n| 错误 | 后果 | 正确做法 |\n|------|------|---------|\n| ❌ BGR直接传给MediaPipe | 检测失败 | 先转换为RGB |\n| ❌ 不翻转画面 | 左右颠倒 | 使用`cv2.flip(frame, 1)` |\n| ❌ 不区分左右手 | 拇指判断错误 | 检查handedness |\n| ❌ 阈值设置不当 | 手势误判 | 根据实际环境调整 |\n| ❌ 不处理检测失败 | 程序崩溃 | 检查`results.multi_hand_landmarks` |\n\n---\n\n## 十、教学建议\n\n### 10.1 认知进阶路线\n\n```\nPYAI 2-3-7          PYAI 2-3-8          PYAI 2-3-9          PYAI 2-3-10\n手部检测     →      手势分类     →      指尖追踪     →      游戏应用\n   ↓                   ↓                   ↓                   ↓\n 21关键点            手指状态            坐标转换            完整项目\n```\n\n### 10.2 常见教学难点\n\n| 难点 | 解决方案 |\n|------|---------|\n| 关键点索引记忆 | 提供手部关键点图示，只记指尖索引 |\n| 左右手判断 | 用镜像翻转简化，或明确说明左右手差异 |\n| 手势分类逻辑 | 先从简单手势开始（握拳、张开） |\n| 追踪抖动 | 添加平滑滤波或降低灵敏度 |\n\n### 10.3 教学话术\n\n> \"手势识别就像教电脑'看手语'。MediaPipe帮我们找到手上的21个关键点，就像在手上贴了21个小标签。通过比较这些标签的位置，我们就能知道哪根手指伸直了、哪根弯曲了。\"\n\n---\n\n**维护者**：知识库管理员\n**关联文件**：[AI知识总表.md](AI知识总表.md)、[人脸识别.md](人脸识别.md)\n"
}