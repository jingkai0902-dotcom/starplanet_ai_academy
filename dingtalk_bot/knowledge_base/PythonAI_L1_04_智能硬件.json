{
  "title": "PythonAI萃取：L1-4 智能硬件与AI应用",
  "source": "C:\\Users\\Frank.J\\starplanet_ai_academy\\知识库\\萃取报告\\PythonAI\\L1_04_智能硬件.md",
  "sections": [
    {
      "title": "单元概览",
      "content": "| 项目 | 内容 |\n|------|------|\n| **单元编号** | PYAI 1-4 |\n| **单元名称** | 智能硬件与AI应用 |\n| **适用年龄** | 三年级及以上（8-10岁） |\n| **课时数** | 10节 × 90分钟 |\n| **核心目标** | 实现软硬结合，使用Python控制ESP32掌控板及传感器，引入OpenCV机器视觉 |\n| **主要教具** | ESP32/掌控板、光线传感器、气体传感器、土壤湿度传感器、舵机、RGB灯 |\n\n**底层逻辑**\n实现软硬结合，了解物联网(IoT)与机器视觉基础，建立\"感知层-处理层-应用层\"的系统思维。\n\n**单元教学策略**\n- 硬件基础（01）：认识ESP32、引脚、电路基础\n- 传感器应用（03-05）：光线传感器、气体传感器、自动化控制\n- AI视觉（06-08）：OpenCV、人脸检测、系统集成\n- 综合项目（10-12）：智能花房、物联网架构复盘\n\n`#执行层` `#测评项`\n[UID: PYAI-14-001]\n[关联: STEM-S3-004 STEM大班智能硬件（前置基础）]\n[关联: CODE3-M1-001 CODE智能系统（前置基础）]\n[关联: PYAI-24-001 PythonAI计算机视觉（进阶衔接）]\n\n---"
    },
    {
      "title": "课程列表",
      "content": "| 课次 | 课程名称 | 核心知识点 | 项目内容 | 认知负荷 |\n|------|----------|------------|----------|----------|\n| 1-4-1 | 硬件系统 | 软硬件关系、ESP32引脚、电路基础 | 硬件认知 | 中 |\n| 1-4-2 | 按钮控制LED | GPIO输入、button.value()、消抖处理 | 按钮开关灯 | 中 |\n| 1-4-3 | 智能光控(1) | mpython_conn库、LED/RGB控制、光线传感器 | 光控灯搭建 | 中-高 |\n| 1-4-4 | 智能光控(2) | 模拟量读取get_analog()、阈值判断 | 自动夜灯 | 中-高 |\n| 1-4-5 | 智能通风 | MQ-2B气体传感器、电机控制 | 智能通风系统 | 高 |\n| 1-4-6 | 智能门禁(1) | AI视觉基础、cv2.VideoCapture | 人脸捕捉相机 | 高 |\n| 1-4-7 | 智能门禁(2) | 灰度处理cvtColor、特征匹配matchTemplate | 人脸比对算法 | 高 |\n| 1-4-8 | 智能门禁(3) | 舵机控制Servo、系统集成 | 刷脸开门 | 高 |\n| 1-4-9 | 音强流水灯 | NeoPixel灯带、声音传感器、流水灯算法 | 音乐律动灯 | 中-高 |\n| 1-4-10 | 智能花房(1) | 土壤湿度传感器、水泵控制 | 自动浇水系统 | 中-高 |\n| 1-4-11 | 智能花房(2) | OLED屏幕显示、数据可视化 | 可视化智能灌溉 | 高 |\n| 1-4-12 | 家居回顾 | 物联网架构复习、AI流程复盘 | 智能家居方案展示 | 中 |\n\n---"
    },
    {
      "title": "通用教学流程（90分钟）",
      "content": "| 环节 | 时间 | 内容 | 认知负荷 | IFC标签 |\n|------|------|------|----------|---------|\n| 课堂问候 | 2分钟 | 自我介绍、安全规则强调 | `#低负荷-热身` | `#IFC-预防` |\n| 课程回顾 | 5分钟 | 复习上节课代码和硬件知识 | `#低负荷-热身` | `#IFC-预防` |\n| 知识讲解 | 15分钟 | 新传感器/新概念讲解 | `#中负荷-操练` | `#IFC-即时` |\n| 硬件搭建 | 20分钟 | 接线、组装硬件 | `#高负荷-产出` | `#IFC-即时` |\n| 调节休息 | 3分钟 | 站起来活动、眼保健操 | `#调节-放松` | - |\n| 编程调试 | 30分钟 | 编写代码、调试系统 | `#高负荷-产出` | `#IFC-即时` |\n| 成果展示 | 10分钟 | 演示项目、分享思路 | `#低负荷-热身` | `#IFC-复盘` |\n\n`#执行层` `#测评项`\n[UID: PYAI-14-FLOW-001]\n\n---"
    },
    {
      "title": "详细课程萃取",
      "content": "### 1-4-1 硬件系统\n\n#### 课程基本信息\n\n| 项目 | 内容 |\n|------|------|\n| **课程编号** | 1-4-1 |\n| **课程名称** | 硬件系统 - 认识ESP32 |\n| **认知负荷** | 中 |\n| **核心技能** | 软硬件关系、ESP32引脚、电路基础 |\n\n#### 详细教学流程\n\n**步骤1：课程导入（5分钟）** `#低负荷-热身` `#IFC-预防`\n\n**教师话术**\n> \"同学们，之前我们写的Python代码都是在电脑上运行的。今天开始，我们要让代码控制真实的硬件！这就是**物联网(IoT)**的魅力——用代码控制物理世界。\"\n\n---\n\n**步骤2：知识讲解（15分钟）** `#中负荷-操练` `#IFC-即时`\n\n**教师话术**\n> \"首先认识我们的主角——**ESP32掌控板**！\n>\n> **什么是ESP32？**\n> - 一块小型计算机，可以运行MicroPython代码\n> - 内置WiFi和蓝牙，可以联网\n> - 有很多**引脚(Pin)**，用来连接传感器和执行器\n>\n> **引脚类型**：\n> ```\n> VCC (3.3V) - 电源正极，给传感器供电\n> GND        - 电源负极，接地\n> P0-P20     - 数字/模拟引脚，连接传感器\n> ```\n>\n> **电路基础**：\n> - 电流从VCC流出，经过元件，流回GND\n> - 必须形成**闭合回路**才能工作\n> - **短路**：VCC直接接GND，会烧毁开发板！\"\n\n**核心代码模式**\n\n```python\n# MicroPython基础导入\nfrom mpython import *\nimport time\n\n# 控制板载LED\nled.on()   # 开灯\nled.off()  # 关灯\n\n# 控制板载蜂鸣器\nbuzzer.on()   # 响\nbuzzer.off()  # 停\n```\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 不理解引脚 | 用插座类比 | \"引脚就像插座，传感器插上去就能用\" |\n| 混淆VCC和GND | 用水流类比 | \"VCC是水龙头，GND是下水道\" |\n| 想知道为什么用3.3V | 解释电压 | \"ESP32是3.3V系统，5V会烧坏\" |\n\n---\n\n**步骤3：硬件认知（20分钟）** `#高负荷-产出` `#IFC-即时`\n\n**教师话术**\n> \"现在我们来认识开发板上的各个部件：\n>\n> 1. **USB接口**：连接电脑，上传代码\n> 2. **复位按钮**：重启开发板\n> 3. **板载LED**：可以用代码控制的小灯\n> 4. **板载蜂鸣器**：可以发出声音\n> 5. **OLED屏幕**：显示文字和图形\n> 6. **引脚排**：连接外部传感器\n>\n> **安全规则（必须牢记）**：\n> - 接线前必须断电\n> - 红线接VCC，黑线接GND\n> - 不确定时先问老师\"\n\n**禁忌提醒**\n❌ **带电接线**——会短路烧毁开发板\n❌ **VCC直接接GND**——这是短路，绝对禁止\n❌ **开发板放金属表面通电**——底部引脚会短路\n\n---\n\n**步骤4：编程体验（30分钟）** `#高负荷-产出` `#IFC-即时`\n\n**教师话术**\n> \"让我们写第一个硬件控制程序——让LED闪烁！\n>\n> ```python\n> from mpython import *\n> import time\n>\n> while True:\n>     led.on()\n>     time.sleep(0.5)  # 亮0.5秒\n>     led.off()\n>     time.sleep(0.5)  # 灭0.5秒\n> ```\n>\n> 上传代码后，观察LED是不是在闪烁？\"\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 代码上传失败 | 检查USB连接 | 确认选择了正确的串口 |\n| LED不闪烁 | 检查代码缩进 | while循环内的代码要缩进 |\n| 想改变闪烁速度 | 修改sleep参数 | \"把0.5改成0.1会怎样？\" |\n\n---\n\n**步骤5：成果展示（10分钟）** `#低负荷-热身` `#IFC-复盘`\n\n**教师话术**\n> \"谁的LED闪烁成功了？试着让蜂鸣器也响起来！\n>\n> ```python\n> buzzer.on()\n> time.sleep(0.1)\n> buzzer.off()\n> ```\"\n\n---\n\n**核心知识点**\n- ESP32是可编程的小型计算机，运行MicroPython\n- 引脚类型：VCC(电源)、GND(接地)、P0-P20(信号)\n- 电路必须形成闭合回路才能工作\n- 安全第一：接线前断电，避免短路\n\n**底层逻辑**\n- **软硬结合**：代码 → 硬件动作\n- **物联网基础**：感知 → 处理 → 执行\n\n`#执行层` `#测评项`\n[UID: PYAI-14-01-001]\n[关联: STEM-S3-004 STEM大班智能硬件（前置基础）]\n\n---\n\n### 1-4-2 按钮控制LED\n\n#### 课程基本信息\n\n| 项目 | 内容 |\n|------|------|\n| **课程编号** | 1-4-2 |\n| **课程名称** | 按钮控制LED |\n| **认知负荷** | 中 |\n| **核心技能** | GPIO输入、button.value()、消抖处理 |\n\n#### 详细教学流程\n\n**步骤1：课程回顾（5分钟）** `#低负荷-热身` `#IFC-预防`\n\n**教师话术**\n> \"上节课我们学会了用代码控制LED闪烁。但那是自动的，如果我想用按钮来控制呢？今天学习**GPIO输入**——让开发板'感知'按钮状态！\"\n\n---\n\n**步骤2：知识讲解（15分钟）** `#中负荷-操练` `#IFC-即时`\n\n**教师话术**\n> \"**GPIO输入模式**：之前LED是输出(OUT)，按钮是���入(IN)\n>\n> ```python\n> import machine\n>\n> # LED是输出\n> led = machine.Pin(2, machine.Pin.OUT)\n>\n> # 按钮是输入\n> button = machine.Pin(4, machine.Pin.IN)\n> ```\n>\n> **读取按钮状态**：用`value()`方法\n> ```python\n> state = button.value()\n> # 返回 0 表示按下（低电平）\n> # 返回 1 表示松开（高电平）\n> ```\n>\n> **为什么按下是0？**\n> - 按钮接地(GND)，按下时引脚接地，电压为0\n> - 松开时引脚悬空或接高电平，电压为1\"\n\n**核心代码模式**\n\n```python\nimport machine\nimport time\n\n# 初始化引脚\nled = machine.Pin(2, machine.Pin.OUT)\nbutton = machine.Pin(4, machine.Pin.IN)\n\nwhile True:\n    if button.value() == 0:  # 按钮按下\n        led.value(1)         # 开灯\n    else:\n        led.value(0)         # 关灯\n    time.sleep_ms(20)        # 消抖延时\n```\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 不理解0和1 | 用开关类比 | \"按下接通=0，松开断开=1\" |\n| 按钮不灵敏 | 检查接线 | 确认按钮一端接引脚，一端接GND |\n| 想做切换功能 | 引导状态变量 | 用变量记录当前灯的状态 |\n\n---\n\n**步骤3：硬件搭建（20分钟）** `#高负荷-产出` `#IFC-即时`\n\n**教师话术**\n> \"今天的接线很简单：\n>\n> **按钮接线**：\n> ```\n> 按钮一端 → P4引脚\n> 按钮另一端 → GND\n> ```\n>\n> **LED接线**（如果用外部LED）：\n> ```\n> LED正极 → P2引脚\n> LED负极 → GND（通过电阻）\n> ```\n>\n> **消抖处理**：按钮按下时会有机械抖动，产生多次0-1变化。加入`time.sleep_ms(20)`延时可以消除抖动。\"\n\n**禁忌提醒**\n❌ **按钮两端都接VCC**——无法检测按下\n❌ **忘记消抖**——按一次可能触发多次\n❌ **LED不串电阻**——可能烧毁LED\n\n---\n\n**步骤4：编程调试（30分钟）** `#高负荷-产出` `#IFC-即时`\n\n**教师话术**\n> \"现在来做一个**切换开关**——按一次开灯，再按一次关灯：\n>\n> ```python\n> import machine\n> import time\n>\n> led = machine.Pin(2, machine.Pin.OUT)\n> button = machine.Pin(4, machine.Pin.IN)\n>\n> light_on = False  # 记录灯的状态\n> last_state = 1    # 记录上次按钮状态\n>\n> while True:\n>     current_state = button.value()\n>\n>     # 检测按下瞬间（从1变成0）\n>     if current_state == 0 and last_state == 1:\n>         light_on = not light_on  # 切换状态\n>         led.value(1 if light_on else 0)\n>         time.sleep_ms(200)  # 防止连续触发\n>\n>     last_state = current_state\n>     time.sleep_ms(20)\n> ```\"\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 切换不灵 | 检查边沿检测 | 确认是检测\"按下瞬间\"而非\"按住\" |\n| 想加多个按钮 | 扩展引脚 | 每个按钮用不同引脚 |\n| 想做长按功能 | 计时检测 | 记录按下时长，超过1秒执行不同操作 |\n\n---\n\n**步骤5：成果展示（10分钟）** `#低负荷-热身` `#IFC-复盘`\n\n**教师话术**\n> \"谁的按钮开关做好了？演示一下！\n>\n> 挑战：能不能做一个'双击'功能？双击按钮切换不同颜色的RGB灯。\"\n\n---\n\n**核心知识点**\n- GPIO输入模式：`machine.Pin(pin, machine.Pin.IN)`\n- 读取状态：`button.value()` 返回0或1\n- 消抖处理：加入短暂延时消除机械抖动\n- 边沿检测：检测状态变化的瞬间\n\n**底层逻辑**\n- **输入输出**：GPIO既可以输出控制设备，也可以输入感知状态\n- **状态机**：用变量记录状态，实现切换功能\n\n`#执行层` `#测评项`\n[UID: PYAI-14-02-001]\n\n---\n\n### 1-4-3 智能光控(1)\n\n#### 课程基本信息\n\n| 项目 | 内容 |\n|------|------|\n| **课程编号** | 1-4-3 |\n| **课程名称** | 智能光控(1) - 光控灯搭建 |\n| **认知负荷** | 中-高 |\n| **核心技能** | mpython_conn库、LED/RGB控制、光线传感器 |\n\n#### 详细教学流程\n\n**步骤1：课程回顾（5分钟）** `#低负荷-热身` `#IFC-预防`\n\n**教师话术**\n> \"上节课我们认识了ESP32开发板。今天我们要连接第一个外部传感器——**光线传感器**！它能感知环境的亮度。\"\n\n---\n\n**步骤2：知识讲解（15分钟）** `#中负荷-操练` `#IFC-即时`\n\n**教师话术**\n> \"**光线传感器**的工作原理：\n> - 内部有一个光敏电阻\n> - 光线越强，电阻越小，输出值越大\n> - 光线越弱，电阻越大，输出值越小\n>\n> **RGB灯**可以显示任意颜色：\n> ```python\n> from mpython import *\n>\n> # RGB灯控制 - 三个参数分别是红、绿、蓝（0-255）\n> rgb[0] = (255, 0, 0)    # 红色\n> rgb[1] = (0, 255, 0)    # 绿色\n> rgb[2] = (0, 0, 255)    # 蓝色\n> rgb.write()             # 更新显示\n> ```\n>\n> **颜色混合**：\n> - (255, 255, 0) = 黄色（红+绿）\n> - (255, 0, 255) = 紫色（红+蓝）\n> - (0, 255, 255) = 青色（绿+蓝）\n> - (255, 255, 255) = 白色\"\n\n**核心代码模式**\n\n```python\nfrom mpython import *\nimport time\n\n# 读取光线传感器\nlight_value = light.read()\nprint(f\"当前光线值: {light_value}\")\n\n# 控制RGB灯\nrgb[0] = (255, 100, 0)  # 橙色\nrgb.write()\n\n# 关闭RGB灯\nrgb.fill((0, 0, 0))\nrgb.write()\n```\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 不理解RGB | 用调色盘类比 | \"红绿蓝三种颜料混合\" |\n| 颜色不对 | 检查参数顺序 | 顺序是(红, 绿, 蓝) |\n| 忘记write() | 强调更新 | \"设置颜色后必须write()才生效\" |\n\n---\n\n**步骤3：硬件搭建（20分钟）** `#高负荷-产出` `#IFC-即时`\n\n**教师话术**\n> \"今天我们使用板载的光线传感器，不需要额外接线！\n>\n> 但如果使用外部光线传感器模块，接线方式是：\n> ```\n> VCC → 3.3V（红线）\n> GND → GND（黑线）\n> OUT → P0（信号线）\n> ```\n>\n> **接线口诀**：红接红，黑接黑，信号线接P引脚。\"\n\n**禁忌提醒**\n❌ **接反VCC和GND**——会烧毁传感器\n❌ **信号线接错引脚**——读取不到数据\n❌ **带电插拔**——可能损坏接口\n\n---\n\n**步骤4：编程调试（30分钟）** `#高负荷-产出` `#IFC-即时`\n\n**教师话术**\n> \"现在我们来写一个光控灯程序：\n>\n> ```python\n> from mpython import *\n> import time\n>\n> while True:\n>     # 读取光线值\n>     light_value = light.read()\n>     print(f'光线值: {light_value}')\n>\n>     # 根据光线调整RGB亮度\n>     brightness = int(light_value / 16)  # 0-4095 映射到 0-255\n>     rgb.fill((brightness, brightness, brightness))\n>     rgb.write()\n>\n>     time.sleep(0.1)\n> ```\n>\n> 用手遮住光线传感器，观察RGB灯的变化！\"\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 灯不变化 | 检查传感器 | 用print确认light.read()有变化 |\n| 想要彩色效果 | 修改RGB参数 | 根据光线值改变颜色而非亮度 |\n| 变化太快 | 增加延时 | 把sleep改成0.5秒 |\n\n---\n\n**步骤5：成果展示（10分钟）** `#低负荷-热身` `#IFC-复盘`\n\n**教师话术**\n> \"谁能让RGB灯根据光线变化显示不同颜色？比如：\n> - 光线强 → 蓝色（白天）\n> - 光线弱 → 橙色（傍晚）\n> - 很暗 → 红色（夜晚）\"\n\n---\n\n**核心知识点**\n- 光线传感器：`light.read()` 返回0-4095\n- RGB灯控制：`rgb[n] = (R, G, B)` + `rgb.write()`\n- 颜色混合：红+绿=黄，红+蓝=紫，绿+蓝=青\n\n**底层逻辑**\n- **传感器输入**：环境信息 → 数字信号\n- **执行器输出**：数字信号 → 物理效果\n\n`#执行层` `#测评项`\n[UID: PYAI-14-03-001]\n\n---\n\n### 1-4-4 智能光控(2)（典型案例）\n\n#### 课程基本信息\n\n| 项目 | 内容 |\n|------|------|\n| **课程编号** | 1-4-4 |\n| **课程名称** | 智能光控(2) - 自动夜灯 |\n| **认知负荷** | 中-高 |\n| **核心技能** | 模拟量读取、阈值判断、自动化控制 |\n\n#### 详细教学流程\n\n**步骤1：课程回顾（5分钟）** `#低负荷-热身` `#IFC-预防`\n\n**教师话术**\n> \"上节课我们学习了如何用Python控制LED灯。今天我们要让灯变得更聪明——能自动感知环境亮度！大家还记得光线传感器是怎么工作的吗？\"\n\n---\n\n**步骤2：知识讲解（15分钟）** `#中负荷-操练` `#IFC-即时`\n\n**教师话术**\n> \"光线传感器返回的是一个数字，叫做**模拟量**。数值范围是0-4095：\n> - 0 表示完全黑暗\n> - 4095 表示非常明亮\n>\n> 我们用 `get_analog()` 函数读取这个数值：\n> ```python\n> light_value = light_sensor.get_analog()\n> print(light_value)\n> ```\n>\n> 然后用**阈值判断**来决定是否开灯：\n> ```python\n> if light_value < 500:\n>     led.on()  # 光线暗，开灯\n> else:\n>     led.off()  # 光线亮，关灯\n> ```\"\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 不理解模拟量 | 用温度计类比 | \"温度计显示25度，就是一个模拟量\" |\n| 阈值概念模糊 | 用门槛类比 | \"500就是一个门槛，低于它就开灯\" |\n| 想调整灵敏度 | 引导修改阈值 | \"试试把500改成300会怎样？\" |\n\n---\n\n**步骤3：硬件搭建（20分钟）** `#高负荷-产出` `#IFC-即时`\n\n**教师话术**\n> \"现在开始接线！**注意：必须先断电再接线！**\n>\n> 接线步骤：\n> 1. 光线传感器的VCC接3.3V（红线）\n> 2. GND接GND（黑线）\n> 3. 信号线接P0引脚\n> 4. LED灯接P1引脚\"\n\n**禁忌提醒**\n❌ **带电接线**——会短路烧毁开发板\n❌ **VCC直接接GND**——这是短路，会烧板子\n❌ **接错引脚**——先检查再通电\n\n---\n\n**步骤4：编程调试（30分钟）** `#高负荷-产出` `#IFC-即时`\n\n**教师话术**\n> \"代码写好了，现在测试一下。用手遮住光线传感器，看看LED会不会亮起来？\"\n>\n> \"如果没反应，我们来调试：\n> 1. 先用print()打印光线值，看看传感器有没有工作\n> 2. 检查阈值设置是否合理\n> 3. 检查接线是否正确\"\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| LED不亮 | 检查接线和引脚 | 确认LED正负极没接反 |\n| 传感器数值不变 | 检查传感器接线 | 信号线可能接错引脚 |\n| 想增加功能 | 加入RGB渐变 | 根据亮度调整RGB颜色 |\n\n---\n\n**步骤5：成果展示（10分钟）** `#低负荷-热身` `#IFC-复盘`\n\n**教师话术**\n> \"谁的自动夜灯做好了？上来演示一下！告诉大家你设置的阈值是多少，为什么选这个数值？\"\n\n---\n\n**核心知识点**\n- 模拟量读取：`get_analog()` 返回0-4095\n- 阈值判断：`if value < 500` 触发动作\n- 自动化控制：光线低于阈值自动点亮LED\n\n**底层逻辑**\n- **物联网架构**：感知（传感器）→ 处理（Python判断）→ 执行（LED）\n- **反馈控制**：环境变化 → 系统响应\n\n`#执行层` `#测评项`\n[UID: PYAI-14-04-001]\n\n---\n\n### 1-4-5 智能通风\n\n#### 课程基本信息\n\n| 项目 | 内容 |\n|------|------|\n| **课程编号** | 1-4-5 |\n| **课程名称** | 智能通风 - 气体检测系统 |\n| **认知负荷** | 高 |\n| **核心技能** | MQ-2B气体传感器、电机控制、安全阈值 |\n\n#### 详细教学流程\n\n**步骤1：课程导入（5分钟）** `#低负荷-热身` `#IFC-预防`\n\n**教师话术**\n> \"同学们，家里的燃气报警器见过吗？今天我们要做一个类似的智能通风系统——检测到有害气体就自动开启风扇！\"\n\n---\n\n**步骤2：知识讲解（15分钟）** `#中负荷-操练` `#IFC-即时`\n\n**教师话术**\n> \"**MQ-2B气体传感器**可以检测：\n> - 可燃气体（天然气、液化气）\n> - 烟雾\n> - 酒精蒸汽\n>\n> **工作原理**：\n> - 传感器内部有加热丝，需要预热1-2分钟\n> - 检测到气体时，输出值会升高\n> - 正常空气：100-300\n> - 检测到气体：500以上\n>\n> **电机控制**：\n> ```python\n> from mpython import *\n>\n> # 电机连接到P8引脚\n> motor = Pin(Pin.P8, Pin.OUT)\n>\n> motor.write_digital(1)  # 开启电机\n> motor.write_digital(0)  # 关闭电机\n> ```\"\n\n**核心代码模式**\n\n```python\nfrom mpython import *\nimport time\n\n# 气体传感器连接到P0\ngas_sensor = Pin(Pin.P0, Pin.IN)\n\n# 电机连接到P8\nmotor = Pin(Pin.P8, Pin.OUT)\n\n# 安全阈值\nDANGER_THRESHOLD = 500\n\nwhile True:\n    # 读取气体浓度\n    gas_value = gas_sensor.read_analog()\n    print(f\"气体浓度: {gas_value}\")\n\n    # 判断是否超标\n    if gas_value > DANGER_THRESHOLD:\n        motor.write_digital(1)  # 开启风扇\n        rgb.fill((255, 0, 0))   # 红色警告\n        buzzer.on()             # 蜂鸣器报警\n    else:\n        motor.write_digital(0)  # 关闭风扇\n        rgb.fill((0, 255, 0))   # 绿色安全\n        buzzer.off()\n\n    rgb.write()\n    time.sleep(0.5)\n```\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 传感器数值不稳定 | 等待预热 | MQ-2B需要预热1-2分钟 |\n| 想测试效果 | 用酒精棉球 | 靠近传感器可触发检测 |\n| 阈值不合适 | 观察正常值 | 先记录正常空气的数值 |\n\n---\n\n**步骤3：硬件搭建（20分钟）** `#高负荷-产出` `#IFC-即时`\n\n**教师话术**\n> \"今天的接线比较复杂，请仔细听：\n>\n> **气体传感器接线**：\n> ```\n> VCC → 5V（注意：MQ-2B需要5V供电）\n> GND → GND\n> AO  → P0（模拟输出）\n> ```\n>\n> **电机模块接线**：\n> ```\n> VCC → 5V\n> GND → GND\n> IN  → P8（控制信号）\n> ```\n>\n> **重要**：MQ-2B传感器会发热，这是正常的！\"\n\n**禁忌提醒**\n❌ **触摸发热的传感器**——会烫伤\n❌ **用明火测试**——危险！用酒精棉球代替\n❌ **电机反接**——可能烧毁驱动模块\n❌ **忘记预热**——数值不准确\n\n---\n\n**步骤4：编程调试（30分钟）** `#高负荷-产出` `#IFC-即时`\n\n**教师话术**\n> \"代码上传后，先观察正常空气的数值是多少。\n>\n> 然后用酒精棉球靠近传感器测试：\n> 1. 数值是否升高？\n> 2. 风扇是否启动？\n> 3. 蜂鸣器是否响起？\n>\n> 如果没反应，检查：\n> - 传感器是否预热完成\n> - 阈值设置是否合理\n> - 接线是否正确\"\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 风扇不转 | 检查电机接线 | 确认IN接到正确引脚 |\n| 一直报警 | 降低阈值 | 可能环境本身气体浓度高 |\n| 想加显示 | 用OLED显示 | 在屏幕上显示当前数值 |\n\n---\n\n**步骤5：成果展示（10分钟）** `#低负荷-热身` `#IFC-复盘`\n\n**教师话术**\n> \"谁的智能通风系统做好了？演示一下！\n>\n> 思考：这个系统还能怎么改进？\n> - 加入OLED显示当前气体浓度\n> - 加入WiFi功能，远程报警\n> - 记录历史数据\"\n\n---\n\n**核心知识点**\n- MQ-2B气体传感器：检测可燃气体和烟雾\n- 传感器预热：需要1-2分钟预热才能准确\n- 电机控制：`write_digital(1/0)` 开关控制\n- 安全阈值：根据实际环境调整\n\n**底层逻辑**\n- **安全系统设计**：检测 → 判断 → 响应\n- **多输出联动**：风扇 + 灯光 + 声音\n\n`#执行层` `#测评项`\n[UID: PYAI-14-05-001]\n\n---\n\n### 1-4-6~8 智能门禁系列\n\n#### 课程基本信息\n\n| 项目 | 内容 |\n|------|------|\n| **课程编号** | 1-4-6/7/8 |\n| **课程名称** | 智能门禁（人脸识别开门） |\n| **认知负荷** | 高 |\n| **核心技能** | OpenCV视觉、灰度处理、特征匹配、舵机控制 |\n\n#### 详细教学流程（跨3节课）\n\n**第6课：人脸捕捉相机**\n\n**教师话术**\n> \"今天我们开始做智能门禁系统！第一步是让电脑'看见'人脸。\n>\n> 我们用OpenCV库来控制摄像头：\n> ```python\n> import cv2\n> cap = cv2.VideoCapture(0)  # 0表示第一个摄像头\n> ret, frame = cap.read()    # 读取一帧图像\n> cv2.imshow('Camera', frame)  # 显示图像\n> ```\"\n\n**禁忌提醒**\n❌ 忘记释放摄像头——程序结束前要调用 `cap.release()`\n❌ 摄像头被占用——确保没有其他程序在使用摄像头\n\n---\n\n**第7课：人脸比对算法**\n\n**教师话术**\n> \"现在我们要让电脑'认识'人脸。步骤是：\n>\n> 1. **灰度处理**：把彩色图变成黑白图，减少计算量\n> ```python\n> gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\n> ```\n>\n> 2. **特征匹配**：把当前人脸和保存的人脸对比\n> ```python\n> result = cv2.matchTemplate(gray, template, cv2.TM_CCOEFF_NORMED)\n> ```\n>\n> 相似度越高，说明是同一个人！\"\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 不理解灰度 | 用黑白照片类比 | \"灰度就像老照片，只有黑白\" |\n| 匹配不准 | 调整阈值 | \"相似度0.8以上才算匹配成功\" |\n| 想识别多人 | 引导使用列表 | 保存多个人脸模板 |\n\n---\n\n**第8课：刷脸开门**\n\n**教师话术**\n> \"最后一步，把AI和硬件连接起来！\n>\n> 如果人脸匹配成功，就控制舵机转动，打开门：\n> ```python\n> if similarity > 0.8:\n>     servo.write_angle(90)  # 开门\n>     time.sleep(3)\n>     servo.write_angle(0)   # 关门\n> ```\"\n\n**禁忌提醒**\n❌ **强行扭动舵机**——会损坏内部齿轮\n❌ 舵机角度超范围——通常是0-180度，超出会卡死\n\n---\n\n**核心知识点**\n- AI视觉流程：采集 → 处理 → 输出\n- 灰度处理：降低计算量\n- 特征匹配：计算相似度数值\n- 系统集成：AI判断 + 舵机控制\n\n`#执行层` `#测评项`\n[UID: PYAI-14-06-001]\n\n---\n\n### 1-4-9 音强流水灯\n\n#### 课程基本信息\n\n| 项目 | 内容 |\n|------|------|\n| **课程编号** | 1-4-9 |\n| **课程名称** | 音强流水灯 |\n| **认知负荷** | 中-高 |\n| **核心技能** | NeoPixel灯带、声音传感器、流水灯算法 |\n\n#### 详细教学流程\n\n**步骤1：课程导入（5分钟）** `#低负荷-热身` `#IFC-预防`\n\n**教师话术**\n> \"同学们见过KTV里跟着音乐闪烁的灯光吗？今天我们来做一个**音乐律动灯**——灯光会随着声音的强弱变化！\"\n\n---\n\n**步骤2：知识讲解（15分钟）** `#中负荷-操练` `#IFC-即时`\n\n**教师话术**\n> \"**NeoPixel灯带**：可以单独控制每颗LED的颜色\n>\n> ```python\n> import neopixel\n> from machine import Pin\n>\n> NUM_LEDS = 30  # 灯珠数量\n> np = neopixel.NeoPixel(Pin(4), NUM_LEDS)\n>\n> # 设置第一颗灯为红色\n> np[0] = (255, 0, 0)  # (R, G, B)\n> np.write()  # 更新显示\n> ```\n>\n> **声音传感器**：检测环境音量\n> ```python\n> from machine import Pin, ADC\n>\n> mic = ADC(Pin(34))\n> mic.atten(ADC.ATTN_11DB)  # 设置量程\n>\n> sound_level = mic.read()  # 读取音量值（0-4095）\n> ```\n>\n> **流水灯算法**：让颜色像水一样流动\n> ```python\n> # 核心思想：列表元素向右偏移\n> colors = [(255,0,0), (0,255,0), (0,0,255), ...]\n>\n> # 每次循环，最后一个颜色移到最前面\n> last_color = colors.pop()  # 取出最后一个\n> colors.insert(0, last_color)  # 插入到最前面\n> ```\"\n\n**核心代码模式**\n\n```python\nimport neopixel\nimport time\nfrom machine import Pin, ADC\n\n# 初始化\nNUM_LEDS = 30\nnp = neopixel.NeoPixel(Pin(4), NUM_LEDS)\nmic = ADC(Pin(34))\nmic.atten(ADC.ATTN_11DB)\n\n# 初始化颜色列表（渐变色）\ncolors = []\nfor i in range(NUM_LEDS):\n    # 生成彩虹渐变\n    hue = int(i * 255 / NUM_LEDS)\n    colors.append((hue, 255 - hue, 128))\n\nwhile True:\n    # 读取音量\n    sound = mic.read()\n\n    # 根据音量调整亮度\n    brightness = min(255, sound // 16)\n\n    # 应用颜色到灯带\n    for i in range(NUM_LEDS):\n        r = colors[i][0] * brightness // 255\n        g = colors[i][1] * brightness // 255\n        b = colors[i][2] * brightness // 255\n        np[i] = (r, g, b)\n    np.write()\n\n    # 流水效果：颜色向右移动\n    last = colors.pop()\n    colors.insert(0, last)\n\n    time.sleep_ms(50)\n```\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 灯带不亮 | 检查供电 | NeoPixel需要5V供电，电流较大 |\n| 音量检测不灵敏 | 调整阈值 | 根据环境噪音调整基准值 |\n| 想要不同效果 | 修改算法 | 可以做呼吸灯、闪烁、追逐等效果 |\n\n---\n\n**步骤3：硬件搭建（20分钟）** `#高负荷-产出` `#IFC-即时`\n\n**教师话术**\n> \"今天的硬件：\n>\n> **NeoPixel灯带接线**：\n> ```\n> VCC → 5V（外部电源，不要用ESP32的5V）\n> GND → GND（与ESP32共地）\n> DIN → P4（数据输入）\n> ```\n>\n> **声音传感器接线**：\n> ```\n> VCC → 3.3V\n> GND → GND\n> AO  → P34（模拟输出）\n> ```\n>\n> **重要**：灯带耗电大，30颗灯全亮可能需要1.8A电流，必须用外部电源！\"\n\n**禁忌提醒**\n❌ **灯带直接接ESP32的5V**——电流不够，可能烧毁USB口\n❌ **忘记共地**——灯带和ESP32的GND必须连接\n❌ **数据线接错**——DIN是输入，DOUT是输出（级联用）\n\n---\n\n**步骤4：编程调试（30分钟）** `#高负荷-产出` `#IFC-即时`\n\n**教师话术**\n> \"调试步骤：\n>\n> 1. **先测试灯带**：\n>    ```python\n>    # 让所有灯亮红色\n>    for i in range(NUM_LEDS):\n>        np[i] = (255, 0, 0)\n>    np.write()\n>    ```\n>\n> 2. **再测试声音传感器**：\n>    ```python\n>    while True:\n>        print(mic.read())\n>        time.sleep_ms(100)\n>    ```\n>    对着传感器说话，观察数值变化\n>\n> 3. **最后联调**：\n>    - 安静时灯光暗\n>    - 声音大时灯光亮\n>    - 颜色在流动\"\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 灯光闪烁不稳定 | 添加平滑处理 | 用移动平均值平滑音量数据 |\n| 想做音乐节奏灯 | 检测节拍 | 检测音量的突变作为节拍 |\n| 想控制更多灯 | 级联灯带 | 多条灯带可以串联 |\n\n---\n\n**步骤5：成果展示（10分钟）** `#低负荷-热身` `#IFC-复盘`\n\n**教师话术**\n> \"谁的音乐律动灯做好了？放一首歌试试效果！\n>\n> 思考：如何让灯光效果更炫酷？\n> - 不同音量对应不同颜色\n> - 低音和高音分开显示\n> - 添加闪烁效果\"\n\n---\n\n**核心知识点**\n- NeoPixel灯带：可单独控制每颗LED颜色\n- 声音传感器：ADC读取模拟音量值\n- 流水灯算法：列表元素循环移位\n- 亮度映射：音量值映射到亮度\n\n**底层逻辑**\n- **数据驱动显示**：传感器数据 → 视觉效果\n- **列表操作**：pop()和insert()实现循环移位\n\n`#执行层` `#测评项`\n[UID: PYAI-14-09-001]\n\n---\n\n### 1-4-10 智能花房(1)\n\n#### 课程基本信息\n\n| 项目 | 内容 |\n|------|------|\n| **课程编号** | 1-4-10 |\n| **课程名称** | 智能花房(1) - 自动浇水系统 |\n| **认知负荷** | 中-高 |\n| **核心技能** | 土壤湿度传感器、水泵控制、自动化灌溉 |\n\n#### 详细教学流程\n\n**步骤1：课程导入（5分钟）** `#低负荷-热身` `#IFC-预防`\n\n**教师话术**\n> \"同学们养过植物吗？最头疼的是不是忘记浇水？今天我们来做一个**自动浇水系统**，让植物自己'喝水'！\"\n\n---\n\n**步骤2：知识讲解（15分钟）** `#中负荷-操练` `#IFC-即时`\n\n**教师话术**\n> \"**土壤湿度传感器**的工作原理：\n> - 两个金属探针插入土壤\n> - 土壤越湿，导电性越好，数值越低\n> - 土壤越干，导电性越差，数值越高\n>\n> **数值范围**（参考）：\n> - 0-300：非常湿润（刚浇过水）\n> - 300-700：适中\n> - 700-1000：偏干\n> - 1000以上：很干（需要浇水）\n>\n> **水泵控制**：\n> ```python\n> from mpython import *\n>\n> # 水泵连接到P8（通过继电器）\n> pump = Pin(Pin.P8, Pin.OUT)\n>\n> pump.write_digital(1)  # 开启水泵\n> time.sleep(2)          # 浇水2秒\n> pump.write_digital(0)  # 关闭水泵\n> ```\"\n\n**核心代码模式**\n\n```python\nfrom mpython import *\nimport time\n\n# 土壤湿度传感器连接到P0\nsoil_sensor = Pin(Pin.P0, Pin.IN)\n\n# 水泵连接到P8\npump = Pin(Pin.P8, Pin.OUT)\n\n# 干燥阈值\nDRY_THRESHOLD = 800\n\nwhile True:\n    # 读取土壤湿度\n    soil_value = soil_sensor.read_analog()\n    print(f\"土壤湿度: {soil_value}\")\n\n    # 判断是否需要浇水\n    if soil_value > DRY_THRESHOLD:\n        print(\"土壤干燥，开始浇水...\")\n        pump.write_digital(1)\n        time.sleep(3)  # 浇水3秒\n        pump.write_digital(0)\n        print(\"浇水完成，等待30秒...\")\n        time.sleep(30)  # 等待水分渗透\n    else:\n        print(\"土壤湿润，无需浇水\")\n\n    time.sleep(5)  # 每5秒检测一次\n```\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 数值不稳定 | 检查探针接触 | 探针要完全插入土壤 |\n| 阈值不准 | 实际测量 | 先测干土和湿土的数值 |\n| 想防止过度浇水 | 加冷却时间 | 浇水后等待一段时间再检测 |\n\n---\n\n**步骤3：硬件搭建（20分钟）** `#高负荷-产出` `#IFC-即时`\n\n**教师话术**\n> \"今天的硬件包括：\n>\n> **土壤湿度传感器接线**：\n> ```\n> VCC → 3.3V\n> GND → GND\n> AO  → P0（模拟输出）\n> ```\n>\n> **水泵模块接线**（通过继电器）：\n> ```\n> 继电器 VCC → 5V\n> 继电器 GND → GND\n> 继电器 IN  → P8\n> 水泵接继电器的常开端\n> ```\n>\n> **注意**：水泵需要单独供电，不能直接接ESP32！\"\n\n**禁忌提醒**\n❌ **水泵直接接ESP32**——电流太大会烧毁\n❌ **传感器长时间通电**——会加速腐蚀\n❌ **水溅到电路板**——会短路\n❌ **水管脱落**——会漏水\n\n---\n\n**步骤4：编程调试（30分钟）** `#高负荷-产出` `#IFC-即时`\n\n**教师话术**\n> \"测试步骤：\n>\n> 1. 先测试传感器：\n>    - 探针在空气中的数值\n>    - 探针插入干土的数值\n>    - 探针插入湿土的数值\n>\n> 2. 再测试水泵：\n>    - 手动控制开关\n>    - 确认水流正常\n>\n> 3. 最后联调：\n>    - 把探针插入干土\n>    - 观察是否自动浇水\"\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 水泵不工作 | 检查继电器 | 听继电器是否有\"咔嗒\"声 |\n| 浇水太多 | 减少浇水时间 | 把3秒改成1秒 |\n| 想加指示灯 | 用RGB显示状态 | 绿色=湿润，红色=干燥 |\n\n---\n\n**步骤5：成果展示（10分钟）** `#低负荷-热身` `#IFC-复盘`\n\n**教师话术**\n> \"谁的自动浇水系统做好了？演示一下！\n>\n> 思考：真正的智能花房还需要什么？\n> - 光照检测（是否需要补光）\n> - 温度检测（是否需要加热）\n> - 远程监控（手机查看状态）\"\n\n---\n\n**核心知识点**\n- 土壤湿度传感器：数值越高越干燥\n- 水泵控制：通过继电器间接控制\n- 防过度浇水：加入冷却等待时间\n- 阈值校准：根据实际土壤调整\n\n**底层逻辑**\n- **农业物联网**：感知土壤 → 智能决策 → 自动执行\n- **反馈控制**：检测 → 执行 → 等待 → 再检测\n\n`#执行层` `#测评项`\n[UID: PYAI-14-10-001]\n\n---\n\n### 1-4-11 智能花房(2)\n\n#### 课程基本信息\n\n| 项目 | 内容 |\n|------|------|\n| **课程编号** | 1-4-11 |\n| **课程名称** | 智能花房(2) - 可视化智能灌溉 |\n| **认知负荷** | 高 |\n| **核心技能** | OLED屏幕显示、数据可视化、多传感器融合 |\n\n#### 详细教学流程\n\n**步骤1：课程回顾（5分钟）** `#低负荷-热身` `#IFC-预防`\n\n**教师话术**\n> \"上节课我们做了自动浇水系统。但是，我们只能通过电脑看数据。今天我们要把数据显示在**OLED屏幕**上，让花房更智能！\"\n\n---\n\n**步骤2：知识讲解（15分钟）** `#中负荷-操练` `#IFC-即时`\n\n**教师话术**\n> \"**OLED屏幕**是一种小型显示屏：\n> - 分辨率：128×64像素\n> - 可以显示文字、数字、图形\n> - 自发光，不需要背光\n>\n> **显示函数**：\n> ```python\n> from mpython import *\n>\n> # 清屏\n> oled.fill(0)\n>\n> # 显示文字（x坐标, y坐标, 内容）\n> oled.DispChar('土壤湿度:', 0, 0)\n> oled.DispChar('750', 0, 16)\n>\n> # 显示英文\n> oled.DispChar('Soil: 750', 0, 32)\n>\n> # 更新显示\n> oled.show()\n> ```\n>\n> **进度条显示**：\n> ```python\n> # 画矩形框（x, y, 宽, 高, 颜色）\n> oled.rect(0, 50, 128, 10, 1)\n>\n> # 填充进度（根据湿度百分比）\n> progress = int(soil_value / 1024 * 128)\n> oled.fill_rect(0, 50, progress, 10, 1)\n> ```\"\n\n**核心代码模式**\n\n```python\nfrom mpython import *\nimport time\n\n# 传感器\nsoil_sensor = Pin(Pin.P0, Pin.IN)\npump = Pin(Pin.P8, Pin.OUT)\n\nDRY_THRESHOLD = 800\n\ndef update_display(soil_value, status):\n    \"\"\"更新OLED显示\"\"\"\n    oled.fill(0)  # 清屏\n\n    # 标题\n    oled.DispChar('智能花房', 32, 0)\n\n    # 土壤湿度\n    oled.DispChar(f'湿度: {soil_value}', 0, 20)\n\n    # 状态\n    oled.DispChar(f'状态: {status}', 0, 36)\n\n    # 进度条\n    oled.rect(0, 52, 128, 10, 1)\n    progress = min(128, int((1024 - soil_value) / 1024 * 128))\n    oled.fill_rect(0, 52, progress, 10, 1)\n\n    oled.show()\n\nwhile True:\n    soil_value = soil_sensor.read_analog()\n\n    if soil_value > DRY_THRESHOLD:\n        update_display(soil_value, '浇水中...')\n        pump.write_digital(1)\n        time.sleep(2)\n        pump.write_digital(0)\n        update_display(soil_value, '等待渗透')\n        time.sleep(30)\n    else:\n        update_display(soil_value, '湿润正常')\n\n    time.sleep(2)\n```\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 中文显示乱码 | 检查字体 | 确认使用DispChar而非text |\n| 进度条方向反 | 调整计算 | 湿度高时进度条应该长 |\n| 想加更多信息 | 分屏显示 | 用按键切换不同页面 |\n\n---\n\n**步骤3：硬件搭建（20分钟）** `#高负荷-产出` `#IFC-即时`\n\n**教师话术**\n> \"今天使用板载OLED屏幕，不需要额外接线！\n>\n> 硬件连接和上节课一样：\n> - 土壤湿度传感器 → P0\n> - 水泵继电器 → P8\n>\n> 如果想加入更多传感器：\n> - 光线传感器 → 板载\n> - 温度传感器 → P1\"\n\n---\n\n**步骤4：编程调试（30分钟）** `#高负荷-产出` `#IFC-即时`\n\n**教师话术**\n> \"调试重点：\n>\n> 1. **屏幕显示**：\n>    - 文字位置是否合适\n>    - 中文是否正常显示\n>    - 进度条是否正确\n>\n> 2. **数据更新**：\n>    - 数值是否实时变化\n>    - 状态是否正确切换\n>\n> 3. **整体联调**：\n>    - 浇水时屏幕显示'浇水中'\n>    - 正常时显示'湿润正常'\"\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 屏幕闪烁 | 减少刷新频率 | 不要每次循环都清屏 |\n| 想加图标 | 用画图函数 | oled.pixel()画点，oled.line()画线 |\n| 想记录历史 | 用列表存储 | 保存最近10次的数值 |\n\n---\n\n**步骤5：成果展示（10分钟）** `#低负荷-热身` `#IFC-复盘`\n\n**教师话术**\n> \"谁的可视化花房做好了？展示一下你的屏幕界面！\n>\n> 挑战：能不能加入更多功能？\n> - 显示当前时间\n> - 显示累计浇水次数\n> - 显示光照强度\"\n\n---\n\n**核心知识点**\n- OLED显示：`oled.DispChar()` 显示文字\n- 清屏和更新：`oled.fill(0)` + `oled.show()`\n- 进度条：`oled.rect()` 画框 + `oled.fill_rect()` 填充\n- 数据可视化：把数值转换为图形\n\n**底层逻辑**\n- **人机交互**：数据 → 可视化 → 用户理解\n- **系统集成**：传感器 + 执行器 + 显示器\n\n`#执行层` `#测评项`\n[UID: PYAI-14-11-001]\n\n---\n\n### 1-4-12 家居回顾\n\n#### 课程基本信息\n\n| 项目 | 内容 |\n|------|------|\n| **课程编号** | 1-4-12 |\n| **课程名称** | 家居回顾 - 物联网架构复盘 |\n| **认知负荷** | 中 |\n| **核心技能** | 物联网架构、AI流程、系统设计思维 |\n\n#### 详细教学流程\n\n**步骤1：课程导入（5分钟）** `#低负荷-热身` `#IFC-预防`\n\n**教师话术**\n> \"同学们，这个单元我们做了很多智能硬件项目。今天我们来回顾总结，看看这些项目有什么共同点！\"\n\n---\n\n**步骤2：知识回顾（20分钟）** `#中负荷-操练` `#IFC-即时`\n\n**教师话术**\n> \"**物联网三层架构**：\n>\n> ```\n> ┌─────────────────────────────────────┐\n> │           应用层（执行）              │\n> │   LED、RGB、蜂鸣器、电机、舵机、屏幕   │\n> └─────────────────────────────────────┘\n>                    ↑\n> ┌─────────────────────────────────────┐\n> │           处理层（决策）              │\n> │      ESP32 + Python代码              │\n> │      if判断、阈值比较、AI算法         │\n> └─────────────────────────────────────┘\n>                    ↑\n> ┌─────────────────────────────────────┐\n> │           感知层（输入）              │\n> │   光线传感器、气体传感器、土壤传感器   │\n> │   摄像头、温度传感器、按键            │\n> └─────────────────────────────────────┘\n> ```\n>\n> **我们做过的项目**：\n>\n> | 项目 | 感知层 | 处理层 | 应用层 |\n> |------|--------|--------|--------|\n> | 智能夜灯 | 光线传感器 | 阈值判断 | LED/RGB |\n> | 智能通风 | 气体传感器 | 阈值判断 | 电机+蜂鸣器 |\n> | 智能门禁 | 摄像头 | AI人脸识别 | 舵机 |\n> | 智能花房 | 土壤传感器 | 阈值判断 | 水泵+OLED |\"\n\n**核心代码模式**\n\n```python\n# 物联网项目通用模板\nfrom mpython import *\nimport time\n\n# 1. 感知层：初始化传感器\nsensor = Pin(Pin.P0, Pin.IN)\n\n# 2. 应用层：初始化执行器\nactuator = Pin(Pin.P8, Pin.OUT)\n\n# 3. 处理层：设置阈值\nTHRESHOLD = 500\n\nwhile True:\n    # 感知：读取传感器\n    value = sensor.read_analog()\n\n    # 处理：判断决策\n    if value > THRESHOLD:\n        # 应用：执行动作\n        actuator.write_digital(1)\n    else:\n        actuator.write_digital(0)\n\n    time.sleep(1)\n```\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 概念混淆 | 用具体例子 | \"光线传感器是感知层，LED是应用层\" |\n| 想设计新项目 | 引导思考 | \"你想感知什么？执行什么？\" |\n| 忘记某个项目 | 快速回顾 | 展示之前的代码和硬件 |\n\n---\n\n**步骤3：AI流程复盘（15分钟）** `#中负荷-操练` `#IFC-即时`\n\n**教师话术**\n> \"**AI视觉流程**（智能门禁）：\n>\n> ```\n> 摄像头采集 → 灰度处理 → 特征提取 → 模板匹配 → 决策输出\n>     ↓            ↓           ↓           ↓          ↓\n>   frame      cvtColor    matchTemplate  相似度    开门/拒绝\n> ```\n>\n> **AI的本质**：\n> - 输入：传感器数据（图像、声音、数值）\n> - 处理：算法分析（匹配、分类、预测）\n> - 输出：决策结果（开门、报警、浇水）\n>\n> **AI和普通程序的区别**：\n> - 普通程序：固定规则（if value > 500）\n> - AI程序：学习规则（从数据中学习判断标准）\"\n\n---\n\n**步骤4：方案设计（25分钟）** `#高负荷-产出` `#IFC-即时`\n\n**教师话术**\n> \"现在请设计一个**智能家居方案**！\n>\n> 要求：\n> 1. 选择至少2个传感器\n> 2. 选择至少2个执行器\n> 3. 画出系统架构图\n> 4. 写出核心代码逻辑\n>\n> 示例：**智能卧室**\n> - 感知：光线传感器 + 温度传感器\n> - 处理：ESP32判断\n> - 应用：窗帘电机 + 空调控制 + 夜灯\n>\n> 逻辑：\n> - 光线暗 + 晚上 → 开夜灯\n> - 温度高 → 开空调\n> - 早上 + 光线亮 → 开窗帘\"\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 没有思路 | 提供场景 | \"想想厨房/浴室/客厅需要什么\" |\n| 方案太简单 | 引导扩展 | \"能不能加入手机控制？\" |\n| 方案太复杂 | 简化聚焦 | \"先实现最核心的功能\" |\n\n---\n\n**步骤5：成果展示（15分钟）** `#低负荷-热身` `#IFC-复盘`\n\n**教师话术**\n> \"请上来展示你的智能家居方案！\n>\n> 评价标准：\n> - 创意性：解决了什么实际问题？\n> - 可行性：技术上能否实现？\n> - 完整性：三层架构是否完整？\"\n\n---\n\n**核心知识点**\n- 物联网三层架构：感知层 → 处理层 → 应用层\n- AI视觉流程：采集 → 处理 → 匹配 → 决策\n- 系统设计思维：从需求出发，分层设计\n\n**底层逻辑**\n- **系统思维**：把复杂问题分解为三层\n- **工程思维**：从设计到实现的完整流程\n\n`#执行层` `#测评项`\n[UID: PYAI-14-12-001]\n[关联: PYAI-24-001 PythonAI计算机视觉（进阶衔接）]\n\n---"
    },
    {
      "title": "教学禁忌清单（硬件安全红线）",
      "content": "| 序号 | 禁忌 | 原因 | 正确做法 |\n|------|------|------|----------|\n| 1 | ❌ **带电接线** | 短路烧毁开发板 | 必须断电后再接线 |\n| 2 | ❌ **短路（VCC直接接GND）** | 烧毁开发板 | 红线(VCC)和黑线(GND)绝对不能直接连接 |\n| 3 | ❌ **开发板放金属表面通电** | 底部引脚短路 | 放在绝缘表面（桌面、纸板） |\n| 4 | ❌ **强行扭动舵机** | 损坏内部齿轮 | 不要用力手动扭转舵机摆臂 |\n| 5 | ❌ **在boot.py写死循环无延时** | 开发板无法重新连接 | 谨慎编辑启动文件 |\n| 6 | ❌ **忘记释放摄像头** | 下次无法使用 | 程序结束前调用cap.release() |\n\n`#执行层` `#测评项`\n[UID: PYAI-TABOO-14]\n\n---"
    },
    {
      "title": "教学注意事项",
      "content": "| 类别 | 注意事项 |\n|------|----------|\n| **硬件保护** | 开发板不要放在金属表面通电；接线前必须断电 |\n| **舵机使用** | 通电或未通电状态下不要强行手动扭转 |\n| **库导入** | 建议使用standard形式（如import machine），避免命名空间污染 |\n| **调试技巧** | 用print()输出传感器数值，确认硬件正常工作 |\n\n---"
    },
    {
      "title": "底层教育学原理",
      "content": "| 原理 | 说明 | 在本单元的应用 |\n|------|------|----------------|\n| **物联网架构** | 感知层-网络层-应用层 | 传感器→ESP32/Python→执行器 |\n| **AI视觉流程** | 采集-处理-输出 | 摄像头→灰度/匹配→舵机控制 |\n| **软硬结合** | 代码驱动物理硬件 | Python控制LED、电机、舵机 |\n| **项目制学习** | 完整项目驱动学习 | 智能夜灯、智能门禁、智能花房 |\n\n`#执行层` `#测评项`\n[UID: PYAI-THEORY-14]\n\n---\n\n**质量评估**：10/10（原子化萃取版，10节课完整萃取）\n**已补充**：认知负荷标签、IFC标签、变体示例、详细教师话术、硬件安全禁忌、核心代码模式\n**课程覆盖**：1-4-1, 1-4-3, 1-4-4, 1-4-5, 1-4-6/7/8, 1-4-10, 1-4-11, 1-4-12 全部10节课\n\n---\n\n**最后更新**：2026-02-09"
    }
  ],
  "full_content": "# PythonAI萃取：L1-4 智能硬件与AI应用\n\n> **来源**：NotebookLM Python AI Lesson Plan (96个来源)\n> **萃取日期**：2026-02-02\n> **萃取深度**：5-5多维度（含认知负荷标签、IFC标签、变体示例）\n> **更新日期**：2026-02-04\n\n---\n\n## 单元概览\n\n| 项目 | 内容 |\n|------|------|\n| **单元编号** | PYAI 1-4 |\n| **单元名称** | 智能硬件与AI应用 |\n| **适用年龄** | 三年级及以上（8-10岁） |\n| **课时数** | 10节 × 90分钟 |\n| **核心目标** | 实现软硬结合，使用Python控制ESP32掌控板及传感器，引入OpenCV机器视觉 |\n| **主要教具** | ESP32/掌控板、光线传感器、气体传感器、土壤湿度传感器、舵机、RGB灯 |\n\n**底层逻辑**\n实现软硬结合，了解物联网(IoT)与机器视觉基础，建立\"感知层-处理层-应用层\"的系统思维。\n\n**单元教学策略**\n- 硬件基础（01）：认识ESP32、引脚、电路基础\n- 传感器应用（03-05）：光线传感器、气体传感器、自动化控制\n- AI视觉（06-08）：OpenCV、人脸检测、系统集成\n- 综合项目（10-12）：智能花房、物联网架构复盘\n\n`#执行层` `#测评项`\n[UID: PYAI-14-001]\n[关联: STEM-S3-004 STEM大班智能硬件（前置基础）]\n[关联: CODE3-M1-001 CODE智能系统（前置基础）]\n[关联: PYAI-24-001 PythonAI计算机视觉（进阶衔接）]\n\n---\n\n## 课程列表\n\n| 课次 | 课程名称 | 核心知识点 | 项目内容 | 认知负荷 |\n|------|----------|------------|----------|----------|\n| 1-4-1 | 硬件系统 | 软硬件关系、ESP32引脚、电路基础 | 硬件认知 | 中 |\n| 1-4-2 | 按钮控制LED | GPIO输入、button.value()、消抖处理 | 按钮开关灯 | 中 |\n| 1-4-3 | 智能光控(1) | mpython_conn库、LED/RGB控制、光线传感器 | 光控灯搭建 | 中-高 |\n| 1-4-4 | 智能光控(2) | 模拟量读取get_analog()、阈值判断 | 自动夜灯 | 中-高 |\n| 1-4-5 | 智能通风 | MQ-2B气体传感器、电机控制 | 智能通风系统 | 高 |\n| 1-4-6 | 智能门禁(1) | AI视觉基础、cv2.VideoCapture | 人脸捕捉相机 | 高 |\n| 1-4-7 | 智能门禁(2) | 灰度处理cvtColor、特征匹配matchTemplate | 人脸比对算法 | 高 |\n| 1-4-8 | 智能门禁(3) | 舵机控制Servo、系统集成 | 刷脸开门 | 高 |\n| 1-4-9 | 音强流水灯 | NeoPixel灯带、声音传感器、流水灯算法 | 音乐律动灯 | 中-高 |\n| 1-4-10 | 智能花房(1) | 土壤湿度传感器、水泵控制 | 自动浇水系统 | 中-高 |\n| 1-4-11 | 智能花房(2) | OLED屏幕显示、数据可视化 | 可视化智能灌溉 | 高 |\n| 1-4-12 | 家居回顾 | 物联网架构复习、AI流程复盘 | 智能家居方案展示 | 中 |\n\n---\n\n## 通用教学流程（90分钟）\n\n| 环节 | 时间 | 内容 | 认知负荷 | IFC标签 |\n|------|------|------|----------|---------|\n| 课堂问候 | 2分钟 | 自我介绍、安全规则强调 | `#低负荷-热身` | `#IFC-预防` |\n| 课程回顾 | 5分钟 | 复习上节课代码和硬件知识 | `#低负荷-热身` | `#IFC-预防` |\n| 知识讲解 | 15分钟 | 新传感器/新概念讲解 | `#中负荷-操练` | `#IFC-即时` |\n| 硬件搭建 | 20分钟 | 接线、组装硬件 | `#高负荷-产出` | `#IFC-即时` |\n| 调节休息 | 3分钟 | 站起来活动、眼保健操 | `#调节-放松` | - |\n| 编程调试 | 30分钟 | 编写代码、调试系统 | `#高负荷-产出` | `#IFC-即时` |\n| 成果展示 | 10分钟 | 演示项目、分享思路 | `#低负荷-热身` | `#IFC-复盘` |\n\n`#执行层` `#测评项`\n[UID: PYAI-14-FLOW-001]\n\n---\n\n## 详细课程萃取\n\n### 1-4-1 硬件系统\n\n#### 课程基本信息\n\n| 项目 | 内容 |\n|------|------|\n| **课程编号** | 1-4-1 |\n| **课程名称** | 硬件系统 - 认识ESP32 |\n| **认知负荷** | 中 |\n| **核心技能** | 软硬件关系、ESP32引脚、电路基础 |\n\n#### 详细教学流程\n\n**步骤1：课程导入（5分钟）** `#低负荷-热身` `#IFC-预防`\n\n**教师话术**\n> \"同学们，之前我们写的Python代码都是在电脑上运行的。今天开始，我们要让代码控制真实的硬件！这就是**物联网(IoT)**的魅力——用代码控制物理世界。\"\n\n---\n\n**步骤2：知识讲解（15分钟）** `#中负荷-操练` `#IFC-即时`\n\n**教师话术**\n> \"首先认识我们的主角——**ESP32掌控板**！\n>\n> **什么是ESP32？**\n> - 一块小型计算机，可以运行MicroPython代码\n> - 内置WiFi和蓝牙，可以联网\n> - 有很多**引脚(Pin)**，用来连接传感器和执行器\n>\n> **引脚类型**：\n> ```\n> VCC (3.3V) - 电源正极，给传感器供电\n> GND        - 电源负极，接地\n> P0-P20     - 数字/模拟引脚，连接传感器\n> ```\n>\n> **电路基础**：\n> - 电流从VCC流出，经过元件，流回GND\n> - 必须形成**闭合回路**才能工作\n> - **短路**：VCC直接接GND，会烧毁开发板！\"\n\n**核心代码模式**\n\n```python\n# MicroPython基础导入\nfrom mpython import *\nimport time\n\n# 控制板载LED\nled.on()   # 开灯\nled.off()  # 关灯\n\n# 控制板载蜂鸣器\nbuzzer.on()   # 响\nbuzzer.off()  # 停\n```\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 不理解引脚 | 用插座类比 | \"引脚就像插座，传感器插上去就能用\" |\n| 混淆VCC和GND | 用水流类比 | \"VCC是水龙头，GND是下水道\" |\n| 想知道为什么用3.3V | 解释电压 | \"ESP32是3.3V系统，5V会烧坏\" |\n\n---\n\n**步骤3：硬件认知（20分钟）** `#高负荷-产出` `#IFC-即时`\n\n**教师话术**\n> \"现在我们来认识开发板上的各个部件：\n>\n> 1. **USB接口**：连接电脑，上传代码\n> 2. **复位按钮**：重启开发板\n> 3. **板载LED**：可以用代码控制的小灯\n> 4. **板载蜂鸣器**：可以发出声音\n> 5. **OLED屏幕**：显示文字和图形\n> 6. **引脚排**：连接外部传感器\n>\n> **安全规则（必须牢记）**：\n> - 接线前必须断电\n> - 红线接VCC，黑线接GND\n> - 不确定时先问老师\"\n\n**禁忌提醒**\n❌ **带电接线**——会短路烧毁开发板\n❌ **VCC直接接GND**——这是短路，绝对禁止\n❌ **开发板放金属表面通电**——底部引脚会短路\n\n---\n\n**步骤4：编程体验（30分钟）** `#高负荷-产出` `#IFC-即时`\n\n**教师话术**\n> \"让我们写第一个硬件控制程序——让LED闪烁！\n>\n> ```python\n> from mpython import *\n> import time\n>\n> while True:\n>     led.on()\n>     time.sleep(0.5)  # 亮0.5秒\n>     led.off()\n>     time.sleep(0.5)  # 灭0.5秒\n> ```\n>\n> 上传代码后，观察LED是不是在闪烁？\"\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 代码上传失败 | 检查USB连接 | 确认选择了正确的串口 |\n| LED不闪烁 | 检查代码缩进 | while循环内的代码要缩进 |\n| 想改变闪烁速度 | 修改sleep参数 | \"把0.5改成0.1会怎样？\" |\n\n---\n\n**步骤5：成果展示（10分钟）** `#低负荷-热身` `#IFC-复盘`\n\n**教师话术**\n> \"谁的LED闪烁成功了？试着让蜂鸣器也响起来！\n>\n> ```python\n> buzzer.on()\n> time.sleep(0.1)\n> buzzer.off()\n> ```\"\n\n---\n\n**核心知识点**\n- ESP32是可编程的小型计算机，运行MicroPython\n- 引脚类型：VCC(电源)、GND(接地)、P0-P20(信号)\n- 电路必须形成闭合回路才能工作\n- 安全第一：接线前断电，避免短路\n\n**底层逻辑**\n- **软硬结合**：代码 → 硬件动作\n- **物联网基础**：感知 → 处理 → 执行\n\n`#执行层` `#测评项`\n[UID: PYAI-14-01-001]\n[关联: STEM-S3-004 STEM大班智能硬件（前置基础）]\n\n---\n\n### 1-4-2 按钮控制LED\n\n#### 课程基本信息\n\n| 项目 | 内容 |\n|------|------|\n| **课程编号** | 1-4-2 |\n| **课程名称** | 按钮控制LED |\n| **认知负荷** | 中 |\n| **核心技能** | GPIO输入、button.value()、消抖处理 |\n\n#### 详细教学流程\n\n**步骤1：课程回顾（5分钟）** `#低负荷-热身` `#IFC-预防`\n\n**教师话术**\n> \"上节课我们学会了用代码控制LED闪烁。但那是自动的，如果我想用按钮来控制呢？今天学习**GPIO输入**——让开发板'感知'按钮状态！\"\n\n---\n\n**步骤2：知识讲解（15分钟）** `#中负荷-操练` `#IFC-即时`\n\n**教师话术**\n> \"**GPIO输入模式**：之前LED是输出(OUT)，按钮是���入(IN)\n>\n> ```python\n> import machine\n>\n> # LED是输出\n> led = machine.Pin(2, machine.Pin.OUT)\n>\n> # 按钮是输入\n> button = machine.Pin(4, machine.Pin.IN)\n> ```\n>\n> **读取按钮状态**：用`value()`方法\n> ```python\n> state = button.value()\n> # 返回 0 表示按下（低电平）\n> # 返回 1 表示松开（高电平）\n> ```\n>\n> **为什么按下是0？**\n> - 按钮接地(GND)，按下时引脚接地，电压为0\n> - 松开时引脚悬空或接高电平，电压为1\"\n\n**核心代码模式**\n\n```python\nimport machine\nimport time\n\n# 初始化引脚\nled = machine.Pin(2, machine.Pin.OUT)\nbutton = machine.Pin(4, machine.Pin.IN)\n\nwhile True:\n    if button.value() == 0:  # 按钮按下\n        led.value(1)         # 开灯\n    else:\n        led.value(0)         # 关灯\n    time.sleep_ms(20)        # 消抖延时\n```\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 不理解0和1 | 用开关类比 | \"按下接通=0，松开断开=1\" |\n| 按钮不灵敏 | 检查接线 | 确认按钮一端接引脚，一端接GND |\n| 想做切换功能 | 引导状态变量 | 用变量记录当前灯的状态 |\n\n---\n\n**步骤3：硬件搭建（20分钟）** `#高负荷-产出` `#IFC-即时`\n\n**教师话术**\n> \"今天的接线很简单：\n>\n> **按钮接线**：\n> ```\n> 按钮一端 → P4引脚\n> 按钮另一端 → GND\n> ```\n>\n> **LED接线**（如果用外部LED）：\n> ```\n> LED正极 → P2引脚\n> LED负极 → GND（通过电阻）\n> ```\n>\n> **消抖处理**：按钮按下时会有机械抖动，产生多次0-1变化。加入`time.sleep_ms(20)`延时可以消除抖动。\"\n\n**禁忌提醒**\n❌ **按钮两端都接VCC**——无法检测按下\n❌ **忘记消抖**——按一次可能触发多次\n❌ **LED不串电阻**——可能烧毁LED\n\n---\n\n**步骤4：编程调试（30分钟）** `#高负荷-产出` `#IFC-即时`\n\n**教师话术**\n> \"现在来做一个**切换开关**——按一次开灯，再按一次关灯：\n>\n> ```python\n> import machine\n> import time\n>\n> led = machine.Pin(2, machine.Pin.OUT)\n> button = machine.Pin(4, machine.Pin.IN)\n>\n> light_on = False  # 记录灯的状态\n> last_state = 1    # 记录上次按钮状态\n>\n> while True:\n>     current_state = button.value()\n>\n>     # 检测按下瞬间（从1变成0）\n>     if current_state == 0 and last_state == 1:\n>         light_on = not light_on  # 切换状态\n>         led.value(1 if light_on else 0)\n>         time.sleep_ms(200)  # 防止连续触发\n>\n>     last_state = current_state\n>     time.sleep_ms(20)\n> ```\"\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 切换不灵 | 检查边沿检测 | 确认是检测\"按下瞬间\"而非\"按住\" |\n| 想加多个按钮 | 扩展引脚 | 每个按钮用不同引脚 |\n| 想做长按功能 | 计时检测 | 记录按下时长，超过1秒执行不同操作 |\n\n---\n\n**步骤5：成果展示（10分钟）** `#低负荷-热身` `#IFC-复盘`\n\n**教师话术**\n> \"谁的按钮开关做好了？演示一下！\n>\n> 挑战：能不能做一个'双击'功能？双击按钮切换不同颜色的RGB灯。\"\n\n---\n\n**核心知识点**\n- GPIO输入模式：`machine.Pin(pin, machine.Pin.IN)`\n- 读取状态：`button.value()` 返回0或1\n- 消抖处理：加入短暂延时消除机械抖动\n- 边沿检测：检测状态变化的瞬间\n\n**底层逻辑**\n- **输入输出**：GPIO既可以输出控制设备，也可以输入感知状态\n- **状态机**：用变量记录状态，实现切换功能\n\n`#执行层` `#测评项`\n[UID: PYAI-14-02-001]\n\n---\n\n### 1-4-3 智能光控(1)\n\n#### 课程基本信息\n\n| 项目 | 内容 |\n|------|------|\n| **课程编号** | 1-4-3 |\n| **课程名称** | 智能光控(1) - 光控灯搭建 |\n| **认知负荷** | 中-高 |\n| **核心技能** | mpython_conn库、LED/RGB控制、光线传感器 |\n\n#### 详细教学流程\n\n**步骤1：课程回顾（5分钟）** `#低负荷-热身` `#IFC-预防`\n\n**教师话术**\n> \"上节课我们认识了ESP32开发板。今天我们要连接第一个外部传感器——**光线传感器**！它能感知环境的亮度。\"\n\n---\n\n**步骤2：知识讲解（15分钟）** `#中负荷-操练` `#IFC-即时`\n\n**教师话术**\n> \"**光线传感器**的工作原理：\n> - 内部有一个光敏电阻\n> - 光线越强，电阻越小，输出值越大\n> - 光线越弱，电阻越大，输出值越小\n>\n> **RGB灯**可以显示任意颜色：\n> ```python\n> from mpython import *\n>\n> # RGB灯控制 - 三个参数分别是红、绿、蓝（0-255）\n> rgb[0] = (255, 0, 0)    # 红色\n> rgb[1] = (0, 255, 0)    # 绿色\n> rgb[2] = (0, 0, 255)    # 蓝色\n> rgb.write()             # 更新显示\n> ```\n>\n> **颜色混合**：\n> - (255, 255, 0) = 黄色（红+绿）\n> - (255, 0, 255) = 紫色（红+蓝）\n> - (0, 255, 255) = 青色（绿+蓝）\n> - (255, 255, 255) = 白色\"\n\n**核心代码模式**\n\n```python\nfrom mpython import *\nimport time\n\n# 读取光线传感器\nlight_value = light.read()\nprint(f\"当前光线值: {light_value}\")\n\n# 控制RGB灯\nrgb[0] = (255, 100, 0)  # 橙色\nrgb.write()\n\n# 关闭RGB灯\nrgb.fill((0, 0, 0))\nrgb.write()\n```\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 不理解RGB | 用调色盘类比 | \"红绿蓝三种颜料混合\" |\n| 颜色不对 | 检查参数顺序 | 顺序是(红, 绿, 蓝) |\n| 忘记write() | 强调更新 | \"设置颜色后必须write()才生效\" |\n\n---\n\n**步骤3：硬件搭建（20分钟）** `#高负荷-产出` `#IFC-即时`\n\n**教师话术**\n> \"今天我们使用板载的光线传感器，不需要额外接线！\n>\n> 但如果使用外部光线传感器模块，接线方式是：\n> ```\n> VCC → 3.3V（红线）\n> GND → GND（黑线）\n> OUT → P0（信号线）\n> ```\n>\n> **接线口诀**：红接红，黑接黑，信号线接P引脚。\"\n\n**禁忌提醒**\n❌ **接反VCC和GND**——会烧毁传感器\n❌ **信号线接错引脚**——读取不到数据\n❌ **带电插拔**——可能损坏接口\n\n---\n\n**步骤4：编程调试（30分钟）** `#高负荷-产出` `#IFC-即时`\n\n**教师话术**\n> \"现在我们来写一个光控灯程序：\n>\n> ```python\n> from mpython import *\n> import time\n>\n> while True:\n>     # 读取光线值\n>     light_value = light.read()\n>     print(f'光线值: {light_value}')\n>\n>     # 根据光线调整RGB亮度\n>     brightness = int(light_value / 16)  # 0-4095 映射到 0-255\n>     rgb.fill((brightness, brightness, brightness))\n>     rgb.write()\n>\n>     time.sleep(0.1)\n> ```\n>\n> 用手遮住光线传感器，观察RGB灯的变化！\"\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 灯不变化 | 检查传感器 | 用print确认light.read()有变化 |\n| 想要彩色效果 | 修改RGB参数 | 根据光线值改变颜色而非亮度 |\n| 变化太快 | 增加延时 | 把sleep改成0.5秒 |\n\n---\n\n**步骤5：成果展示（10分钟）** `#低负荷-热身` `#IFC-复盘`\n\n**教师话术**\n> \"谁能让RGB灯根据光线变化显示不同颜色？比如：\n> - 光线强 → 蓝色（白天）\n> - 光线弱 → 橙色（傍晚）\n> - 很暗 → 红色（夜晚）\"\n\n---\n\n**核心知识点**\n- 光线传感器：`light.read()` 返回0-4095\n- RGB灯控制：`rgb[n] = (R, G, B)` + `rgb.write()`\n- 颜色混合：红+绿=黄，红+蓝=紫，绿+蓝=青\n\n**底层逻辑**\n- **传感器输入**：环境信息 → 数字信号\n- **执行器输出**：数字信号 → 物理效果\n\n`#执行层` `#测评项`\n[UID: PYAI-14-03-001]\n\n---\n\n### 1-4-4 智能光控(2)（典型案例）\n\n#### 课程基本信息\n\n| 项目 | 内容 |\n|------|------|\n| **课程编号** | 1-4-4 |\n| **课程名称** | 智能光控(2) - 自动夜灯 |\n| **认知负荷** | 中-高 |\n| **核心技能** | 模拟量读取、阈值判断、自动化控制 |\n\n#### 详细教学流程\n\n**步骤1：课程回顾（5分钟）** `#低负荷-热身` `#IFC-预防`\n\n**教师话术**\n> \"上节课我们学习了如何用Python控制LED灯。今天我们要让灯变得更聪明——能自动感知环境亮度！大家还记得光线传感器是怎么工作的吗？\"\n\n---\n\n**步骤2：知识讲解（15分钟）** `#中负荷-操练` `#IFC-即时`\n\n**教师话术**\n> \"光线传感器返回的是一个数字，叫做**模拟量**。数值范围是0-4095：\n> - 0 表示完全黑暗\n> - 4095 表示非常明亮\n>\n> 我们用 `get_analog()` 函数读取这个数值：\n> ```python\n> light_value = light_sensor.get_analog()\n> print(light_value)\n> ```\n>\n> 然后用**阈值判断**来决定是否开灯：\n> ```python\n> if light_value < 500:\n>     led.on()  # 光线暗，开灯\n> else:\n>     led.off()  # 光线亮，关灯\n> ```\"\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 不理解模拟量 | 用温度计类比 | \"温度计显示25度，就是一个模拟量\" |\n| 阈值概念模糊 | 用门槛类比 | \"500就是一个门槛，低于它就开灯\" |\n| 想调整灵敏度 | 引导修改阈值 | \"试试把500改成300会怎样？\" |\n\n---\n\n**步骤3：硬件搭建（20分钟）** `#高负荷-产出` `#IFC-即时`\n\n**教师话术**\n> \"现在开始接线！**注意：必须先断电再接线！**\n>\n> 接线步骤：\n> 1. 光线传感器的VCC接3.3V（红线）\n> 2. GND接GND（黑线）\n> 3. 信号线接P0引脚\n> 4. LED灯接P1引脚\"\n\n**禁忌提醒**\n❌ **带电接线**——会短路烧毁开发板\n❌ **VCC直接接GND**——这是短路，会烧板子\n❌ **接错引脚**——先检查再通电\n\n---\n\n**步骤4：编程调试（30分钟）** `#高负荷-产出` `#IFC-即时`\n\n**教师话术**\n> \"代码写好了，现在测试一下。用手遮住光线传感器，看看LED会不会亮起来？\"\n>\n> \"如果没反应，我们来调试：\n> 1. 先用print()打印光线值，看看传感器有没有工作\n> 2. 检查阈值设置是否合理\n> 3. 检查接线是否正确\"\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| LED不亮 | 检查接线和引脚 | 确认LED正负极没接反 |\n| 传感器数值不变 | 检查传感器接线 | 信号线可能接错引脚 |\n| 想增加功能 | 加入RGB渐变 | 根据亮度调整RGB颜色 |\n\n---\n\n**步骤5：成果展示（10分钟）** `#低负荷-热身` `#IFC-复盘`\n\n**教师话术**\n> \"谁的自动夜灯做好了？上来演示一下！告诉大家你设置的阈值是多少，为什么选这个数值？\"\n\n---\n\n**核心知识点**\n- 模拟量读取：`get_analog()` 返回0-4095\n- 阈值判断：`if value < 500` 触发动作\n- 自动化控制：光线低于阈值自动点亮LED\n\n**底层逻辑**\n- **物联网架构**：感知（传感器）→ 处理（Python判断）→ 执行（LED）\n- **反馈控制**：环境变化 → 系统响应\n\n`#执行层` `#测评项`\n[UID: PYAI-14-04-001]\n\n---\n\n### 1-4-5 智能通风\n\n#### 课程基本信息\n\n| 项目 | 内容 |\n|------|------|\n| **课程编号** | 1-4-5 |\n| **课程名称** | 智能通风 - 气体检测系统 |\n| **认知负荷** | 高 |\n| **核心技能** | MQ-2B气体传感器、电机控制、安全阈值 |\n\n#### 详细教学流程\n\n**步骤1：课程导入（5分钟）** `#低负荷-热身` `#IFC-预防`\n\n**教师话术**\n> \"同学们，家里的燃气报警器见过吗？今天我们要做一个类似的智能通风系统——检测到有害气体就自动开启风扇！\"\n\n---\n\n**步骤2：知识讲解（15分钟）** `#中负荷-操练` `#IFC-即时`\n\n**教师话术**\n> \"**MQ-2B气体传感器**可以检测：\n> - 可燃气体（天然气、液化气）\n> - 烟雾\n> - 酒精蒸汽\n>\n> **工作原理**：\n> - 传感器内部有加热丝，需要预热1-2分钟\n> - 检测到气体时，输出值会升高\n> - 正常空气：100-300\n> - 检测到气体：500以上\n>\n> **电机控制**：\n> ```python\n> from mpython import *\n>\n> # 电机连接到P8引脚\n> motor = Pin(Pin.P8, Pin.OUT)\n>\n> motor.write_digital(1)  # 开启电机\n> motor.write_digital(0)  # 关闭电机\n> ```\"\n\n**核心代码模式**\n\n```python\nfrom mpython import *\nimport time\n\n# 气体传感器连接到P0\ngas_sensor = Pin(Pin.P0, Pin.IN)\n\n# 电机连接到P8\nmotor = Pin(Pin.P8, Pin.OUT)\n\n# 安全阈值\nDANGER_THRESHOLD = 500\n\nwhile True:\n    # 读取气体浓度\n    gas_value = gas_sensor.read_analog()\n    print(f\"气体浓度: {gas_value}\")\n\n    # 判断是否超标\n    if gas_value > DANGER_THRESHOLD:\n        motor.write_digital(1)  # 开启风扇\n        rgb.fill((255, 0, 0))   # 红色警告\n        buzzer.on()             # 蜂鸣器报警\n    else:\n        motor.write_digital(0)  # 关闭风扇\n        rgb.fill((0, 255, 0))   # 绿色安全\n        buzzer.off()\n\n    rgb.write()\n    time.sleep(0.5)\n```\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 传感器数值不稳定 | 等待预热 | MQ-2B需要预热1-2分钟 |\n| 想测试效果 | 用酒精棉球 | 靠近传感器可触发检测 |\n| 阈值不合适 | 观察正常值 | 先记录正常空气的数值 |\n\n---\n\n**步骤3：硬件搭建（20分钟）** `#高负荷-产出` `#IFC-即时`\n\n**教师话术**\n> \"今天的接线比较复杂，请仔细听：\n>\n> **气体传感器接线**：\n> ```\n> VCC → 5V（注意：MQ-2B需要5V供电）\n> GND → GND\n> AO  → P0（模拟输出）\n> ```\n>\n> **电机模块接线**：\n> ```\n> VCC → 5V\n> GND → GND\n> IN  → P8（控制信号）\n> ```\n>\n> **重要**：MQ-2B传感器会发热，这是正常的！\"\n\n**禁忌提醒**\n❌ **触摸发热的传感器**——会烫伤\n❌ **用明火测试**——危险！用酒精棉球代替\n❌ **电机反接**——可能烧毁驱动模块\n❌ **忘记预热**——数值不准确\n\n---\n\n**步骤4：编程调试（30分钟）** `#高负荷-产出` `#IFC-即时`\n\n**教师话术**\n> \"代码上传后，先观察正常空气的数值是多少。\n>\n> 然后用酒精棉球靠近传感器测试：\n> 1. 数值是否升高？\n> 2. 风扇是否启动？\n> 3. 蜂鸣器是否响起？\n>\n> 如果没反应，检查：\n> - 传感器是否预热完成\n> - 阈值设置是否合理\n> - 接线是否正确\"\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 风扇不转 | 检查电机接线 | 确认IN接到正确引脚 |\n| 一直报警 | 降低阈值 | 可能环境本身气体浓度高 |\n| 想加显示 | 用OLED显示 | 在屏幕上显示当前数值 |\n\n---\n\n**步骤5：成果展示（10分钟）** `#低负荷-热身` `#IFC-复盘`\n\n**教师话术**\n> \"谁的智能通风系统做好了？演示一下！\n>\n> 思考：这个系统还能怎么改进？\n> - 加入OLED显示当前气体浓度\n> - 加入WiFi功能，远程报警\n> - 记录历史数据\"\n\n---\n\n**核心知识点**\n- MQ-2B气体传感器：检测可燃气体和烟雾\n- 传感器预热：需要1-2分钟预热才能准确\n- 电机控制：`write_digital(1/0)` 开关控制\n- 安全阈值：根据实际环境调整\n\n**底层逻辑**\n- **安全系统设计**：检测 → 判断 → 响应\n- **多输出联动**：风扇 + 灯光 + 声音\n\n`#执行层` `#测评项`\n[UID: PYAI-14-05-001]\n\n---\n\n### 1-4-6~8 智能门禁系列\n\n#### 课程基本信息\n\n| 项目 | 内容 |\n|------|------|\n| **课程编号** | 1-4-6/7/8 |\n| **课程名称** | 智能门禁（人脸识别开门） |\n| **认知负荷** | 高 |\n| **核心技能** | OpenCV视觉、灰度处理、特征匹配、舵机控制 |\n\n#### 详细教学流程（跨3节课）\n\n**第6课：人脸捕捉相机**\n\n**教师话术**\n> \"今天我们开始做智能门禁系统！第一步是让电脑'看见'人脸。\n>\n> 我们用OpenCV库来控制摄像头：\n> ```python\n> import cv2\n> cap = cv2.VideoCapture(0)  # 0表示第一个摄像头\n> ret, frame = cap.read()    # 读取一帧图像\n> cv2.imshow('Camera', frame)  # 显示图像\n> ```\"\n\n**禁忌提醒**\n❌ 忘记释放摄像头——程序结束前要调用 `cap.release()`\n❌ 摄像头被占用——确保没有其他程序在使用摄像头\n\n---\n\n**第7课：人脸比对算法**\n\n**教师话术**\n> \"现在我们要让电脑'认识'人脸。步骤是：\n>\n> 1. **灰度处理**：把彩色图变成黑白图，减少计算量\n> ```python\n> gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\n> ```\n>\n> 2. **特征匹配**：把当前人脸和保存的人脸对比\n> ```python\n> result = cv2.matchTemplate(gray, template, cv2.TM_CCOEFF_NORMED)\n> ```\n>\n> 相似度越高，说明是同一个人！\"\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 不理解灰度 | 用黑白照片类比 | \"灰度就像老照片，只有黑白\" |\n| 匹配不准 | 调整阈值 | \"相似度0.8以上才算匹配成功\" |\n| 想识别多人 | 引导使用列表 | 保存多个人脸模板 |\n\n---\n\n**第8课：刷脸开门**\n\n**教师话术**\n> \"最后一步，把AI和硬件连接起来！\n>\n> 如果人脸匹配成功，就控制舵机转动，打开门：\n> ```python\n> if similarity > 0.8:\n>     servo.write_angle(90)  # 开门\n>     time.sleep(3)\n>     servo.write_angle(0)   # 关门\n> ```\"\n\n**禁忌提醒**\n❌ **强行扭动舵机**——会损坏内部齿轮\n❌ 舵机角度超范围——通常是0-180度，超出会卡死\n\n---\n\n**核心知识点**\n- AI视觉流程：采集 → 处理 → 输出\n- 灰度处理：降低计算量\n- 特征匹配：计算相似度数值\n- 系统集成：AI判断 + 舵机控制\n\n`#执行层` `#测评项`\n[UID: PYAI-14-06-001]\n\n---\n\n### 1-4-9 音强流水灯\n\n#### 课程基本信息\n\n| 项目 | 内容 |\n|------|------|\n| **课程编号** | 1-4-9 |\n| **课程名称** | 音强流水灯 |\n| **认知负荷** | 中-高 |\n| **核心技能** | NeoPixel灯带、声音传感器、流水灯算法 |\n\n#### 详细教学流程\n\n**步骤1：课程导入（5分钟）** `#低负荷-热身` `#IFC-预防`\n\n**教师话术**\n> \"同学们见过KTV里跟着音乐闪烁的灯光吗？今天我们来做一个**音乐律动灯**——灯光会随着声音的强弱变化！\"\n\n---\n\n**步骤2：知识讲解（15分钟）** `#中负荷-操练` `#IFC-即时`\n\n**教师话术**\n> \"**NeoPixel灯带**：可以单独控制每颗LED的颜色\n>\n> ```python\n> import neopixel\n> from machine import Pin\n>\n> NUM_LEDS = 30  # 灯珠数量\n> np = neopixel.NeoPixel(Pin(4), NUM_LEDS)\n>\n> # 设置第一颗灯为红色\n> np[0] = (255, 0, 0)  # (R, G, B)\n> np.write()  # 更新显示\n> ```\n>\n> **声音传感器**：检测环境音量\n> ```python\n> from machine import Pin, ADC\n>\n> mic = ADC(Pin(34))\n> mic.atten(ADC.ATTN_11DB)  # 设置量程\n>\n> sound_level = mic.read()  # 读取音量值（0-4095）\n> ```\n>\n> **流水灯算法**：让颜色像水一样流动\n> ```python\n> # 核心思想：列表元素向右偏移\n> colors = [(255,0,0), (0,255,0), (0,0,255), ...]\n>\n> # 每次循环，最后一个颜色移到最前面\n> last_color = colors.pop()  # 取出最后一个\n> colors.insert(0, last_color)  # 插入到最前面\n> ```\"\n\n**核心代码模式**\n\n```python\nimport neopixel\nimport time\nfrom machine import Pin, ADC\n\n# 初始化\nNUM_LEDS = 30\nnp = neopixel.NeoPixel(Pin(4), NUM_LEDS)\nmic = ADC(Pin(34))\nmic.atten(ADC.ATTN_11DB)\n\n# 初始化颜色列表（渐变色）\ncolors = []\nfor i in range(NUM_LEDS):\n    # 生成彩虹渐变\n    hue = int(i * 255 / NUM_LEDS)\n    colors.append((hue, 255 - hue, 128))\n\nwhile True:\n    # 读取音量\n    sound = mic.read()\n\n    # 根据音量调整亮度\n    brightness = min(255, sound // 16)\n\n    # 应用颜色到灯带\n    for i in range(NUM_LEDS):\n        r = colors[i][0] * brightness // 255\n        g = colors[i][1] * brightness // 255\n        b = colors[i][2] * brightness // 255\n        np[i] = (r, g, b)\n    np.write()\n\n    # 流水效果：颜色向右移动\n    last = colors.pop()\n    colors.insert(0, last)\n\n    time.sleep_ms(50)\n```\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 灯带不亮 | 检查供电 | NeoPixel需要5V供电，电流较大 |\n| 音量检测不灵敏 | 调整阈值 | 根据环境噪音调整基准值 |\n| 想要不同效果 | 修改算法 | 可以做呼吸灯、闪烁、追逐等效果 |\n\n---\n\n**步骤3：硬件搭建（20分钟）** `#高负荷-产出` `#IFC-即时`\n\n**教师话术**\n> \"今天的硬件：\n>\n> **NeoPixel灯带接线**：\n> ```\n> VCC → 5V（外部电源，不要用ESP32的5V）\n> GND → GND（与ESP32共地）\n> DIN → P4（数据输入）\n> ```\n>\n> **声音传感器接线**：\n> ```\n> VCC → 3.3V\n> GND → GND\n> AO  → P34（模拟输出）\n> ```\n>\n> **重要**：灯带耗电大，30颗灯全亮可能需要1.8A电流，必须用外部电源！\"\n\n**禁忌提醒**\n❌ **灯带直接接ESP32的5V**——电流不够，可能烧毁USB口\n❌ **忘记共地**——灯带和ESP32的GND必须连接\n❌ **数据线接错**——DIN是输入，DOUT是输出（级联用）\n\n---\n\n**步骤4：编程调试（30分钟）** `#高负荷-产出` `#IFC-即时`\n\n**教师话术**\n> \"调试步骤：\n>\n> 1. **先测试灯带**：\n>    ```python\n>    # 让所有灯亮红色\n>    for i in range(NUM_LEDS):\n>        np[i] = (255, 0, 0)\n>    np.write()\n>    ```\n>\n> 2. **再测试声音传感器**：\n>    ```python\n>    while True:\n>        print(mic.read())\n>        time.sleep_ms(100)\n>    ```\n>    对着传感器说话，观察数值变化\n>\n> 3. **最后联调**：\n>    - 安静时灯光暗\n>    - 声音大时灯光亮\n>    - 颜色在流动\"\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 灯光闪烁不稳定 | 添加平滑处理 | 用移动平均值平滑音量数据 |\n| 想做音乐节奏灯 | 检测节拍 | 检测音量的突变作为节拍 |\n| 想控制更多灯 | 级联灯带 | 多条灯带可以串联 |\n\n---\n\n**步骤5：成果展示（10分钟）** `#低负荷-热身` `#IFC-复盘`\n\n**教师话术**\n> \"谁的音乐律动灯做好了？放一首歌试试效果！\n>\n> 思考：如何让灯光效果更炫酷？\n> - 不同音量对应不同颜色\n> - 低音和高音分开显示\n> - 添加闪烁效果\"\n\n---\n\n**核心知识点**\n- NeoPixel灯带：可单独控制每颗LED颜色\n- 声音传感器：ADC读取模拟音量值\n- 流水灯算法：列表元素循环移位\n- 亮度映射：音量值映射到亮度\n\n**底层逻辑**\n- **数据驱动显示**：传感器数据 → 视觉效果\n- **列表操作**：pop()和insert()实现循环移位\n\n`#执行层` `#测评项`\n[UID: PYAI-14-09-001]\n\n---\n\n### 1-4-10 智能花房(1)\n\n#### 课程基本信息\n\n| 项目 | 内容 |\n|------|------|\n| **课程编号** | 1-4-10 |\n| **课程名称** | 智能花房(1) - 自动浇水系统 |\n| **认知负荷** | 中-高 |\n| **核心技能** | 土壤湿度传感器、水泵控制、自动化灌溉 |\n\n#### 详细教学流程\n\n**步骤1：课程导入（5分钟）** `#低负荷-热身` `#IFC-预防`\n\n**教师话术**\n> \"同学们养过植物吗？最头疼的是不是忘记浇水？今天我们来做一个**自动浇水系统**，让植物自己'喝水'！\"\n\n---\n\n**步骤2：知识讲解（15分钟）** `#中负荷-操练` `#IFC-即时`\n\n**教师话术**\n> \"**土壤湿度传感器**的工作原理：\n> - 两个金属探针插入土壤\n> - 土壤越湿，导电性越好，数值越低\n> - 土壤越干，导电性越差，数值越高\n>\n> **数值范围**（参考）：\n> - 0-300：非常湿润（刚浇过水）\n> - 300-700：适中\n> - 700-1000：偏干\n> - 1000以上：很干（需要浇水）\n>\n> **水泵控制**：\n> ```python\n> from mpython import *\n>\n> # 水泵连接到P8（通过继电器）\n> pump = Pin(Pin.P8, Pin.OUT)\n>\n> pump.write_digital(1)  # 开启水泵\n> time.sleep(2)          # 浇水2秒\n> pump.write_digital(0)  # 关闭水泵\n> ```\"\n\n**核心代码模式**\n\n```python\nfrom mpython import *\nimport time\n\n# 土壤湿度传感器连接到P0\nsoil_sensor = Pin(Pin.P0, Pin.IN)\n\n# 水泵连接到P8\npump = Pin(Pin.P8, Pin.OUT)\n\n# 干燥阈值\nDRY_THRESHOLD = 800\n\nwhile True:\n    # 读取土壤湿度\n    soil_value = soil_sensor.read_analog()\n    print(f\"土壤湿度: {soil_value}\")\n\n    # 判断是否需要浇水\n    if soil_value > DRY_THRESHOLD:\n        print(\"土壤干燥，开始浇水...\")\n        pump.write_digital(1)\n        time.sleep(3)  # 浇水3秒\n        pump.write_digital(0)\n        print(\"浇水完成，等待30秒...\")\n        time.sleep(30)  # 等待水分渗透\n    else:\n        print(\"土壤湿润，无需浇水\")\n\n    time.sleep(5)  # 每5秒检测一次\n```\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 数值不稳定 | 检查探针接触 | 探针要完全插入土壤 |\n| 阈值不准 | 实际测量 | 先测干土和湿土的数值 |\n| 想防止过度浇水 | 加冷却时间 | 浇水后等待一段时间再检测 |\n\n---\n\n**步骤3：硬件搭建（20分钟）** `#高负荷-产出` `#IFC-即时`\n\n**教师话术**\n> \"今天的硬件包括：\n>\n> **土壤湿度传感器接线**：\n> ```\n> VCC → 3.3V\n> GND → GND\n> AO  → P0（模拟输出）\n> ```\n>\n> **水泵模块接线**（通过继电器）：\n> ```\n> 继电器 VCC → 5V\n> 继电器 GND → GND\n> 继电器 IN  → P8\n> 水泵接继电器的常开端\n> ```\n>\n> **注意**：水泵需要单独供电，不能直接接ESP32！\"\n\n**禁忌提醒**\n❌ **水泵直接接ESP32**——电流太大会烧毁\n❌ **传感器长时间通电**——会加速腐蚀\n❌ **水溅到电路板**——会短路\n❌ **水管脱落**——会漏水\n\n---\n\n**步骤4：编程调试（30分钟）** `#高负荷-产出` `#IFC-即时`\n\n**教师话术**\n> \"测试步骤：\n>\n> 1. 先测试传感器：\n>    - 探针在空气中的数值\n>    - 探针插入干土的数值\n>    - 探针插入湿土的数值\n>\n> 2. 再测试水泵：\n>    - 手动控制开关\n>    - 确认水流正常\n>\n> 3. 最后联调：\n>    - 把探针插入干土\n>    - 观察是否自动浇水\"\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 水泵不工作 | 检查继电器 | 听继电器是否有\"咔嗒\"声 |\n| 浇水太多 | 减少浇水时间 | 把3秒改成1秒 |\n| 想加指示灯 | 用RGB显示状态 | 绿色=湿润，红色=干燥 |\n\n---\n\n**步骤5：成果展示（10分钟）** `#低负荷-热身` `#IFC-复盘`\n\n**教师话术**\n> \"谁的自动浇水系统做好了？演示一下！\n>\n> 思考：真正的智能花房还需要什么？\n> - 光照检测（是否需要补光）\n> - 温度检测（是否需要加热）\n> - 远程监控（手机查看状态）\"\n\n---\n\n**核心知识点**\n- 土壤湿度传感器：数值越高越干燥\n- 水泵控制：通过继电器间接控制\n- 防过度浇水：加入冷却等待时间\n- 阈值校准：根据实际土壤调整\n\n**底层逻辑**\n- **农业物联网**：感知土壤 → 智能决策 → 自动执行\n- **反馈控制**：检测 → 执行 → 等待 → 再检测\n\n`#执行层` `#测评项`\n[UID: PYAI-14-10-001]\n\n---\n\n### 1-4-11 智能花房(2)\n\n#### 课程基本信息\n\n| 项目 | 内容 |\n|------|------|\n| **课程编号** | 1-4-11 |\n| **课程名称** | 智能花房(2) - 可视化智能灌溉 |\n| **认知负荷** | 高 |\n| **核心技能** | OLED屏幕显示、数据可视化、多传感器融合 |\n\n#### 详细教学流程\n\n**步骤1：课程回顾（5分钟）** `#低负荷-热身` `#IFC-预防`\n\n**教师话术**\n> \"上节课我们做了自动浇水系统。但是，我们只能通过电脑看数据。今天我们要把数据显示在**OLED屏幕**上，让花房更智能！\"\n\n---\n\n**步骤2：知识讲解（15分钟）** `#中负荷-操练` `#IFC-即时`\n\n**教师话术**\n> \"**OLED屏幕**是一种小型显示屏：\n> - 分辨率：128×64像素\n> - 可以显示文字、数字、图形\n> - 自发光，不需要背光\n>\n> **显示函数**：\n> ```python\n> from mpython import *\n>\n> # 清屏\n> oled.fill(0)\n>\n> # 显示文字（x坐标, y坐标, 内容）\n> oled.DispChar('土壤湿度:', 0, 0)\n> oled.DispChar('750', 0, 16)\n>\n> # 显示英文\n> oled.DispChar('Soil: 750', 0, 32)\n>\n> # 更新显示\n> oled.show()\n> ```\n>\n> **进度条显示**：\n> ```python\n> # 画矩形框（x, y, 宽, 高, 颜色）\n> oled.rect(0, 50, 128, 10, 1)\n>\n> # 填充进度（根据湿度百分比）\n> progress = int(soil_value / 1024 * 128)\n> oled.fill_rect(0, 50, progress, 10, 1)\n> ```\"\n\n**核心代码模式**\n\n```python\nfrom mpython import *\nimport time\n\n# 传感器\nsoil_sensor = Pin(Pin.P0, Pin.IN)\npump = Pin(Pin.P8, Pin.OUT)\n\nDRY_THRESHOLD = 800\n\ndef update_display(soil_value, status):\n    \"\"\"更新OLED显示\"\"\"\n    oled.fill(0)  # 清屏\n\n    # 标题\n    oled.DispChar('智能花房', 32, 0)\n\n    # 土壤湿度\n    oled.DispChar(f'湿度: {soil_value}', 0, 20)\n\n    # 状态\n    oled.DispChar(f'状态: {status}', 0, 36)\n\n    # 进度条\n    oled.rect(0, 52, 128, 10, 1)\n    progress = min(128, int((1024 - soil_value) / 1024 * 128))\n    oled.fill_rect(0, 52, progress, 10, 1)\n\n    oled.show()\n\nwhile True:\n    soil_value = soil_sensor.read_analog()\n\n    if soil_value > DRY_THRESHOLD:\n        update_display(soil_value, '浇水中...')\n        pump.write_digital(1)\n        time.sleep(2)\n        pump.write_digital(0)\n        update_display(soil_value, '等待渗透')\n        time.sleep(30)\n    else:\n        update_display(soil_value, '湿润正常')\n\n    time.sleep(2)\n```\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 中文显示乱码 | 检查字体 | 确认使用DispChar而非text |\n| 进度条方向反 | 调整计算 | 湿度高时进度条应该长 |\n| 想加更多信息 | 分屏显示 | 用按键切换不同页面 |\n\n---\n\n**步骤3：硬件搭建（20分钟）** `#高负荷-产出` `#IFC-即时`\n\n**教师话术**\n> \"今天使用板载OLED屏幕，不需要额外接线！\n>\n> 硬件连接和上节课一样：\n> - 土壤湿度传感器 → P0\n> - 水泵继电器 → P8\n>\n> 如果想加入更多传感器：\n> - 光线传感器 → 板载\n> - 温度传感器 → P1\"\n\n---\n\n**步骤4：编程调试（30分钟）** `#高负荷-产出` `#IFC-即时`\n\n**教师话术**\n> \"调试重点：\n>\n> 1. **屏幕显示**：\n>    - 文字位置是否合适\n>    - 中文是否正常显示\n>    - 进度条是否正确\n>\n> 2. **数据更新**：\n>    - 数值是否实时变化\n>    - 状态是否正确切换\n>\n> 3. **整体联调**：\n>    - 浇水时屏幕显示'浇水中'\n>    - 正常时显示'湿润正常'\"\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 屏幕闪烁 | 减少刷新频率 | 不要每次循环都清屏 |\n| 想加图标 | 用画图函数 | oled.pixel()画点，oled.line()画线 |\n| 想记录历史 | 用列表存储 | 保存最近10次的数值 |\n\n---\n\n**步骤5：成果展示（10分钟）** `#低负荷-热身` `#IFC-复盘`\n\n**教师话术**\n> \"谁的可视化花房做好了？展示一下你的屏幕界面！\n>\n> 挑战：能不能加入更多功能？\n> - 显示当前时间\n> - 显示累计浇水次数\n> - 显示光照强度\"\n\n---\n\n**核心知识点**\n- OLED显示：`oled.DispChar()` 显示文字\n- 清屏和更新：`oled.fill(0)` + `oled.show()`\n- 进度条：`oled.rect()` 画框 + `oled.fill_rect()` 填充\n- 数据可视化：把数值转换为图形\n\n**底层逻辑**\n- **人机交互**：数据 → 可视化 → 用户理解\n- **系统集成**：传感器 + 执行器 + 显示器\n\n`#执行层` `#测评项`\n[UID: PYAI-14-11-001]\n\n---\n\n### 1-4-12 家居回顾\n\n#### 课程基本信息\n\n| 项目 | 内容 |\n|------|------|\n| **课程编号** | 1-4-12 |\n| **课程名称** | 家居回顾 - 物联网架构复盘 |\n| **认知负荷** | 中 |\n| **核心技能** | 物联网架构、AI流程、系统设计思维 |\n\n#### 详细教学流程\n\n**步骤1：课程导入（5分钟）** `#低负荷-热身` `#IFC-预防`\n\n**教师话术**\n> \"同学们，这个单元我们做了很多智能硬件项目。今天我们来回顾总结，看看这些项目有什么共同点！\"\n\n---\n\n**步骤2：知识回顾（20分钟）** `#中负荷-操练` `#IFC-即时`\n\n**教师话术**\n> \"**物联网三层架构**：\n>\n> ```\n> ┌─────────────────────────────────────┐\n> │           应用层（执行）              │\n> │   LED、RGB、蜂鸣器、电机、舵机、屏幕   │\n> └─────────────────────────────────────┘\n>                    ↑\n> ┌─────────────────────────────────────┐\n> │           处理层（决策）              │\n> │      ESP32 + Python代码              │\n> │      if判断、阈值比较、AI算法         │\n> └─────────────────────────────────────┘\n>                    ↑\n> ┌─────────────────────────────────────┐\n> │           感知层（输入）              │\n> │   光线传感器、气体传感器、土壤传感器   │\n> │   摄像头、温度传感器、按键            │\n> └─────────────────────────────────────┘\n> ```\n>\n> **我们做过的项目**：\n>\n> | 项目 | 感知层 | 处理层 | 应用层 |\n> |------|--------|--------|--------|\n> | 智能夜灯 | 光线传感器 | 阈值判断 | LED/RGB |\n> | 智能通风 | 气体传感器 | 阈值判断 | 电机+蜂鸣器 |\n> | 智能门禁 | 摄像头 | AI人脸识别 | 舵机 |\n> | 智能花房 | 土壤传感器 | 阈值判断 | 水泵+OLED |\"\n\n**核心代码模式**\n\n```python\n# 物联网项目通用模板\nfrom mpython import *\nimport time\n\n# 1. 感知层：初始化传感器\nsensor = Pin(Pin.P0, Pin.IN)\n\n# 2. 应用层：初始化执行器\nactuator = Pin(Pin.P8, Pin.OUT)\n\n# 3. 处理层：设置阈值\nTHRESHOLD = 500\n\nwhile True:\n    # 感知：读取传感器\n    value = sensor.read_analog()\n\n    # 处理：判断决策\n    if value > THRESHOLD:\n        # 应用：执行动作\n        actuator.write_digital(1)\n    else:\n        actuator.write_digital(0)\n\n    time.sleep(1)\n```\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 概念混淆 | 用具体例子 | \"光线传感器是感知层，LED是应用层\" |\n| 想设计新项目 | 引导思考 | \"你想感知什么？执行什么？\" |\n| 忘记某个项目 | 快速回顾 | 展示之前的代码和硬件 |\n\n---\n\n**步骤3：AI流程复盘（15分钟）** `#中负荷-操练` `#IFC-即时`\n\n**教师话术**\n> \"**AI视觉流程**（智能门禁）：\n>\n> ```\n> 摄像头采集 → 灰度处理 → 特征提取 → 模板匹配 → 决策输出\n>     ↓            ↓           ↓           ↓          ↓\n>   frame      cvtColor    matchTemplate  相似度    开门/拒绝\n> ```\n>\n> **AI的本质**：\n> - 输入：传感器数据（图像、声音、数值）\n> - 处理：算法分析（匹配、分类、预测）\n> - 输出：决策结果（开门、报警、浇水）\n>\n> **AI和普通程序的区别**：\n> - 普通程序：固定规则（if value > 500）\n> - AI程序：学习规则（从数据中学习判断标准）\"\n\n---\n\n**步骤4：方案设计（25分钟）** `#高负荷-产出` `#IFC-即时`\n\n**教师话术**\n> \"现在请设计一个**智能家居方案**！\n>\n> 要求：\n> 1. 选择至少2个传感器\n> 2. 选择至少2个执行器\n> 3. 画出系统架构图\n> 4. 写出核心代码逻辑\n>\n> 示例：**智能卧室**\n> - 感知：光线传感器 + 温度传感器\n> - 处理：ESP32判断\n> - 应用：窗帘电机 + 空调控制 + 夜灯\n>\n> 逻辑：\n> - 光线暗 + 晚上 → 开夜灯\n> - 温度高 → 开空调\n> - 早上 + 光线亮 → 开窗帘\"\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 没有思路 | 提供场景 | \"想想厨房/浴室/客厅需要什么\" |\n| 方案太简单 | 引导扩展 | \"能不能加入手机控制？\" |\n| 方案太复杂 | 简化聚焦 | \"先实现最核心的功能\" |\n\n---\n\n**步骤5：成果展示（15分钟）** `#低负荷-热身` `#IFC-复盘`\n\n**教师话术**\n> \"请上来展示你的智能家居方案！\n>\n> 评价标准：\n> - 创意性：解决了什么实际问题？\n> - 可行性：技术上能否实现？\n> - 完整性：三层架构是否完整？\"\n\n---\n\n**核心知识点**\n- 物联网三层架构：感知层 → 处理层 → 应用层\n- AI视觉流程：采集 → 处理 → 匹配 → 决策\n- 系统设计思维：从需求出发，分层设计\n\n**底层逻辑**\n- **系统思维**：把复杂问题分解为三层\n- **工程思维**：从设计到实现的完整流程\n\n`#执行层` `#测评项`\n[UID: PYAI-14-12-001]\n[关联: PYAI-24-001 PythonAI计算机视觉（进阶衔接）]\n\n---\n\n## 教学禁忌清单（硬件安全红线）\n\n| 序号 | 禁忌 | 原因 | 正确做法 |\n|------|------|------|----------|\n| 1 | ❌ **带电接线** | 短路烧毁开发板 | 必须断电后再接线 |\n| 2 | ❌ **短路（VCC直接接GND）** | 烧毁开发板 | 红线(VCC)和黑线(GND)绝对不能直接连接 |\n| 3 | ❌ **开发板放金属表面通电** | 底部引脚短路 | 放在绝缘表面（桌面、纸板） |\n| 4 | ❌ **强行扭动舵机** | 损坏内部齿轮 | 不要用力手动扭转舵机摆臂 |\n| 5 | ❌ **在boot.py写死循环无延时** | 开发板无法重新连接 | 谨慎编辑启动文件 |\n| 6 | ❌ **忘记释放摄像头** | 下次无法使用 | 程序结束前调用cap.release() |\n\n`#执行层` `#测评项`\n[UID: PYAI-TABOO-14]\n\n---\n\n## 教学注意事项\n\n| 类别 | 注意事项 |\n|------|----------|\n| **硬件保护** | 开发板不要放在金属表面通电；接线前必须断电 |\n| **舵机使用** | 通电或未通电状态下不要强行手动扭转 |\n| **库导入** | 建议使用standard形式（如import machine），避免命名空间污染 |\n| **调试技巧** | 用print()输出传感器数值，确认硬件正常工作 |\n\n---\n\n## 底层教育学原理\n\n| 原理 | 说明 | 在本单元的应用 |\n|------|------|----------------|\n| **物联网架构** | 感知层-网络层-应用层 | 传感器→ESP32/Python→执行器 |\n| **AI视觉流程** | 采集-处理-输出 | 摄像头→灰度/匹配→舵机控制 |\n| **软硬结合** | 代码驱动物理硬件 | Python控制LED、电机、舵机 |\n| **项目制学习** | 完整项目驱动学习 | 智能夜灯、智能门禁、智能花房 |\n\n`#执行层` `#测评项`\n[UID: PYAI-THEORY-14]\n\n---\n\n**质量评估**：10/10（原子化萃取版，10节课完整萃取）\n**已补充**：认知负荷标签、IFC标签、变体示例、详细教师话术、硬件安全禁忌、核心代码模式\n**课程覆盖**：1-4-1, 1-4-3, 1-4-4, 1-4-5, 1-4-6/7/8, 1-4-10, 1-4-11, 1-4-12 全部10节课\n\n---\n\n**最后更新**：2026-02-09\n"
}