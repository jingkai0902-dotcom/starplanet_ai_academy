{
  "title": "算法基础",
  "source": "C:\\Users\\Frank.J\\starplanet_ai_academy\\知识库\\02_知识点数据库\\编程概念库\\算法基础.md",
  "sections": [
    {
      "title": "一、搜索算法",
      "content": "### 1.1 线性搜索\n\n#### 概念定义\n从头到尾依次检查每个元素，直到找到目标或遍历完所有元素。\n\n#### 跨课程出现\n\n| 课程编号 | 课程名称 | 具体内容 |\n|----------|---------|---------|\n| PYAI 2-1-5 | 线性搜索 | 搜索效率、列表遍历 |\n\n#### Python示例\n```python\ndef linear_search(arr, target):\n    \"\"\"线性搜索：返回目标的索引，未找到返回-1\"\"\"\n    for i in range(len(arr)):\n        if arr[i] == target:\n            return i\n    return -1\n\n# 使用\nnumbers = [5, 2, 8, 1, 9, 3]\nindex = linear_search(numbers, 8)\nprint(f\"找到8在索引: {index}\")  # 输出: 找到8在索引: 2\n```\n\n#### 特点\n- 时间复杂度：O(n)\n- 适用于无序列表\n- 简单但效率较低\n\n### 1.2 二分搜索\n\n#### 概念定义\n在有序列表中，每次将搜索范围缩小一半，快速定位目标。\n\n#### 跨课程出现\n\n| 课程编号 | 课程名称 | 具体内容 |\n|----------|---------|---------|\n| CODE2-3-01 | 二分查找思维 | 通过反馈缩小范围 |\n| PYAI 2-1-1 | 二分法 | math库应用 |\n| PYAI 2-1-6 | 二分搜索 | 有序列表、搜索优化 |\n\n#### Scratch思维示例（猜数字）\n```\n设定 [最小值] 为 (1)\n设定 [最大值] 为 (100)\n重复执行直到 <(猜测) = (答案)>\n    设定 [猜测] 为 ((最小值) + (最大值)) / 2 取整\n    如果 <(猜测) < (答案)> 那么\n        设定 [最小值] 为 (猜测 + 1)\n    否则\n        设定 [最大值] 为 (猜测 - 1)\n```\n\n#### Python示例\n```python\ndef binary_search(arr, target):\n    \"\"\"二分搜索：返回目标的索引，未找到返回-1\"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\n# 使用（列表必须有序）\nnumbers = [1, 2, 3, 5, 8, 9, 12, 15, 20]\nindex = binary_search(numbers, 8)\nprint(f\"找到8在索引: {index}\")  # 输出: 找到8在索引: 4\n```\n\n#### 特点\n- 时间复杂度：O(log n)\n- **必须是有序列表**\n- 效率远高于线性搜索\n\n#### 搜索效率对比\n\n| 列表大小 | 线性搜索最坏情况 | 二分搜索最坏情况 |\n|---------|-----------------|-----------------|\n| 10 | 10次 | 4次 |\n| 100 | 100次 | 7次 |\n| 1000 | 1000次 | 10次 |\n| 1000000 | 1000000次 | 20次 |\n\n---"
    },
    {
      "title": "二、排序算法",
      "content": "### 2.1 冒泡排序\n\n#### 概念定义\n重复遍历列表，比较相邻元素，如果顺序错误就交换，直到没有需要交换的元素。\n\n#### 跨课程出现\n\n| 课程编号 | 课程名称 | 具体内容 |\n|----------|---------|---------|\n| PYAI 2-1-8 | 冒泡排序 | 时间复杂度 |\n\n#### Python示例\n```python\ndef bubble_sort(arr):\n    \"\"\"冒泡排序\"\"\"\n    n = len(arr)\n    for i in range(n):\n        # 每轮将最大的元素\"冒泡\"到末尾\n        for j in range(0, n - i - 1):\n            if arr[j] > arr[j + 1]:\n                # 交换\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n    return arr\n\n# 使用\nnumbers = [64, 34, 25, 12, 22, 11, 90]\nsorted_numbers = bubble_sort(numbers)\nprint(sorted_numbers)  # [11, 12, 22, 25, 34, 64, 90]\n```\n\n#### 可视化过程\n```\n原始: [64, 34, 25, 12]\n\n第1轮:\n  比较64和34 → 交换 → [34, 64, 25, 12]\n  比较64和25 → 交换 → [34, 25, 64, 12]\n  比较64和12 → 交换 → [34, 25, 12, 64]  ← 64到位\n\n第2轮:\n  比较34和25 → 交换 → [25, 34, 12, 64]\n  比较34和12 → 交换 → [25, 12, 34, 64]  ← 34到位\n\n第3轮:\n  比较25和12 → 交换 → [12, 25, 34, 64]  ← 完成\n```\n\n#### 特点\n- 时间复杂度：O(n²)\n- 简单易懂，适合教学\n- 效率较低，不适合大数据\n\n### 2.2 选择排序\n\n#### 概念定义\n每次从未排序部分选择最小的元素，放到已排序部分的末尾。\n\n#### 跨课程出现\n\n| 课程编号 | 课程名称 | 具体内容 |\n|----------|---------|---------|\n| PYAI 2-1-9 | 选择排序 | 排序对比 |\n\n#### Python示例\n```python\ndef selection_sort(arr):\n    \"\"\"选择排序\"\"\"\n    n = len(arr)\n    for i in range(n):\n        # 找到未排序部分的最小值索引\n        min_idx = i\n        for j in range(i + 1, n):\n            if arr[j] < arr[min_idx]:\n                min_idx = j\n        # 交换\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\n    return arr\n\n# 使用\nnumbers = [64, 25, 12, 22, 11]\nsorted_numbers = selection_sort(numbers)\nprint(sorted_numbers)  # [11, 12, 22, 25, 64]\n```\n\n### 2.3 插入排序\n\n#### 概念定义\n将未排序的元素逐个插入到已排序部分的正确位置。\n\n#### 跨课程出现\n\n| 课程编号 | 课程名称 | 具体内容 |\n|----------|---------|---------|\n| PYAI 2-1-9 | 插入排序 | 排序对比 |\n\n#### Python示例\n```python\ndef insertion_sort(arr):\n    \"\"\"插入排序\"\"\"\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        # 将大于key的元素向后移动\n        while j >= 0 and arr[j] > key:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n    return arr\n\n# 使用\nnumbers = [12, 11, 13, 5, 6]\nsorted_numbers = insertion_sort(numbers)\nprint(sorted_numbers)  # [5, 6, 11, 12, 13]\n```\n\n### 排序算法对比\n\n| 算法 | 时间复杂度 | 空间复杂度 | 稳定性 | 特点 |\n|------|-----------|-----------|--------|------|\n| 冒泡排序 | O(n²) | O(1) | 稳定 | 简单，适合教学 |\n| 选择排序 | O(n²) | O(1) | 不稳定 | 交换次数少 |\n| 插入排序 | O(n²) | O(1) | 稳定 | 小数据效率高 |\n\n---"
    },
    {
      "title": "三、递归",
      "content": "### 概念定义\n函数调用自身的编程技巧，将问题分解为更小的相同子问题。\n\n### 跨课程出现\n\n| 课程编号 | 课程名称 | 具体内容 |\n|----------|---------|---------|\n| PYAI 2-1-3 | 递归函数 | 递归终止条件、调用栈 |\n| PYAI 2-1-4 | 递归应用 | 分治思想、汉诺塔 |\n\n### 3.1 递归三要素\n\n1. **终止条件**：何时停止递归\n2. **递归调用**：调用自身\n3. **问题缩小**：每次调用问题规模变小\n\n### 3.2 经典递归示例\n\n#### 阶乘\n```python\ndef factorial(n):\n    \"\"\"计算n的阶乘: n! = n × (n-1) × ... × 1\"\"\"\n    # 终止条件\n    if n <= 1:\n        return 1\n    # 递归调用\n    return n * factorial(n - 1)\n\nprint(factorial(5))  # 120 = 5 × 4 × 3 × 2 × 1\n```\n\n#### 调用过程可视化\n```\nfactorial(5)\n  → 5 × factorial(4)\n       → 4 × factorial(3)\n            → 3 × factorial(2)\n                 → 2 × factorial(1)\n                      → 1  (终止条件)\n                 ← 2 × 1 = 2\n            ← 3 × 2 = 6\n       ← 4 × 6 = 24\n  ← 5 × 24 = 120\n```\n\n#### 斐波那契数列\n```python\ndef fibonacci(n):\n    \"\"\"计算第n个斐波那契数\"\"\"\n    if n <= 1:\n        return n\n    return fibonacci(n - 1) + fibonacci(n - 2)\n\n# 0, 1, 1, 2, 3, 5, 8, 13, 21, 34...\nfor i in range(10):\n    print(fibonacci(i), end=' ')\n```\n\n### 3.3 汉诺塔问题\n\n#### 跨课程出现\n\n| 课程编号 | 课程名称 | 具体内容 |\n|----------|---------|---------|\n| PYAI 2-1-4 | 汉诺塔 | 分治思想 |\n\n#### Python示例\n```python\ndef hanoi(n, source, auxiliary, target):\n    \"\"\"\n    汉诺塔问题\n    n: 盘子数量\n    source: 起始柱\n    auxiliary: 辅助柱\n    target: 目标柱\n    \"\"\"\n    if n == 1:\n        print(f\"移动盘子从 {source} 到 {target}\")\n        return\n\n    # 1. 将n-1个盘子从source移到auxiliary\n    hanoi(n - 1, source, target, auxiliary)\n\n    # 2. 将最大的盘子从source移到target\n    print(f\"移动盘子从 {source} 到 {target}\")\n\n    # 3. 将n-1个盘子从auxiliary移到target\n    hanoi(n - 1, auxiliary, source, target)\n\n# 使用\nhanoi(3, 'A', 'B', 'C')\n```\n\n#### 输出\n```\n移动盘子从 A 到 C\n移动盘子从 A 到 B\n移动盘子从 C 到 B\n移动盘子从 A 到 C\n移动盘子从 B 到 A\n移动盘子从 B 到 C\n移动盘子从 A 到 C\n```\n\n---"
    },
    {
      "title": "四、算法在游戏中的应用",
      "content": "### 4.1 碰撞检测算法\n\n#### 跨课程出现\n\n| 课程编号 | 课程名称 | 具体内容 |\n|----------|---------|---------|\n| PYAI 1-2-1 | 圆形碰撞检测 | 距离公式 |\n| PYAI 1-2-2 | 矩形碰撞检测 | 比较运算符 |\n| CODE3-2-02 | 碰撞检测 | 检测两个角色是否接触 |\n\n#### 圆形碰撞检测\n```python\nimport math\n\ndef circle_collision(x1, y1, r1, x2, y2, r2):\n    \"\"\"检测两个圆是否碰撞\"\"\"\n    distance = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\n    return distance < r1 + r2\n\n# 使用\nif circle_collision(100, 100, 30, 150, 120, 25):\n    print(\"碰撞了！\")\n```\n\n#### 矩形碰撞检测（AABB）\n```python\ndef rect_collision(x1, y1, w1, h1, x2, y2, w2, h2):\n    \"\"\"检测两个矩形是否碰撞\"\"\"\n    x_overlap = x1 < x2 + w2 and x1 + w1 > x2\n    y_overlap = y1 < y2 + h2 and y1 + h1 > y2\n    return x_overlap and y_overlap\n\n# 使用\nif rect_collision(100, 100, 50, 50, 130, 120, 40, 40):\n    print(\"碰撞了！\")\n```\n\n### 4.2 数值映射算法\n\n#### 跨课程出现\n\n| 课程编号 | 课程名称 | 具体内容 |\n|----------|---------|---------|\n| CODE2-1-10 | 数值映射 | 将一个范围映射到另一个范围 |\n| MP1-L8 | 舵机与映射 | 旋钮值映射到角度 |\n\n#### Python示例\n```python\ndef map_value(x, in_min, in_max, out_min, out_max):\n    \"\"\"将x从[in_min, in_max]映射到[out_min, out_max]\"\"\"\n    return (x - in_min) * (out_max - out_min) // (in_max - in_min) + out_min\n\n# 将旋钮值(0-4095)映射到舵机角度(0-180)\nknob_value = 2048\nangle = map_value(knob_value, 0, 4095, 0, 180)\nprint(f\"角度: {angle}\")  # 约90度\n```\n\n---"
    },
    {
      "title": "五、算法进阶路线",
      "content": "```\nCODE2-3-01          PYAI 2-1-5          PYAI 2-1-6          PYAI 2-1-8          PYAI 2-1-3\n二分思维     →      线性搜索     →      二分搜索     →      排序算法     →      递归\n   ↓                   ↓                   ↓                   ↓                   ↓\n 猜数字             遍历查找            折半查找            冒泡/选择           自我调用\n```\n\n---"
    },
    {
      "title": "六、常见错误与禁忌",
      "content": "| 错误 | 后果 | 正确做法 |\n|------|------|---------|\n| ❌ 二分搜索用于无序列表 | 结果错误 | 先排序或使用线性搜索 |\n| ❌ 递归无终止条件 | 栈溢出 | 必须有终止条件 |\n| ❌ 递归深度过大 | RecursionError | 改用迭代或增加递归限制 |\n| ❌ 排序时修改原列表 | 数据丢失 | 需要时先复制列表 |\n\n---\n\n**维护者**：知识库管理员\n**数据来源**：萃取报告/CODE/、萃取报告/PythonAI/\n**整合原则**：基于现有萃取报告，不压缩删减"
    }
  ],
  "full_content": "# 算法基础\n\n> **用途**：跨课程算法基础（搜索、排序、递归）详细说明\n> **更新日期**：2026-02-10\n> **数据来源**：萃取报告/CODE/、萃取报告/PythonAI/\n> **整合原则**：基于现有萃取报告，不压缩删减\n\n---\n\n## 一、搜索算法\n\n### 1.1 线性搜索\n\n#### 概念定义\n从头到尾依次检查每个元素，直到找到目标或遍历完所有元素。\n\n#### 跨课程出现\n\n| 课程编号 | 课程名称 | 具体内容 |\n|----------|---------|---------|\n| PYAI 2-1-5 | 线性搜索 | 搜索效率、列表遍历 |\n\n#### Python示例\n```python\ndef linear_search(arr, target):\n    \"\"\"线性搜索：返回目标的索引，未找到返回-1\"\"\"\n    for i in range(len(arr)):\n        if arr[i] == target:\n            return i\n    return -1\n\n# 使用\nnumbers = [5, 2, 8, 1, 9, 3]\nindex = linear_search(numbers, 8)\nprint(f\"找到8在索引: {index}\")  # 输出: 找到8在索引: 2\n```\n\n#### 特点\n- 时间复杂度：O(n)\n- 适用于无序列表\n- 简单但效率较低\n\n### 1.2 二分搜索\n\n#### 概念定义\n在有序列表中，每次将搜索范围缩小一半，快速定位目标。\n\n#### 跨课程出现\n\n| 课程编号 | 课程名称 | 具体内容 |\n|----------|---------|---------|\n| CODE2-3-01 | 二分查找思维 | 通过反馈缩小范围 |\n| PYAI 2-1-1 | 二分法 | math库应用 |\n| PYAI 2-1-6 | 二分搜索 | 有序列表、搜索优化 |\n\n#### Scratch思维示例（猜数字）\n```\n设定 [最小值] 为 (1)\n设定 [最大值] 为 (100)\n重复执行直到 <(猜测) = (答案)>\n    设定 [猜测] 为 ((最小值) + (最大值)) / 2 取整\n    如果 <(猜测) < (答案)> 那么\n        设定 [最小值] 为 (猜测 + 1)\n    否则\n        设定 [最大值] 为 (猜测 - 1)\n```\n\n#### Python示例\n```python\ndef binary_search(arr, target):\n    \"\"\"二分搜索：返回目标的索引，未找到返回-1\"\"\"\n    left = 0\n    right = len(arr) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n\n# 使用（列表必须有序）\nnumbers = [1, 2, 3, 5, 8, 9, 12, 15, 20]\nindex = binary_search(numbers, 8)\nprint(f\"找到8在索引: {index}\")  # 输出: 找到8在索引: 4\n```\n\n#### 特点\n- 时间复杂度：O(log n)\n- **必须是有序列表**\n- 效率远高于线性搜索\n\n#### 搜索效率对比\n\n| 列表大小 | 线性搜索最坏情况 | 二分搜索最坏情况 |\n|---------|-----------------|-----------------|\n| 10 | 10次 | 4次 |\n| 100 | 100次 | 7次 |\n| 1000 | 1000次 | 10次 |\n| 1000000 | 1000000次 | 20次 |\n\n---\n\n## 二、排序算法\n\n### 2.1 冒泡排序\n\n#### 概念定义\n重复遍历列表，比较相邻元素，如果顺序错误就交换，直到没有需要交换的元素。\n\n#### 跨课程出现\n\n| 课程编号 | 课程名称 | 具体内容 |\n|----------|---------|---------|\n| PYAI 2-1-8 | 冒泡排序 | 时间复杂度 |\n\n#### Python示例\n```python\ndef bubble_sort(arr):\n    \"\"\"冒泡排序\"\"\"\n    n = len(arr)\n    for i in range(n):\n        # 每轮将最大的元素\"冒泡\"到末尾\n        for j in range(0, n - i - 1):\n            if arr[j] > arr[j + 1]:\n                # 交换\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n    return arr\n\n# 使用\nnumbers = [64, 34, 25, 12, 22, 11, 90]\nsorted_numbers = bubble_sort(numbers)\nprint(sorted_numbers)  # [11, 12, 22, 25, 34, 64, 90]\n```\n\n#### 可视化过程\n```\n原始: [64, 34, 25, 12]\n\n第1轮:\n  比较64和34 → 交换 → [34, 64, 25, 12]\n  比较64和25 → 交换 → [34, 25, 64, 12]\n  比较64和12 → 交换 → [34, 25, 12, 64]  ← 64到位\n\n第2轮:\n  比较34和25 → 交换 → [25, 34, 12, 64]\n  比较34和12 → 交换 → [25, 12, 34, 64]  ← 34到位\n\n第3轮:\n  比较25和12 → 交换 → [12, 25, 34, 64]  ← 完成\n```\n\n#### 特点\n- 时间复杂度：O(n²)\n- 简单易懂，适合教学\n- 效率较低，不适合大数据\n\n### 2.2 选择排序\n\n#### 概念定义\n每次从未排序部分选择最小的元素，放到已排序部分的末尾。\n\n#### 跨课程出现\n\n| 课程编号 | 课程名称 | 具体内容 |\n|----------|---------|---------|\n| PYAI 2-1-9 | 选择排序 | 排序对比 |\n\n#### Python示例\n```python\ndef selection_sort(arr):\n    \"\"\"选择排序\"\"\"\n    n = len(arr)\n    for i in range(n):\n        # 找到未排序部分的最小值索引\n        min_idx = i\n        for j in range(i + 1, n):\n            if arr[j] < arr[min_idx]:\n                min_idx = j\n        # 交换\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\n    return arr\n\n# 使用\nnumbers = [64, 25, 12, 22, 11]\nsorted_numbers = selection_sort(numbers)\nprint(sorted_numbers)  # [11, 12, 22, 25, 64]\n```\n\n### 2.3 插入排序\n\n#### 概念定义\n将未排序的元素逐个插入到已排序部分的正确位置。\n\n#### 跨课程出现\n\n| 课程编号 | 课程名称 | 具体内容 |\n|----------|---------|---------|\n| PYAI 2-1-9 | 插入排序 | 排序对比 |\n\n#### Python示例\n```python\ndef insertion_sort(arr):\n    \"\"\"插入排序\"\"\"\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        # 将大于key的元素向后移动\n        while j >= 0 and arr[j] > key:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n    return arr\n\n# 使用\nnumbers = [12, 11, 13, 5, 6]\nsorted_numbers = insertion_sort(numbers)\nprint(sorted_numbers)  # [5, 6, 11, 12, 13]\n```\n\n### 排序算法对比\n\n| 算法 | 时间复杂度 | 空间复杂度 | 稳定性 | 特点 |\n|------|-----------|-----------|--------|------|\n| 冒泡排序 | O(n²) | O(1) | 稳定 | 简单，适合教学 |\n| 选择排序 | O(n²) | O(1) | 不稳定 | 交换次数少 |\n| 插入排序 | O(n²) | O(1) | 稳定 | 小数据效率高 |\n\n---\n\n## 三、递归\n\n### 概念定义\n函数调用自身的编程技巧，将问题分解为更小的相同子问题。\n\n### 跨课程出现\n\n| 课程编号 | 课程名称 | 具体内容 |\n|----------|---------|---------|\n| PYAI 2-1-3 | 递归函数 | 递归终止条件、调用栈 |\n| PYAI 2-1-4 | 递归应用 | 分治思想、汉诺塔 |\n\n### 3.1 递归三要素\n\n1. **终止条件**：何时停止递归\n2. **递归调用**：调用自身\n3. **问题缩小**：每次调用问题规模变小\n\n### 3.2 经典递归示例\n\n#### 阶乘\n```python\ndef factorial(n):\n    \"\"\"计算n的阶乘: n! = n × (n-1) × ... × 1\"\"\"\n    # 终止条件\n    if n <= 1:\n        return 1\n    # 递归调用\n    return n * factorial(n - 1)\n\nprint(factorial(5))  # 120 = 5 × 4 × 3 × 2 × 1\n```\n\n#### 调用过程可视化\n```\nfactorial(5)\n  → 5 × factorial(4)\n       → 4 × factorial(3)\n            → 3 × factorial(2)\n                 → 2 × factorial(1)\n                      → 1  (终止条件)\n                 ← 2 × 1 = 2\n            ← 3 × 2 = 6\n       ← 4 × 6 = 24\n  ← 5 × 24 = 120\n```\n\n#### 斐波那契数列\n```python\ndef fibonacci(n):\n    \"\"\"计算第n个斐波那契数\"\"\"\n    if n <= 1:\n        return n\n    return fibonacci(n - 1) + fibonacci(n - 2)\n\n# 0, 1, 1, 2, 3, 5, 8, 13, 21, 34...\nfor i in range(10):\n    print(fibonacci(i), end=' ')\n```\n\n### 3.3 汉诺塔问题\n\n#### 跨课程出现\n\n| 课程编号 | 课程名称 | 具体内容 |\n|----------|---------|---------|\n| PYAI 2-1-4 | 汉诺塔 | 分治思想 |\n\n#### Python示例\n```python\ndef hanoi(n, source, auxiliary, target):\n    \"\"\"\n    汉诺塔问题\n    n: 盘子数量\n    source: 起始柱\n    auxiliary: 辅助柱\n    target: 目标柱\n    \"\"\"\n    if n == 1:\n        print(f\"移动盘子从 {source} 到 {target}\")\n        return\n\n    # 1. 将n-1个盘子从source移到auxiliary\n    hanoi(n - 1, source, target, auxiliary)\n\n    # 2. 将最大的盘子从source移到target\n    print(f\"移动盘子从 {source} 到 {target}\")\n\n    # 3. 将n-1个盘子从auxiliary移到target\n    hanoi(n - 1, auxiliary, source, target)\n\n# 使用\nhanoi(3, 'A', 'B', 'C')\n```\n\n#### 输出\n```\n移动盘子从 A 到 C\n移动盘子从 A 到 B\n移动盘子从 C 到 B\n移动盘子从 A 到 C\n移动盘子从 B 到 A\n移动盘子从 B 到 C\n移动盘子从 A 到 C\n```\n\n---\n\n## 四、算法在游戏中的应用\n\n### 4.1 碰撞检测算法\n\n#### 跨课程出现\n\n| 课程编号 | 课程名称 | 具体内容 |\n|----------|---------|---------|\n| PYAI 1-2-1 | 圆形碰撞检测 | 距离公式 |\n| PYAI 1-2-2 | 矩形碰撞检测 | 比较运算符 |\n| CODE3-2-02 | 碰撞检测 | 检测两个角色是否接触 |\n\n#### 圆形碰撞检测\n```python\nimport math\n\ndef circle_collision(x1, y1, r1, x2, y2, r2):\n    \"\"\"检测两个圆是否碰撞\"\"\"\n    distance = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\n    return distance < r1 + r2\n\n# 使用\nif circle_collision(100, 100, 30, 150, 120, 25):\n    print(\"碰撞了！\")\n```\n\n#### 矩形碰撞检测（AABB）\n```python\ndef rect_collision(x1, y1, w1, h1, x2, y2, w2, h2):\n    \"\"\"检测两个矩形是否碰撞\"\"\"\n    x_overlap = x1 < x2 + w2 and x1 + w1 > x2\n    y_overlap = y1 < y2 + h2 and y1 + h1 > y2\n    return x_overlap and y_overlap\n\n# 使用\nif rect_collision(100, 100, 50, 50, 130, 120, 40, 40):\n    print(\"碰撞了！\")\n```\n\n### 4.2 数值映射算法\n\n#### 跨课程出现\n\n| 课程编号 | 课程名称 | 具体内容 |\n|----------|---------|---------|\n| CODE2-1-10 | 数值映射 | 将一个范围映射到另一个范围 |\n| MP1-L8 | 舵机与映射 | 旋钮值映射到角度 |\n\n#### Python示例\n```python\ndef map_value(x, in_min, in_max, out_min, out_max):\n    \"\"\"将x从[in_min, in_max]映射到[out_min, out_max]\"\"\"\n    return (x - in_min) * (out_max - out_min) // (in_max - in_min) + out_min\n\n# 将旋钮值(0-4095)映射到舵机角度(0-180)\nknob_value = 2048\nangle = map_value(knob_value, 0, 4095, 0, 180)\nprint(f\"角度: {angle}\")  # 约90度\n```\n\n---\n\n## 五、算法进阶路线\n\n```\nCODE2-3-01          PYAI 2-1-5          PYAI 2-1-6          PYAI 2-1-8          PYAI 2-1-3\n二分思维     →      线性搜索     →      二分搜索     →      排序算法     →      递归\n   ↓                   ↓                   ↓                   ↓                   ↓\n 猜数字             遍历查找            折半查找            冒泡/选择           自我调用\n```\n\n---\n\n## 六、常见错误与禁忌\n\n| 错误 | 后果 | 正确做法 |\n|------|------|---------|\n| ❌ 二分搜索用于无序列表 | 结果错误 | 先排序或使用线性搜索 |\n| ❌ 递归无终止条件 | 栈溢出 | 必须有终止条件 |\n| ❌ 递归深度过大 | RecursionError | 改用迭代或增加递归限制 |\n| ❌ 排序时修改原列表 | 数据丢失 | 需要时先复制列表 |\n\n---\n\n**维护者**：知识库管理员\n**数据来源**：萃取报告/CODE/、萃取报告/PythonAI/\n**整合原则**：基于现有萃取报告，不压缩删减\n"
}