{
  "title": "人脸识别",
  "source": "C:\\Users\\Frank.J\\starplanet_ai_academy\\知识库\\02_知识点数据库\\AI知识库\\人脸识别.md",
  "sections": [
    {
      "title": "一、技术概述",
      "content": "### 1.1 人脸识别流程\n\n```\n图像采集 → 人脸检测 → 特征提取 → 特征匹配 → 身份确认\n```\n\n### 1.2 跨课程出现\n\n| 课程编号 | 课程名称 | 具体内容 |\n|----------|---------|---------|\n| PYAI 1-4-6 | 智能门禁(1) | 人脸捕捉 |\n| PYAI 1-4-7 | 智能门禁(2) | 人脸比对 |\n| PYAI 1-4-8 | 智能门禁(3) | 刷脸开门 |\n| PYAI 2-3-1 | 眼控开关 | FaceMesh |\n\n---"
    },
    {
      "title": "二、MediaPipe FaceMesh",
      "content": "### 2.1 简介\n\nMediaPipe FaceMesh 可以检测468个面部关键点，用于表情识别、眨眼检测等。\n\n### 2.2 安装\n\n```bash\npip install mediapipe\n```\n\n### 2.3 基本使用\n\n```python\nimport cv2\nimport mediapipe as mp\n\n# 初始化\nmp_face_mesh = mp.solutions.face_mesh\nface_mesh = mp_face_mesh.FaceMesh(\n    max_num_faces=1,\n    refine_landmarks=True,\n    min_detection_confidence=0.5,\n    min_tracking_confidence=0.5\n)\n\n# 绘制工具\nmp_drawing = mp.solutions.drawing_utils\nmp_drawing_styles = mp.solutions.drawing_styles\n\ncap = cv2.VideoCapture(0)\n\nwhile True:\n    ret, frame = cap.read()\n    if not ret:\n        break\n\n    # 转换颜色空间（重要！）\n    rgb_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)\n\n    # 检测人脸\n    results = face_mesh.process(rgb_frame)\n\n    if results.multi_face_landmarks:\n        for face_landmarks in results.multi_face_landmarks:\n            # 绘制关键点\n            mp_drawing.draw_landmarks(\n                frame,\n                face_landmarks,\n                mp_face_mesh.FACEMESH_TESSELATION,\n                landmark_drawing_spec=None,\n                connection_drawing_spec=mp_drawing_styles.get_default_face_mesh_tesselation_style()\n            )\n\n    cv2.imshow('FaceMesh', frame)\n    if cv2.waitKey(1) & 0xFF == ord('q'):\n        break\n\ncap.release()\ncv2.destroyAllWindows()\n```\n\n### 2.4 获取关键点坐标\n\n```python\nif results.multi_face_landmarks:\n    landmarks = results.multi_face_landmarks[0].landmark\n\n    # 获取特定关键点\n    h, w, c = frame.shape\n    point = landmarks[0]  # 第0个关键点\n    x = int(point.x * w)\n    y = int(point.y * h)\n    z = point.z  # 深度（相对值）\n```\n\n---"
    },
    {
      "title": "三、关键点索引",
      "content": "### 3.1 眼睛关键点\n\n```\n左眼：\n  - 上眼皮: 159\n  - 下眼皮: 145\n  - 左眼角: 33\n  - 右眼角: 133\n\n右眼：\n  - 上眼皮: 386\n  - 下眼皮: 374\n  - 左眼角: 362\n  - 右眼角: 263\n```\n\n### 3.2 嘴巴关键点\n\n```\n嘴巴：\n  - 上嘴唇中心: 13\n  - 下嘴唇中心: 14\n  - 左嘴角: 61\n  - 右嘴角: 291\n```\n\n### 3.3 其他关键点\n\n```\n鼻尖: 1\n下巴: 152\n左眉: 70\n右眉: 300\n```\n\n---"
    },
    {
      "title": "四、眨眼检测",
      "content": "### 4.1 原理\n\n通过计算上下眼皮的距离判断眼睛开合状态。\n\n### 4.2 跨课程出现\n\n| 课程编号 | 课程名称 | 具体内容 |\n|----------|---------|---------|\n| PYAI 2-3-1 | 眼控开关 | 眨眼检测基础 |\n| PYAI 2-3-2 | 眼控开关 | 状态机设计 |\n\n### 4.3 实现代码\n\n```python\ndef get_eye_aspect_ratio(landmarks, eye_indices):\n    \"\"\"计算眼睛纵横比（EAR）\"\"\"\n    # 垂直距离\n    v1 = abs(landmarks[eye_indices[1]].y - landmarks[eye_indices[5]].y)\n    v2 = abs(landmarks[eye_indices[2]].y - landmarks[eye_indices[4]].y)\n    # 水平距离\n    h = abs(landmarks[eye_indices[0]].x - landmarks[eye_indices[3]].x)\n    # EAR\n    ear = (v1 + v2) / (2.0 * h)\n    return ear\n\n# 左眼关键点索引\nLEFT_EYE = [33, 160, 158, 133, 153, 144]\n# 右眼关键点索引\nRIGHT_EYE = [362, 385, 387, 263, 373, 380]\n\n# 简化版：只用上下眼皮\ndef is_eye_closed(landmarks, threshold=0.02):\n    \"\"\"检测眼睛是否闭合\"\"\"\n    # 左眼\n    left_dist = abs(landmarks[159].y - landmarks[145].y)\n    # 右眼\n    right_dist = abs(landmarks[386].y - landmarks[374].y)\n    # 平均\n    avg_dist = (left_dist + right_dist) / 2\n    return avg_dist < threshold\n```\n\n### 4.4 眨眼计数\n\n```python\nclass BlinkCounter:\n    def __init__(self, threshold=0.02):\n        self.threshold = threshold\n        self.blink_count = 0\n        self.eye_closed = False\n\n    def update(self, landmarks):\n        \"\"\"更新眨眼状态\"\"\"\n        closed = is_eye_closed(landmarks, self.threshold)\n\n        if closed and not self.eye_closed:\n            # 眼睛刚闭上\n            self.eye_closed = True\n        elif not closed and self.eye_closed:\n            # 眼睛刚睁开 = 完成一次眨眼\n            self.eye_closed = False\n            self.blink_count += 1\n\n        return self.blink_count\n```\n\n---"
    },
    {
      "title": "五、表情识别",
      "content": "### 5.1 微笑检测\n\n```python\ndef detect_smile(landmarks, threshold=0.01):\n    \"\"\"检测微笑\"\"\"\n    # 嘴角位置\n    left_corner = landmarks[61]\n    right_corner = landmarks[291]\n    mouth_center = landmarks[13]\n\n    # 嘴角上扬程度\n    left_lift = mouth_center.y - left_corner.y\n    right_lift = mouth_center.y - right_corner.y\n\n    # 判断是否微笑\n    if left_lift > threshold and right_lift > threshold:\n        intensity = (left_lift + right_lift) / 2\n        return True, intensity\n    return False, 0\n```\n\n### 5.2 张嘴检测\n\n```python\ndef detect_mouth_open(landmarks, threshold=0.05):\n    \"\"\"检测张嘴\"\"\"\n    upper_lip = landmarks[13]\n    lower_lip = landmarks[14]\n\n    mouth_open = abs(upper_lip.y - lower_lip.y)\n    return mouth_open > threshold, mouth_open\n```\n\n### 5.3 跨课程出现\n\n| 课程编号 | 课程名称 | 具体内容 |\n|----------|---------|---------|\n| PYAI 2-3-5 | 表情音乐播放器 | 微笑/张嘴检测 |\n| PYAI 2-3-6 | 表情仪表盘 | 表情强度计算 |\n\n---"
    },
    {
      "title": "六、人脸比对",
      "content": "### 6.1 模板匹配方法\n\n```python\nimport cv2\n\ndef compare_faces(template_path, current_frame):\n    \"\"\"简单的人脸比对（模板匹配）\"\"\"\n    # 读取模板\n    template = cv2.imread(template_path, cv2.IMREAD_GRAYSCALE)\n    if template is None:\n        return False, 0\n\n    # 当前帧转灰度\n    gray = cv2.cvtColor(current_frame, cv2.COLOR_BGR2GRAY)\n\n    # 模板匹配\n    result = cv2.matchTemplate(gray, template, cv2.TM_CCOEFF_NORMED)\n\n    # 获取最大匹配值\n    min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)\n\n    # 判断是否匹配\n    threshold = 0.7\n    return max_val > threshold, max_val\n```\n\n### 6.2 跨课程出现\n\n| 课程编号 | 课程名称 | 具体内容 |\n|----------|---------|---------|\n| PYAI 1-4-7 | 智能门禁(2) | 人脸比对算法 |\n\n---"
    },
    {
      "title": "七、完整项目：刷脸开门",
      "content": "### 7.1 系统架构\n\n```\n摄像头 → 人脸检测 → 人脸比对 → 舵机控制\n                              ↓\n                         开门/拒绝\n```\n\n### 7.2 核心代码\n\n```python\nimport cv2\nimport mediapipe as mp\n# from servo import Servo  # 假设有舵机控制模块\n\nclass FaceDoorSystem:\n    def __init__(self, registered_face_path):\n        self.template = cv2.imread(registered_face_path, cv2.IMREAD_GRAYSCALE)\n        self.mp_face = mp.solutions.face_detection\n        self.face_detection = self.mp_face.FaceDetection(min_detection_confidence=0.5)\n        # self.servo = Servo(pin=9)\n\n    def detect_and_verify(self, frame):\n        \"\"\"检测并验证人脸\"\"\"\n        # 检测人脸\n        rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)\n        results = self.face_detection.process(rgb)\n\n        if not results.detections:\n            return False, \"未检测到人脸\"\n\n        # 提取人脸区域\n        detection = results.detections[0]\n        bbox = detection.location_data.relative_bounding_box\n        h, w, _ = frame.shape\n        x = int(bbox.xmin * w)\n        y = int(bbox.ymin * h)\n        face_w = int(bbox.width * w)\n        face_h = int(bbox.height * h)\n\n        face_roi = frame[y:y+face_h, x:x+face_w]\n        if face_roi.size == 0:\n            return False, \"人脸区域无效\"\n\n        # 比对\n        gray_face = cv2.cvtColor(face_roi, cv2.COLOR_BGR2GRAY)\n        gray_face = cv2.resize(gray_face, self.template.shape[::-1])\n\n        result = cv2.matchTemplate(gray_face, self.template, cv2.TM_CCOEFF_NORMED)\n        _, max_val, _, _ = cv2.minMaxLoc(result)\n\n        if max_val > 0.6:\n            # self.servo.write_angle(90)  # 开门\n            return True, f\"验证通过 ({max_val:.2f})\"\n        else:\n            return False, f\"验证失败 ({max_val:.2f})\"\n```\n\n### 7.3 跨课程出现\n\n| 课程编号 | 课程名称 | 具体内容 |\n|----------|---------|---------|\n| PYAI 1-4-8 | 智能门禁(3) | 完整系统集成 |\n\n---"
    },
    {
      "title": "八、常见错误与禁忌",
      "content": "| 错误 | 后果 | 正确做法 |\n|------|------|---------|\n| ❌ BGR直接传给MediaPipe | 检测失败 | 先转换为RGB |\n| ❌ 不检查检测结果 | 程序崩溃 | 检查`results.multi_face_landmarks` |\n| ❌ 阈值设置不当 | 误判 | 根据实际环境调整 |\n| ❌ 光照条件差 | 检测不稳定 | 确保充足均匀的光照 |\n\n---"
    },
    {
      "title": "九、教学建议",
      "content": "### 9.1 认知进阶路线\n\n```\nPYAI 1-4-6          PYAI 2-3-1          PYAI 2-3-5          PYAI 1-4-8\n人脸捕捉     →      关键点检测   →      表情识别     →      系统集成\n   ↓                   ↓                   ↓                   ↓\n 摄像头基础          FaceMesh            特征计算            AI+硬件\n```\n\n### 9.2 常见教学难点\n\n| 难点 | 解决方案 |\n|------|---------|\n| 关键点索引记忆 | 提供关键点图示，只记常用的 |\n| 阈值调整 | 让学生实验不同阈值，理解影响 |\n| 状态机设计 | 用流程图可视化状态转换 |\n\n---\n\n**维护者**：知识库管理员\n**关联文件**：[AI知识总表.md](AI知识总表.md)、[手势识别.md](手势识别.md)"
    }
  ],
  "full_content": "# 人脸识别\n\n> **用途**：人脸检测与识别技术在各课程中的应用详解\n> **更新日期**：2026-02-10\n> **数据来源**：萃取报告/PythonAI/\n\n---\n\n## 一、技术概述\n\n### 1.1 人脸识别流程\n\n```\n图像采集 → 人脸检测 → 特征提取 → 特征匹配 → 身份确认\n```\n\n### 1.2 跨课程出现\n\n| 课程编号 | 课程名称 | 具体内容 |\n|----------|---------|---------|\n| PYAI 1-4-6 | 智能门禁(1) | 人脸捕捉 |\n| PYAI 1-4-7 | 智能门禁(2) | 人脸比对 |\n| PYAI 1-4-8 | 智能门禁(3) | 刷脸开门 |\n| PYAI 2-3-1 | 眼控开关 | FaceMesh |\n\n---\n\n## 二、MediaPipe FaceMesh\n\n### 2.1 简介\n\nMediaPipe FaceMesh 可以检测468个面部关键点，用于表情识别、眨眼检测等。\n\n### 2.2 安装\n\n```bash\npip install mediapipe\n```\n\n### 2.3 基本使用\n\n```python\nimport cv2\nimport mediapipe as mp\n\n# 初始化\nmp_face_mesh = mp.solutions.face_mesh\nface_mesh = mp_face_mesh.FaceMesh(\n    max_num_faces=1,\n    refine_landmarks=True,\n    min_detection_confidence=0.5,\n    min_tracking_confidence=0.5\n)\n\n# 绘制工具\nmp_drawing = mp.solutions.drawing_utils\nmp_drawing_styles = mp.solutions.drawing_styles\n\ncap = cv2.VideoCapture(0)\n\nwhile True:\n    ret, frame = cap.read()\n    if not ret:\n        break\n\n    # 转换颜色空间（重要！）\n    rgb_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)\n\n    # 检测人脸\n    results = face_mesh.process(rgb_frame)\n\n    if results.multi_face_landmarks:\n        for face_landmarks in results.multi_face_landmarks:\n            # 绘制关键点\n            mp_drawing.draw_landmarks(\n                frame,\n                face_landmarks,\n                mp_face_mesh.FACEMESH_TESSELATION,\n                landmark_drawing_spec=None,\n                connection_drawing_spec=mp_drawing_styles.get_default_face_mesh_tesselation_style()\n            )\n\n    cv2.imshow('FaceMesh', frame)\n    if cv2.waitKey(1) & 0xFF == ord('q'):\n        break\n\ncap.release()\ncv2.destroyAllWindows()\n```\n\n### 2.4 获取关键点坐标\n\n```python\nif results.multi_face_landmarks:\n    landmarks = results.multi_face_landmarks[0].landmark\n\n    # 获取特定关键点\n    h, w, c = frame.shape\n    point = landmarks[0]  # 第0个关键点\n    x = int(point.x * w)\n    y = int(point.y * h)\n    z = point.z  # 深度（相对值）\n```\n\n---\n\n## 三、关键点索引\n\n### 3.1 眼睛关键点\n\n```\n左眼：\n  - 上眼皮: 159\n  - 下眼皮: 145\n  - 左眼角: 33\n  - 右眼角: 133\n\n右眼：\n  - 上眼皮: 386\n  - 下眼皮: 374\n  - 左眼角: 362\n  - 右眼角: 263\n```\n\n### 3.2 嘴巴关键点\n\n```\n嘴巴：\n  - 上嘴唇中心: 13\n  - 下嘴唇中心: 14\n  - 左嘴角: 61\n  - 右嘴角: 291\n```\n\n### 3.3 其他关键点\n\n```\n鼻尖: 1\n下巴: 152\n左眉: 70\n右眉: 300\n```\n\n---\n\n## 四、眨眼检测\n\n### 4.1 原理\n\n通过计算上下眼皮的距离判断眼睛开合状态。\n\n### 4.2 跨课程出现\n\n| 课程编号 | 课程名称 | 具体内容 |\n|----------|---------|---------|\n| PYAI 2-3-1 | 眼控开关 | 眨眼检测基础 |\n| PYAI 2-3-2 | 眼控开关 | 状态机设计 |\n\n### 4.3 实现代码\n\n```python\ndef get_eye_aspect_ratio(landmarks, eye_indices):\n    \"\"\"计算眼睛纵横比（EAR）\"\"\"\n    # 垂直距离\n    v1 = abs(landmarks[eye_indices[1]].y - landmarks[eye_indices[5]].y)\n    v2 = abs(landmarks[eye_indices[2]].y - landmarks[eye_indices[4]].y)\n    # 水平距离\n    h = abs(landmarks[eye_indices[0]].x - landmarks[eye_indices[3]].x)\n    # EAR\n    ear = (v1 + v2) / (2.0 * h)\n    return ear\n\n# 左眼关键点索引\nLEFT_EYE = [33, 160, 158, 133, 153, 144]\n# 右眼关键点索引\nRIGHT_EYE = [362, 385, 387, 263, 373, 380]\n\n# 简化版：只用上下眼皮\ndef is_eye_closed(landmarks, threshold=0.02):\n    \"\"\"检测眼睛是否闭合\"\"\"\n    # 左眼\n    left_dist = abs(landmarks[159].y - landmarks[145].y)\n    # 右眼\n    right_dist = abs(landmarks[386].y - landmarks[374].y)\n    # 平均\n    avg_dist = (left_dist + right_dist) / 2\n    return avg_dist < threshold\n```\n\n### 4.4 眨眼计数\n\n```python\nclass BlinkCounter:\n    def __init__(self, threshold=0.02):\n        self.threshold = threshold\n        self.blink_count = 0\n        self.eye_closed = False\n\n    def update(self, landmarks):\n        \"\"\"更新眨眼状态\"\"\"\n        closed = is_eye_closed(landmarks, self.threshold)\n\n        if closed and not self.eye_closed:\n            # 眼睛刚闭上\n            self.eye_closed = True\n        elif not closed and self.eye_closed:\n            # 眼睛刚睁开 = 完成一次眨眼\n            self.eye_closed = False\n            self.blink_count += 1\n\n        return self.blink_count\n```\n\n---\n\n## 五、表情识别\n\n### 5.1 微笑检测\n\n```python\ndef detect_smile(landmarks, threshold=0.01):\n    \"\"\"检测微笑\"\"\"\n    # 嘴角位置\n    left_corner = landmarks[61]\n    right_corner = landmarks[291]\n    mouth_center = landmarks[13]\n\n    # 嘴角上扬程度\n    left_lift = mouth_center.y - left_corner.y\n    right_lift = mouth_center.y - right_corner.y\n\n    # 判断是否微笑\n    if left_lift > threshold and right_lift > threshold:\n        intensity = (left_lift + right_lift) / 2\n        return True, intensity\n    return False, 0\n```\n\n### 5.2 张嘴检测\n\n```python\ndef detect_mouth_open(landmarks, threshold=0.05):\n    \"\"\"检测张嘴\"\"\"\n    upper_lip = landmarks[13]\n    lower_lip = landmarks[14]\n\n    mouth_open = abs(upper_lip.y - lower_lip.y)\n    return mouth_open > threshold, mouth_open\n```\n\n### 5.3 跨课程出现\n\n| 课程编号 | 课程名称 | 具体内容 |\n|----------|---------|---------|\n| PYAI 2-3-5 | 表情音乐播放器 | 微笑/张嘴检测 |\n| PYAI 2-3-6 | 表情仪表盘 | 表情强度计算 |\n\n---\n\n## 六、人脸比对\n\n### 6.1 模板匹配方法\n\n```python\nimport cv2\n\ndef compare_faces(template_path, current_frame):\n    \"\"\"简单的人脸比对（模板匹配）\"\"\"\n    # 读取模板\n    template = cv2.imread(template_path, cv2.IMREAD_GRAYSCALE)\n    if template is None:\n        return False, 0\n\n    # 当前帧转灰度\n    gray = cv2.cvtColor(current_frame, cv2.COLOR_BGR2GRAY)\n\n    # 模板匹配\n    result = cv2.matchTemplate(gray, template, cv2.TM_CCOEFF_NORMED)\n\n    # 获取最大匹配值\n    min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)\n\n    # 判断是否匹配\n    threshold = 0.7\n    return max_val > threshold, max_val\n```\n\n### 6.2 跨课程出现\n\n| 课程编号 | 课程名称 | 具体内容 |\n|----------|---------|---------|\n| PYAI 1-4-7 | 智能门禁(2) | 人脸比对算法 |\n\n---\n\n## 七、完整项目：刷脸开门\n\n### 7.1 系统架构\n\n```\n摄像头 → 人脸检测 → 人脸比对 → 舵机控制\n                              ↓\n                         开门/拒绝\n```\n\n### 7.2 核心代码\n\n```python\nimport cv2\nimport mediapipe as mp\n# from servo import Servo  # 假设有舵机控制模块\n\nclass FaceDoorSystem:\n    def __init__(self, registered_face_path):\n        self.template = cv2.imread(registered_face_path, cv2.IMREAD_GRAYSCALE)\n        self.mp_face = mp.solutions.face_detection\n        self.face_detection = self.mp_face.FaceDetection(min_detection_confidence=0.5)\n        # self.servo = Servo(pin=9)\n\n    def detect_and_verify(self, frame):\n        \"\"\"检测并验证人脸\"\"\"\n        # 检测人脸\n        rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)\n        results = self.face_detection.process(rgb)\n\n        if not results.detections:\n            return False, \"未检测到人脸\"\n\n        # 提取人脸区域\n        detection = results.detections[0]\n        bbox = detection.location_data.relative_bounding_box\n        h, w, _ = frame.shape\n        x = int(bbox.xmin * w)\n        y = int(bbox.ymin * h)\n        face_w = int(bbox.width * w)\n        face_h = int(bbox.height * h)\n\n        face_roi = frame[y:y+face_h, x:x+face_w]\n        if face_roi.size == 0:\n            return False, \"人脸区域无效\"\n\n        # 比对\n        gray_face = cv2.cvtColor(face_roi, cv2.COLOR_BGR2GRAY)\n        gray_face = cv2.resize(gray_face, self.template.shape[::-1])\n\n        result = cv2.matchTemplate(gray_face, self.template, cv2.TM_CCOEFF_NORMED)\n        _, max_val, _, _ = cv2.minMaxLoc(result)\n\n        if max_val > 0.6:\n            # self.servo.write_angle(90)  # 开门\n            return True, f\"验证通过 ({max_val:.2f})\"\n        else:\n            return False, f\"验证失败 ({max_val:.2f})\"\n```\n\n### 7.3 跨课程出现\n\n| 课程编号 | 课程名称 | 具体内容 |\n|----------|---------|---------|\n| PYAI 1-4-8 | 智能门禁(3) | 完整系统集成 |\n\n---\n\n## 八、常见错误与禁忌\n\n| 错误 | 后果 | 正确做法 |\n|------|------|---------|\n| ❌ BGR直接传给MediaPipe | 检测失败 | 先转换为RGB |\n| ❌ 不检查检测结果 | 程序崩溃 | 检查`results.multi_face_landmarks` |\n| ❌ 阈值设置不当 | 误判 | 根据实际环境调整 |\n| ❌ 光照条件差 | 检测不稳定 | 确保充足均匀的光照 |\n\n---\n\n## 九、教学建议\n\n### 9.1 认知进阶路线\n\n```\nPYAI 1-4-6          PYAI 2-3-1          PYAI 2-3-5          PYAI 1-4-8\n人脸捕捉     →      关键点检测   →      表情识别     →      系统集成\n   ↓                   ↓                   ↓                   ↓\n 摄像头基础          FaceMesh            特征计算            AI+硬件\n```\n\n### 9.2 常见教学难点\n\n| 难点 | 解决方案 |\n|------|---------|\n| 关键点索引记忆 | 提供关键点图示，只记常用的 |\n| 阈值调整 | 让学生实验不同阈值，理解影响 |\n| 状态机设计 | 用流程图可视化状态转换 |\n\n---\n\n**维护者**：知识库管理员\n**关联文件**：[AI知识总表.md](AI知识总表.md)、[手势识别.md](手势识别.md)\n"
}