{
  "title": "PythonAI萃取：L2-2 项目应用",
  "source": "C:\\Users\\Frank.J\\starplanet_ai_academy\\知识库\\萃取报告\\PythonAI\\L2_02_项目应用.md",
  "sections": [
    {
      "title": "单元概览",
      "content": "| 项目 | 内容 |\n|------|------|\n| **单元编号** | PYAI 2-2 |\n| **单元名称** | 项目应用 |\n| **适用年龄** | 四年级及以上（10-12岁） |\n| **课时数** | 12节 × 90分钟 |\n| **核心目标** | 掌握Pygame游戏开发与物理仿真，实现面向对象编程的综合应用 |\n| **主要平台** | Python IDLE + Pygame |\n\n**底层逻辑**\n从面向过程转向面向对象编程，通过游戏开发项目理解类与实例、碰撞检测、物理仿真等核心概念。\n\n**单元教��策略**\n- 面向对象（01）：类和对象基础\n- Pygame入门（02-03）：文字绘制、弹幕生成\n- 图形绘制（04-06）：pygame.draw、蒙特卡洛、星空特效\n- 游戏开发（07-08）：球球大作战、贪食蛇\n- 物理仿真（09-11）：大炮射击系列、Pymunk引擎\n- 阶段复习（12）：知识整合\n\n`#执行层` `#测评项`\n[UID: PYAI-22-001]\n[关联: PYAI-21-001 PythonAI算法数据科学（前置基础）]\n[关联: PYAI-11-001 PythonAI函数封装（前置基础）]\n[关联: PYAI-23-001 PythonAI交互式AI（进阶衔接）]\n\n---"
    },
    {
      "title": "课程列表",
      "content": "| 课次 | 课程名称 | 核心知识点 | 项目内容 | 认知负荷 |\n|------|----------|------------|----------|----------|\n| 2-2-1 | 脚踏实地 | class定义、实例创建、self、__init__ | 类和对象 | 高 |\n| 2-2-2 | 电子成绩单 | IDLE环境、Pygame初识、文字绘制 | 电子成绩单 | 中-高 |\n| 2-2-3 | 弹幕生成器 | Pygame综合、Random/Time模块、类实例应用 | 弹幕生成器 | 高 |\n| 2-2-4 | 规矩方圆 | pygame.draw.line()、二维列表、RGB色彩 | 规矩方圆 | 中-高 |\n| 2-2-5 | 蒙特卡洛法 | pygame.draw.circle()、距离公式、蒙特卡洛算法 | 求圆周率 | 高 |\n| 2-2-6 | 弱肉强食 | 随机模块、类属性控制、for循环高级用法 | 星空特效 | 中-高 |\n| 2-2-7 | 积小致巨1 | 按键交互、碰撞检测、列表动态操作 | 球球大作战 | 高 |\n| 2-2-8 | 积小致巨2 | 多角色联动、列表数据存取、贪食蛇逻辑 | 贪食蛇 | 高 |\n| 2-2-9 | 举重若轻1 | 图像导入变换、能量值变化、游戏环节控制 | 大炮射击1 | 高 |\n| 2-2-10 | 举重若轻2 | 物理运动原理、加速度、速度合并 | 大炮射击2 | 高 |\n| 2-2-11 | 举重若轻3 | 向量拆分合并、爆炸效果、音频加载 | 大炮射击3 | 高 |\n| 2-2-12 | 阶段复习 | 综合复习Pygame与OOP | 阶段测试 | 中 |\n\n---"
    },
    {
      "title": "通用教学流程（90分钟）",
      "content": "| 环节 | 时间 | 内容 | 认知负荷 | IFC标签 |\n|------|------|------|----------|---------|\n| 课堂问候 | 2分钟 | 自我介绍、学习目标 | `#低负荷-热身` | `#IFC-预防` |\n| 课程回顾 | 5分钟 | 复习上节课代码知识 | `#低负荷-热身` | `#IFC-预防` |\n| 知识讲解 | 20分钟 | 新概念/语法讲解 | `#中负荷-操练` | `#IFC-即时` |\n| 代码实践 | 40分钟 | 编写游戏代码、调试 | `#高负荷-产出` | `#IFC-即时` |\n| 调节休息 | 3分钟 | 站起来活动 | `#调节-放松` | - |\n| 项目拓展 | 10分钟 | 功能扩展/创意改进 | `#高负荷-产出` | `#IFC-即时` |\n| 成果展示 | 10分钟 | 演示游戏、分享思路 | `#低负荷-热身` | `#IFC-复盘` |\n\n`#执行层` `#测评项`\n[UID: PYAI-22-FLOW-001]\n\n---"
    },
    {
      "title": "详细课程萃取",
      "content": "### 2-2-1 脚踏实地（典型案例）\n\n#### 课程基本信息\n\n| 项目 | 内容 |\n|------|------|\n| **课程编号** | 2-2-1 |\n| **课程名称** | 脚踏实地 |\n| **认知负荷** | 高 |\n| **核心技能** | class定义、实例创建、self、__init__ |\n\n#### 详细教学流程\n\n**步骤1：知识讲解（20分钟）** `#中负荷-操练` `#IFC-即时`\n\n**教师话术**\n> \"今天我们学习一个超级重要的概念——**面向对象编程(OOP)**！之前我们写的代码是'面向过程'的，一步一步执行。现在要学习把数据和动作'打包'在一起。\"\n>\n> \"**类(Class)和实例(Instance)**：\n> - 类是**模板/蓝图**，定义了一类事物的共同特征\n> - 实例是根据类创建的**具体对象**\n>\n> 比喻：类就像'做饼干的模具'，实例就是用模具压出来的'饼干'。\"\n>\n> \"**定义类的语法**：\n> ```python\n> class Dog:\n>     # 属性（特征）\n>     name = '小白'\n>     color = '白色'\n>\n>     # 方法（行为）\n>     def bark(self):\n>         print('汪汪！')\n>\n> # 创建实例\n> dog1 = Dog()\n> dog1.name = '旺财'\n> dog1.bark()  # 输出：汪汪！\n> ```\"\n\n**核心代码模式**\n\n```python\n# 1. 定义类\nclass Student:\n    # 初始化方法，创建对象时自动调用\n    def __init__(self, name, score):\n        self.name = name   # 实例属性\n        self.score = score\n\n    # 实例方法\n    def introduce(self):\n        print(f'我是{self.name}，考了{self.score}分')\n\n# 2. 创建实例\ns1 = Student('小明', 98)\ns2 = Student('小红', 100)\n\n# 3. 调用方法\ns1.introduce()  # 输出：我是小明，考了98分\n```\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 不理解类和实例 | 用模具类比 | \"类是模具，实例是用模具做出来的饼干\" |\n| 忘记写self | 强调规则 | \"方法的第一个参数必须是self，代表'我自己'\" |\n| __init__写错 | 强调双下划线 | \"左右各两个下划线，不是单下划线\" |\n| 混淆类属性和实例属性 | 演示区别 | 修改dog1.name不影响dog2.name |\n\n**禁忌提醒**\n❌ 方法定义忘记self——TypeError错误\n❌ __init__写成_init_——不会自动调用\n❌ 类名用小写——应该用大驼峰命名法\n\n---\n\n**核心知识点**\n- 类(Class)：抽象的模板/蓝图\n- 实例(Instance)：具体的对象\n- self：代表实例本身\n- __init__：初始化方法，创建实例时自动调用\n\n**底层逻辑**\n- **封装思想**：把数据和操作数据的方法打包在一起\n- **代码复用**：一个类可以创建多个实例\n\n`#执行层` `#测评项`\n[UID: PYAI-22-01-001]\n[关联: PYAI-11-01-001 函数定义（前置基础）]\n\n---\n\n### 2-2-2 电子成绩单\n\n#### 课程基本信息\n\n| 项目 | 内容 |\n|------|------|\n| **课程编号** | 2-2-2 |\n| **课程名称** | 电子成绩单 |\n| **认知负荷** | 中-高 |\n| **核心技能** | IDLE环境、Pygame初识、文字绘制 |\n\n#### 详细教学流程\n\n**步骤1：知识讲解（20分钟）** `#中负荷-操练` `#IFC-即时`\n\n**教师话术**\n> \"今天我们开始学习**Pygame**——Python最流行的游戏开发库！先从最简单的开始：在窗口上显示文字。\"\n>\n> \"**Pygame基础结构**：\n> ```python\n> import pygame\n>\n> # 1. 初始化\n> pygame.init()\n>\n> # 2. 创建窗口\n> screen = pygame.display.set_mode((800, 600))\n> pygame.display.set_caption('我的第一个Pygame程序')\n>\n> # 3. 游戏主循环\n> running = True\n> while running:\n>     for event in pygame.event.get():\n>         if event.type == pygame.QUIT:\n>             running = False\n>\n>     # 填充背景色\n>     screen.fill((255, 255, 255))\n>\n>     # 更新显示\n>     pygame.display.flip()\n>\n> pygame.quit()\n> ```\"\n\n**核心代码模式**\n\n```python\nimport pygame\n\npygame.init()\nscreen = pygame.display.set_mode((800, 600))\n\n# 创建字体对象\nfont = pygame.font.Font(None, 48)  # None使用默认字体，48是字号\n\n# 渲染文字（文字内容, 抗锯齿, 颜色）\ntext = font.render('Hello Pygame!', True, (0, 0, 0))\n\nrunning = True\nwhile running:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            running = False\n\n    screen.fill((255, 255, 255))\n\n    # 绘制文字到屏幕\n    screen.blit(text, (100, 100))  # (x, y)坐标\n\n    pygame.display.flip()\n\npygame.quit()\n```\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 窗口闪退 | 检查主循环 | 确保while循环正确运行 |\n| 中文显示乱码 | 使用中文字体 | pygame.font.Font('simhei.ttf', 48) |\n| 想改变颜色 | 解释RGB | (255,0,0)红色，(0,255,0)绿色 |\n\n---\n\n**核心知识点**\n- Pygame初始化：`pygame.init()`\n- 创建窗口：`pygame.display.set_mode((宽, 高))`\n- 游戏主循环：while循环 + 事件处理\n- 文字渲染：`font.render()` + `screen.blit()`\n\n`#执行层` `#测评项`\n[UID: PYAI-22-02-001]\n\n---\n\n### 2-2-3 弹幕生成器\n\n#### 课程基本信息\n\n| 项目 | 内容 |\n|------|------|\n| **课程编号** | 2-2-3 |\n| **课程名称** | 弹幕生成器 |\n| **认知负荷** | 高 |\n| **核心技能** | Pygame综合、Random/Time模块、类实例应用 |\n\n#### 详细教学流程\n\n**步骤1：知识讲解（20分钟）** `#中负荷-操练` `#IFC-即时`\n\n**教师话术**\n> \"今天我们做一个**弹幕生成器**！就像B站视频上飘过的弹幕一样。这个项目会用到上节课学的类和Pygame。\"\n>\n> \"**弹幕的本质**：\n> - 每条弹幕是一个**对象**（有位置、速度、内容）\n> - 弹幕从右边出现，向左移动\n> - 用**列表**管理多条弹幕\"\n\n**核心代码模式**\n\n```python\nimport pygame\nimport random\n\n# 弹幕类\nclass Danmaku:\n    def __init__(self, text, y):\n        self.text = text\n        self.x = 800  # 从右边开始\n        self.y = y\n        self.speed = random.randint(3, 8)\n        self.color = (random.randint(0,255), random.randint(0,255), random.randint(0,255))\n\n    def move(self):\n        self.x -= self.speed  # 向左移动\n\n    def draw(self, screen, font):\n        text_surface = font.render(self.text, True, self.color)\n        screen.blit(text_surface, (self.x, self.y))\n\n# 主程序\npygame.init()\nscreen = pygame.display.set_mode((800, 600))\nfont = pygame.font.Font(None, 36)\n\ndanmaku_list = []\nmessages = ['Hello!', 'Pygame真好玩', '666', '前方高能']\n\nrunning = True\nframe_count = 0\nwhile running:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            running = False\n\n    # 每60帧生成一条弹幕\n    frame_count += 1\n    if frame_count % 60 == 0:\n        text = random.choice(messages)\n        y = random.randint(50, 550)\n        danmaku_list.append(Danmaku(text, y))\n\n    screen.fill((0, 0, 0))\n\n    # 更新和绘制所有弹幕\n    for d in danmaku_list:\n        d.move()\n        d.draw(screen, font)\n\n    # 移除已经飘出屏幕的弹幕\n    danmaku_list = [d for d in danmaku_list if d.x > -200]\n\n    pygame.display.flip()\n    pygame.time.delay(16)  # 约60FPS\n\npygame.quit()\n```\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 弹幕太快/太慢 | 调整speed范围 | 修改random.randint的参数 |\n| 想添加自定义弹幕 | 加入input | 用pygame.KEYDOWN捕获输入 |\n| 弹幕重叠 | 优化y坐标 | 检测已有弹幕位置避免重叠 |\n\n---\n\n**核心知识点**\n- 类的综合应用：封装弹幕的属性和行为\n- 列表管理对象：存储多个弹幕实例\n- 列表推导式：过滤已消失的弹幕\n- 帧率控制：`pygame.time.delay()`\n\n`#执行层` `#测评项`\n[UID: PYAI-22-03-001]\n\n---\n\n### 2-2-4 规矩方圆\n\n#### 课程基本信息\n\n| 项目 | 内容 |\n|------|------|\n| **课程编号** | 2-2-4 |\n| **课程名称** | 规矩方圆 |\n| **认知负荷** | 中-高 |\n| **核心技能** | pygame.draw.line()、二维列表、RGB色彩 |\n\n#### 详细教学流程\n\n**步骤1：知识讲解（20分钟）** `#中负荷-操练` `#IFC-即时`\n\n**教师话术**\n> \"今天学习Pygame的**绑图函数**！用代码画出各种图形。\"\n>\n> \"**pygame.draw模块**：\n> ```python\n> # 画线\n> pygame.draw.line(screen, color, start_pos, end_pos, width)\n>\n> # 画矩形\n> pygame.draw.rect(screen, color, (x, y, width, height), width)\n>\n> # 画圆\n> pygame.draw.circle(screen, color, center, radius, width)\n> ```\n>\n> **RGB色彩**：\n> - (255, 0, 0) = 红色\n> - (0, 255, 0) = 绿色\n> - (0, 0, 255) = 蓝色\n> - (255, 255, 255) = 白色\n> - (0, 0, 0) = 黑色\"\n\n**核心代码模式**\n\n```python\nimport pygame\n\npygame.init()\nscreen = pygame.display.set_mode((800, 600))\n\nrunning = True\nwhile running:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            running = False\n\n    screen.fill((255, 255, 255))\n\n    # 画线（红色，从(100,100)到(300,300)，宽度3）\n    pygame.draw.line(screen, (255, 0, 0), (100, 100), (300, 300), 3)\n\n    # 画矩形（蓝色，位置(400,100)，大小200x150，边框宽度2）\n    pygame.draw.rect(screen, (0, 0, 255), (400, 100, 200, 150), 2)\n\n    # 画填充矩形（宽度为0表示填充）\n    pygame.draw.rect(screen, (0, 255, 0), (400, 300, 200, 150), 0)\n\n    # 画圆（黄色，圆心(200,400)，半径50，填充）\n    pygame.draw.circle(screen, (255, 255, 0), (200, 400), 50, 0)\n\n    pygame.display.flip()\n\npygame.quit()\n```\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 分不清填充和边框 | 演示width参数 | width=0填充，width>0画边框 |\n| 想画更多图形 | 介绍其他函数 | polygon多边形、ellipse椭圆 |\n| 颜色不对 | 检查RGB顺序 | 是(R,G,B)不是(B,G,R) |\n\n---\n\n**核心知识点**\n- pygame.draw.line()：画线\n- pygame.draw.rect()：画矩形\n- pygame.draw.circle()：画圆\n- RGB色彩模型：三原色混合\n\n`#执行层` `#测评项`\n[UID: PYAI-22-04-001]\n\n---\n\n### 2-2-5 蒙特卡洛法\n\n#### 课程基本信息\n\n| 项目 | 内容 |\n|------|------|\n| **课程编号** | 2-2-5 |\n| **课程名称** | 蒙特卡洛法 |\n| **认知负荷** | 高 |\n| **核心技能** | pygame.draw.circle()、距离公式、蒙特卡洛算法 |\n\n#### 详细教学流程\n\n**步骤1：知识讲解（20分钟）** `#中负荷-操练` `#IFC-即时`\n\n**教师话术**\n> \"今天我们用**随机数**来计算**圆周率π**！这种方法叫**蒙特卡洛法**。\"\n>\n> \"**原理**：\n> 1. 画一个正方形，边长为2r\n> 2. 在正方形内画一个内切圆，半径为r\n> 3. 随机撒点，统计落在圆内的点数\n> 4. 圆内点数/总点数 ≈ 圆面积/正方形面积 = πr²/(2r)² = π/4\n> 5. 所以 π ≈ 4 × (圆内点数/总点数)\"\n>\n> \"**判断点是否在圆内**：\n> - 计算点到圆心的距离\n> - 距离公式：d = √((x-cx)² + (y-cy)²)\n> - 如果 d ≤ r，点在圆内\"\n\n**核心代码模式**\n\n```python\nimport pygame\nimport random\nimport math\n\npygame.init()\nscreen = pygame.display.set_mode((600, 600))\nfont = pygame.font.Font(None, 36)\n\n# 圆心和半径\ncx, cy = 300, 300\nradius = 250\n\ninside_count = 0\ntotal_count = 0\n\nrunning = True\nwhile running:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            running = False\n\n    # 每帧撒10个点\n    for _ in range(10):\n        x = random.randint(cx - radius, cx + radius)\n        y = random.randint(cy - radius, cy + radius)\n\n        # 计算到圆心的距离\n        distance = math.sqrt((x - cx)**2 + (y - cy)**2)\n\n        total_count += 1\n        if distance <= radius:\n            inside_count += 1\n            color = (255, 0, 0)  # 圆内红色\n        else:\n            color = (0, 0, 255)  # 圆外蓝色\n\n        pygame.draw.circle(screen, color, (x, y), 2)\n\n    # 计算π的估计值\n    if total_count > 0:\n        pi_estimate = 4 * inside_count / total_count\n        text = font.render(f'Pi = {pi_estimate:.6f}', True, (0, 0, 0))\n        pygame.draw.rect(screen, (255, 255, 255), (10, 10, 200, 40))\n        screen.blit(text, (20, 20))\n\n    pygame.display.flip()\n    pygame.time.delay(10)\n\npygame.quit()\n```\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 不理解蒙特卡洛 | 用投飞镖类比 | \"随机投飞镖，统计落在靶心的比例\" |\n| π值不准确 | 增加点数 | 点越多越接近真实值 |\n| 想加速计算 | 减少绘制 | 不是每个点都画出来 |\n\n---\n\n**核心知识点**\n- 蒙特卡洛算法：用随机数模拟概率\n- 距离公式：d = √((x₁-x₂)² + (y₁-y₂)²)\n- 概率与面积的关系\n\n**底层逻辑**\n- **随机模拟**：用大量随机样本逼近真实结果\n- **数学应用**：几何概率在编程中的应用\n\n`#执行层` `#测评项`\n[UID: PYAI-22-05-001]\n\n---\n\n### 2-2-6 弱肉强食\n\n#### 课程基本信息\n\n| 项目 | 内容 |\n|------|------|\n| **课程编号** | 2-2-6 |\n| **课程名称** | 弱肉强食 |\n| **认知负荷** | 中-高 |\n| **核心技能** | 随机模块、类属性控制、for循环高级用法 |\n\n#### 详细教学流程\n\n**步骤1：知识讲解（20分钟）** `#中负荷-操练` `#IFC-即时`\n\n**教师话术**\n> \"今天我们做一个**星空特效**！屏幕上有很多星星，它们会移动、闪烁。\"\n>\n> \"**设计思路**：\n> 1. 每颗星星是一个对象（有位置、大小、速度、亮度）\n> 2. 用列表管理所有星星\n> 3. 每帧更新星星的位置和亮度\"\n\n**核心代码模式**\n\n```python\nimport pygame\nimport random\n\nclass Star:\n    def __init__(self):\n        self.x = random.randint(0, 800)\n        self.y = random.randint(0, 600)\n        self.size = random.randint(1, 3)\n        self.speed = random.uniform(0.5, 2.0)\n        self.brightness = random.randint(100, 255)\n        self.twinkle_speed = random.uniform(1, 5)\n\n    def update(self):\n        # 移动\n        self.y += self.speed\n        if self.y > 600:\n            self.y = 0\n            self.x = random.randint(0, 800)\n\n        # 闪烁\n        self.brightness += self.twinkle_speed\n        if self.brightness > 255 or self.brightness < 100:\n            self.twinkle_speed = -self.twinkle_speed\n\n    def draw(self, screen):\n        b = int(self.brightness)\n        color = (b, b, b)\n        pygame.draw.circle(screen, color, (int(self.x), int(self.y)), self.size)\n\npygame.init()\nscreen = pygame.display.set_mode((800, 600))\n\n# 创建100颗星星\nstars = [Star() for _ in range(100)]\n\nrunning = True\nwhile running:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            running = False\n\n    screen.fill((0, 0, 30))  # 深蓝色背景\n\n    for star in stars:\n        star.update()\n        star.draw(screen)\n\n    pygame.display.flip()\n    pygame.time.delay(16)\n\npygame.quit()\n```\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 星星太少 | 增加数量 | 把100改成200或更多 |\n| 想要彩色星星 | 修改颜色 | 随机生成RGB颜色 |\n| 想加流星 | 新建流星类 | 速度更快、有尾迹 |\n\n---\n\n**核心知识点**\n- 类属性的动态变化\n- 列表推导式创建对象\n- 边界检测和重置\n\n`#执行层` `#测评项`\n[UID: PYAI-22-06-001]\n\n---\n\n### 2-2-7 积小致巨1\n\n#### 课程基本信息\n\n| 项目 | 内容 |\n|------|------|\n| **课程编号** | 2-2-7 |\n| **课程名称** | 积小致巨1 |\n| **认知负荷** | 高 |\n| **核心技能** | 按键交互、碰撞检测、列表动态操作 |\n\n#### 详细教学流程\n\n**步骤1：知识讲解（20分钟）** `#中负荷-操练` `#IFC-即时`\n\n**教师话术**\n> \"今天我们做一个**球球大作战**游戏！玩家控制一个球，吃掉小球变大，碰到大球就游戏结束。\"\n>\n> \"**按键交互**：用键盘控制角色移动\n> ```python\n> keys = pygame.key.get_pressed()\n> if keys[pygame.K_LEFT]:\n>     player_x -= speed\n> if keys[pygame.K_RIGHT]:\n>     player_x += speed\n> if keys[pygame.K_UP]:\n>     player_y -= speed\n> if keys[pygame.K_DOWN]:\n>     player_y += speed\n> ```\n>\n> **碰撞检测**：判断两个圆是否相交\n> ```python\n> def check_collision(x1, y1, r1, x2, y2, r2):\n>     distance = math.sqrt((x1-x2)**2 + (y1-y2)**2)\n>     return distance < r1 + r2  # 距离小于半径之和就碰撞\n> ```\"\n\n**核心代码模式**\n\n```python\nimport pygame\nimport random\nimport math\n\npygame.init()\nscreen = pygame.display.set_mode((800, 600))\n\n# 玩家\nplayer_x, player_y = 400, 300\nplayer_radius = 20\nspeed = 5\n\n# 食物球列表\nfoods = []\nfor _ in range(20):\n    foods.append({\n        'x': random.randint(50, 750),\n        'y': random.randint(50, 550),\n        'radius': random.randint(5, 15),\n        'color': (random.randint(50,255), random.randint(50,255), random.randint(50,255))\n    })\n\ndef check_collision(x1, y1, r1, x2, y2, r2):\n    distance = math.sqrt((x1-x2)**2 + (y1-y2)**2)\n    return distance < r1 + r2\n\nrunning = True\nwhile running:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            running = False\n\n    # 按键控制\n    keys = pygame.key.get_pressed()\n    if keys[pygame.K_LEFT]: player_x -= speed\n    if keys[pygame.K_RIGHT]: player_x += speed\n    if keys[pygame.K_UP]: player_y -= speed\n    if keys[pygame.K_DOWN]: player_y += speed\n\n    # 边界限制\n    player_x = max(player_radius, min(800-player_radius, player_x))\n    player_y = max(player_radius, min(600-player_radius, player_y))\n\n    # 碰撞检测\n    for food in foods[:]:  # 用切片复制列表，避免遍历时修改\n        if check_collision(player_x, player_y, player_radius,\n                          food['x'], food['y'], food['radius']):\n            if player_radius > food['radius']:\n                # 吃掉小球，变大\n                player_radius += food['radius'] // 3\n                foods.remove(food)\n\n    screen.fill((30, 30, 30))\n\n    # 绘制食物\n    for food in foods:\n        pygame.draw.circle(screen, food['color'], (food['x'], food['y']), food['radius'])\n\n    # 绘制玩家\n    pygame.draw.circle(screen, (0, 255, 0), (int(player_x), int(player_y)), player_radius)\n\n    pygame.display.flip()\n    pygame.time.delay(16)\n\npygame.quit()\n```\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 移动太快/太慢 | 调整speed | 根据手感调整移动速度 |\n| 想加敌人 | 添加AI球 | 敌人球会追踪玩家 |\n| 碰撞不准 | 检查半径 | 确保碰撞检测使用正确的半径 |\n\n**禁忌提醒**\n❌ 遍历列表时直接删除元素——会跳过元素，用切片复制\n❌ 忘记边界限制——球会跑出屏幕\n\n---\n\n**核心知识点**\n- 按键交互：`pygame.key.get_pressed()`\n- 碰撞检测：圆形碰撞（距离 < 半径之和）\n- 列表动态操作：遍历时安全删除元素\n\n`#执行层` `#测评项`\n[UID: PYAI-22-07-001]\n\n---\n\n### 2-2-8 积小致巨2\n\n#### 课程基本信息\n\n| 项目 | 内容 |\n|------|------|\n| **课程编号** | 2-2-8 |\n| **课程名称** | 积小致巨2 |\n| **认知负荷** | 高 |\n| **核心技能** | 多角色联动、列表数据存取、贪食蛇逻辑 |\n\n#### 详细教学流程\n\n**步骤1：知识讲解（20分钟）** `#中负荷-操练` `#IFC-即时`\n\n**教师话术**\n> \"今天做经典游戏**贪食蛇**！蛇的身体是一串方块，吃到食物就变长。\"\n>\n> \"**贪食蛇的核心逻辑**：\n> 1. 蛇身用**列表**存储每个方块的坐标\n> 2. 移动时：头部添加新位置，尾部删除\n> 3. 吃到食物：头部添加，尾部不删除（变长）\n>\n> ```python\n> snake = [(100, 100), (80, 100), (60, 100)]  # 头在前\n> direction = (20, 0)  # 向右移动\n>\n> # 移动\n> new_head = (snake[0][0] + direction[0], snake[0][1] + direction[1])\n> snake.insert(0, new_head)  # 头部添加\n> snake.pop()  # 尾部删除\n> ```\"\n\n**核心代码模式**\n\n```python\nimport pygame\nimport random\n\npygame.init()\nscreen = pygame.display.set_mode((800, 600))\n\nGRID_SIZE = 20\n\n# 蛇身（列表存储坐标）\nsnake = [(200, 200), (180, 200), (160, 200)]\ndirection = (GRID_SIZE, 0)  # 初始向右\n\n# 食物\nfood = (random.randint(0, 39) * GRID_SIZE, random.randint(0, 29) * GRID_SIZE)\n\nscore = 0\ngame_over = False\n\nrunning = True\nwhile running:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            running = False\n        if event.type == pygame.KEYDOWN:\n            if event.key == pygame.K_LEFT and direction != (GRID_SIZE, 0):\n                direction = (-GRID_SIZE, 0)\n            elif event.key == pygame.K_RIGHT and direction != (-GRID_SIZE, 0):\n                direction = (GRID_SIZE, 0)\n            elif event.key == pygame.K_UP and direction != (0, GRID_SIZE):\n                direction = (0, -GRID_SIZE)\n            elif event.key == pygame.K_DOWN and direction != (0, -GRID_SIZE):\n                direction = (0, GRID_SIZE)\n\n    if not game_over:\n        # 计算新头部位置\n        new_head = (snake[0][0] + direction[0], snake[0][1] + direction[1])\n\n        # 边界检测\n        if new_head[0] < 0 or new_head[0] >= 800 or new_head[1] < 0 or new_head[1] >= 600:\n            game_over = True\n\n        # 自身碰撞检测\n        if new_head in snake:\n            game_over = True\n\n        if not game_over:\n            snake.insert(0, new_head)\n\n            # 吃到食物\n            if new_head == food:\n                score += 10\n                food = (random.randint(0, 39) * GRID_SIZE, random.randint(0, 29) * GRID_SIZE)\n            else:\n                snake.pop()  # 没吃到就删除尾部\n\n    # 绘制\n    screen.fill((0, 0, 0))\n\n    # 绘制食物\n    pygame.draw.rect(screen, (255, 0, 0), (food[0], food[1], GRID_SIZE-2, GRID_SIZE-2))\n\n    # 绘制蛇\n    for i, segment in enumerate(snake):\n        color = (0, 255, 0) if i == 0 else (0, 200, 0)  # 头部亮一点\n        pygame.draw.rect(screen, color, (segment[0], segment[1], GRID_SIZE-2, GRID_SIZE-2))\n\n    pygame.display.flip()\n    pygame.time.delay(100)  # 控制蛇的速度\n\npygame.quit()\n```\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 蛇移动太快 | 增加delay | 把100改成150或200 |\n| 想加障碍物 | 添加墙壁列表 | 碰到墙壁也游戏结束 |\n| 想显示分数 | 用font渲染 | 在屏幕上显示当前分数 |\n\n**禁忌提醒**\n❌ 允许180度转向——蛇会撞到自己\n❌ 食物生成在蛇身上——需要检测避免\n\n---\n\n**核心知识点**\n- 列表作为数据结构：存储蛇身坐标\n- insert()和pop()：实现蛇的移动\n- 方向控制：防止180度转向\n\n**底层逻辑**\n- **队列思想**：头部入队，尾部出队\n- **状态管理**：用变量控制游戏状态\n\n`#执行层` `#测评项`\n[UID: PYAI-22-08-001]\n\n---\n\n### 2-2-9 举重若轻1\n\n#### 课程基本信息\n\n| 项目 | 内容 |\n|------|------|\n| **课程编号** | 2-2-9 |\n| **课程名称** | 举重若轻1 |\n| **认知负荷** | 高 |\n| **核心技能** | 图像导入变换、能量值变化、游戏环节控制 |\n\n#### 详细教学流程\n\n**步骤1：知识讲解（20分钟）** `#中负荷-操练` `#IFC-即时`\n\n**教师话术**\n> \"今天开始做一个**大炮射击**游戏！这是一个三节课的大项目，我们会学到图像处理、物理运动、音效等很多知识。\"\n>\n> \"**Pygame图像加载**：\n> ```python\n> import pygame\n>\n> # 加载图像\n> cannon_img = pygame.image.load('cannon.png')\n>\n> # 缩放图像\n> cannon_img = pygame.transform.scale(cannon_img, (100, 50))\n>\n> # 旋转图像（角度，逆时针为正）\n> rotated = pygame.transform.rotate(cannon_img, 45)\n>\n> # 绘制到屏幕\n> screen.blit(cannon_img, (x, y))\n> ```\n>\n> **能量条设计**：\n> - 按住空格键蓄力，能量值增加\n> - 松开空格键发射，能量值决定初速度\"\n\n**核心代码模式**\n\n```python\nimport pygame\n\npygame.init()\nscreen = pygame.display.set_mode((800, 600))\n\n# 加载图像\ncannon_img = pygame.image.load('cannon.png')\ncannon_img = pygame.transform.scale(cannon_img, (80, 40))\n\n# 大炮位置和角度\ncannon_x, cannon_y = 50, 500\ncannon_angle = 45\n\n# 能量系统\nenergy = 0\nmax_energy = 100\ncharging = False\n\nrunning = True\nwhile running:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            running = False\n        if event.type == pygame.KEYDOWN:\n            if event.key == pygame.K_SPACE:\n                charging = True\n        if event.type == pygame.KEYUP:\n            if event.key == pygame.K_SPACE:\n                charging = False\n                # 发射炮弹（下节课实现）\n                print(f'发射！能量：{energy}')\n                energy = 0\n\n    # 蓄力\n    if charging and energy < max_energy:\n        energy += 2\n\n    # 角度控制\n    keys = pygame.key.get_pressed()\n    if keys[pygame.K_UP] and cannon_angle < 80:\n        cannon_angle += 1\n    if keys[pygame.K_DOWN] and cannon_angle > 10:\n        cannon_angle -= 1\n\n    screen.fill((135, 206, 235))  # 天蓝色背景\n\n    # 绘制大炮（旋转）\n    rotated_cannon = pygame.transform.rotate(cannon_img, cannon_angle)\n    screen.blit(rotated_cannon, (cannon_x, cannon_y - cannon_angle))\n\n    # 绘制能量条\n    pygame.draw.rect(screen, (100, 100, 100), (20, 20, 104, 24))  # 边框\n    pygame.draw.rect(screen, (0, 255, 0), (22, 22, energy, 20))   # 能量\n\n    pygame.display.flip()\n    pygame.time.delay(16)\n\npygame.quit()\n```\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 图像加载失败 | 检查路径 | 确认图片文件在正确位置 |\n| 旋转后图像变形 | 解释原理 | 旋转会改变图像尺寸，需要调整位置 |\n| 能量条不显示 | 检查坐标 | 确认绘制位置在屏幕范围内 |\n\n**禁忌提醒**\n❌ 图像路径错误——FileNotFoundError\n❌ 忘记convert()——大图像可能卡顿\n\n---\n\n**核心知识点**\n- 图像加载：`pygame.image.load()`\n- 图像变换：`pygame.transform.scale()` / `rotate()`\n- 能量系统：按键蓄力、松开释放\n- 游戏状态：用变量控制不同阶段\n\n`#执行层` `#测评项`\n[UID: PYAI-22-09-001]\n\n---\n\n### 2-2-10 举重若轻2\n\n#### 课程基本信息\n\n| 项目 | 内容 |\n|------|------|\n| **课程编号** | 2-2-10 |\n| **课程名称** | 举重若轻2 |\n| **认知负荷** | 高 |\n| **核心技能** | 物理运动原理、加速度、速度合并 |\n\n#### 详细教学流程\n\n**步骤1：知识讲解（20分钟）** `#中负荷-操练` `#IFC-即时`\n\n**教师话术**\n> \"今天我们要让炮弹'飞'起来！这需要用到**物理学**的知识。\"\n>\n> \"**抛物线运动**：\n> - 水平方向：匀速运动，vx不变\n> - 垂直方向：受重力影响，vy不断增加\n>\n> ```python\n> # 物理参数\n> gravity = 0.5  # 重力加速度\n> vx = 10        # 水平速度（不变）\n> vy = -15       # 垂直速度（负数表示向上）\n>\n> # 每帧更新\n> x += vx        # 水平位移\n> vy += gravity  # 垂直速度增加（重力）\n> y += vy        # 垂直位移\n> ```\n>\n> **速度分解**：\n> - 初速度v和角度θ\n> - vx = v × cos(θ)\n> - vy = v × sin(θ)（向上为负）\"\n\n**核心代码模式**\n\n```python\nimport pygame\nimport math\n\npygame.init()\nscreen = pygame.display.set_mode((800, 600))\n\n# 物理常量\nGRAVITY = 0.3\n\n# 炮弹类\nclass Bullet:\n    def __init__(self, x, y, speed, angle):\n        self.x = x\n        self.y = y\n        # 速度分解\n        rad = math.radians(angle)\n        self.vx = speed * math.cos(rad)\n        self.vy = -speed * math.sin(rad)  # 向上为负\n        self.active = True\n\n    def update(self):\n        if self.active:\n            self.x += self.vx\n            self.vy += GRAVITY  # 重力作用\n            self.y += self.vy\n\n            # 落地检测\n            if self.y > 550:\n                self.active = False\n\n    def draw(self, screen):\n        if self.active:\n            pygame.draw.circle(screen, (50, 50, 50), (int(self.x), int(self.y)), 8)\n\n# 炮弹列表\nbullets = []\n\n# 发射炮弹\ndef fire(x, y, energy, angle):\n    speed = energy / 5  # 能量转换为速度\n    bullet = Bullet(x, y, speed, angle)\n    bullets.append(bullet)\n\n# 主循环\ncannon_angle = 45\nenergy = 0\ncharging = False\n\nrunning = True\nwhile running:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            running = False\n        if event.type == pygame.KEYDOWN:\n            if event.key == pygame.K_SPACE:\n                charging = True\n        if event.type == pygame.KEYUP:\n            if event.key == pygame.K_SPACE:\n                charging = False\n                fire(80, 480, energy, cannon_angle)\n                energy = 0\n\n    if charging and energy < 100:\n        energy += 2\n\n    keys = pygame.key.get_pressed()\n    if keys[pygame.K_UP]: cannon_angle = min(80, cannon_angle + 1)\n    if keys[pygame.K_DOWN]: cannon_angle = max(10, cannon_angle - 1)\n\n    screen.fill((135, 206, 235))\n\n    # 绘制地面\n    pygame.draw.rect(screen, (34, 139, 34), (0, 550, 800, 50))\n\n    # 更新和绘制炮弹\n    for bullet in bullets:\n        bullet.update()\n        bullet.draw(screen)\n\n    # 清理已落地的炮弹\n    bullets = [b for b in bullets if b.active]\n\n    pygame.display.flip()\n    pygame.time.delay(16)\n\npygame.quit()\n```\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 炮弹飞太快/太慢 | 调整speed计算 | 修改energy/5的系数 |\n| 不理解三角函数 | 画图演示 | 用直角三角形解释sin/cos |\n| 想加风力影响 | 引入wind变量 | vx += wind实现风力效果 |\n\n**禁忌提醒**\n❌ 忘记转换弧度——math.sin/cos需要弧度\n❌ 重力方向错误——向下应该是正值\n\n---\n\n**核心知识点**\n- 抛物线运动：水平匀速 + 垂直加速\n- 速度分解：vx = v×cos(θ), vy = v×sin(θ)\n- 重力模拟：每帧vy += gravity\n- 弧度转换：math.radians(角度)\n\n**底层逻辑**\n- **物理仿真**：用数学公式模拟真实物理\n- **帧更新**：每帧计算新位置\n\n`#执行层` `#测评项`\n[UID: PYAI-22-10-001]\n\n---\n\n### 2-2-11 举重若轻3\n\n#### 课程基本信息\n\n| 项目 | 内容 |\n|------|------|\n| **课程编号** | 2-2-11 |\n| **课程名称** | 举重若轻3 |\n| **认知负荷** | 高 |\n| **核心技能** | 向量拆分合并、爆炸效果、音频加载 |\n\n#### 详细教学流程\n\n**步骤1：知识讲解（20分钟）** `#中负荷-操练` `#IFC-即时`\n\n**教师话术**\n> \"今天是大炮射击的最后一课！我们要加入**目标**、**爆炸效果**和**音效**，让游戏更完整！\"\n>\n> \"**Pygame音频**：\n> ```python\n> import pygame\n>\n> pygame.mixer.init()  # 初始化音频\n>\n> # 加载音效\n> explosion_sound = pygame.mixer.Sound('explosion.wav')\n>\n> # 播放音效\n> explosion_sound.play()\n>\n> # 加载背景音乐\n> pygame.mixer.music.load('bgm.mp3')\n> pygame.mixer.music.play(-1)  # -1表示循环播放\n> ```\n>\n> **爆炸效果**：\n> - 碰撞时创建爆炸粒子\n> - 粒子向四周扩散\n> - 逐渐消失\"\n\n**核心代码模式**\n\n```python\nimport pygame\nimport math\nimport random\n\npygame.init()\npygame.mixer.init()\nscreen = pygame.display.set_mode((800, 600))\n\nGRAVITY = 0.3\n\n# 目标类\nclass Target:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n        self.radius = 25\n        self.alive = True\n\n    def draw(self, screen):\n        if self.alive:\n            pygame.draw.circle(screen, (255, 0, 0), (self.x, self.y), self.radius)\n            pygame.draw.circle(screen, (255, 255, 255), (self.x, self.y), 15)\n            pygame.draw.circle(screen, (255, 0, 0), (self.x, self.y), 5)\n\n# 爆炸粒子类\nclass Particle:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n        angle = random.uniform(0, 2 * math.pi)\n        speed = random.uniform(2, 8)\n        self.vx = speed * math.cos(angle)\n        self.vy = speed * math.sin(angle)\n        self.life = 30  # 生命周期\n        self.color = random.choice([(255,100,0), (255,200,0), (255,50,0)])\n\n    def update(self):\n        self.x += self.vx\n        self.y += self.vy\n        self.vy += 0.1  # 轻微重力\n        self.life -= 1\n\n    def draw(self, screen):\n        if self.life > 0:\n            size = max(1, self.life // 5)\n            pygame.draw.circle(screen, self.color, (int(self.x), int(self.y)), size)\n\n# 炮弹类（简化版）\nclass Bullet:\n    def __init__(self, x, y, speed, angle):\n        self.x, self.y = x, y\n        rad = math.radians(angle)\n        self.vx = speed * math.cos(rad)\n        self.vy = -speed * math.sin(rad)\n        self.active = True\n\n    def update(self):\n        self.x += self.vx\n        self.vy += GRAVITY\n        self.y += self.vy\n        if self.y > 550: self.active = False\n\n    def draw(self, screen):\n        pygame.draw.circle(screen, (50,50,50), (int(self.x), int(self.y)), 8)\n\n# 碰撞检测\ndef check_hit(bullet, target):\n    dist = math.sqrt((bullet.x - target.x)**2 + (bullet.y - target.y)**2)\n    return dist < target.radius + 8\n\n# 创建爆炸\ndef create_explosion(x, y):\n    return [Particle(x, y) for _ in range(20)]\n\n# 游戏对象\ntargets = [Target(600, 500), Target(500, 450), Target(700, 480)]\nbullets = []\nparticles = []\nscore = 0\n\nrunning = True\nwhile running:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            running = False\n        if event.type == pygame.KEYUP:\n            if event.key == pygame.K_SPACE:\n                bullets.append(Bullet(80, 480, 15, 45))\n\n    screen.fill((135, 206, 235))\n    pygame.draw.rect(screen, (34, 139, 34), (0, 550, 800, 50))\n\n    # 更新炮弹\n    for bullet in bullets[:]:\n        bullet.update()\n        bullet.draw(screen)\n\n        # 检测碰撞\n        for target in targets:\n            if target.alive and check_hit(bullet, target):\n                target.alive = False\n                bullet.active = False\n                particles.extend(create_explosion(target.x, target.y))\n                score += 100\n\n    bullets = [b for b in bullets if b.active]\n\n    # 更新粒子\n    for p in particles[:]:\n        p.update()\n        p.draw(screen)\n    particles = [p for p in particles if p.life > 0]\n\n    # 绘制目标\n    for target in targets:\n        target.draw(screen)\n\n    pygame.display.flip()\n    pygame.time.delay(16)\n\npygame.quit()\n```\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 爆炸效果太弱 | 增加粒子数量 | 把20改成50 |\n| 想加音效 | 加载wav文件 | 碰撞时播放explosion_sound.play() |\n| 想加关卡 | 设计关卡系统 | 消灭所有目标后进入下一关 |\n\n**禁忌提醒**\n❌ 音频格式不支持——推荐使用wav或ogg\n❌ 粒子太多导致卡顿——控制粒子数量和生命周期\n\n---\n\n**核心知识点**\n- 音频加载：`pygame.mixer.Sound()` / `pygame.mixer.music`\n- 粒子系统：随机方向、速度、颜色\n- 碰撞响应：检测到碰撞后触发效果\n- 生命周期：粒子逐渐消失\n\n**底层逻辑**\n- **粒子系统**：大量简单对象模拟复杂效果\n- **游戏完整性**：视觉+音效+交互\n\n`#执行层` `#测评项`\n[UID: PYAI-22-11-001]\n\n---\n\n### 2-2-12 阶段复习\n\n#### 课程基本信息\n\n| 项目 | 内容 |\n|------|------|\n| **课程编号** | 2-2-12 |\n| **课程名称** | 阶段复习 |\n| **认知负荷** | 中 |\n| **核心技能** | 综合复习Pygame与OOP |\n\n#### 详细教学流程\n\n**步骤1：知识回顾（30分钟）** `#中负荷-操练` `#IFC-即时`\n\n**教师话术**\n> \"这个单元我们学了很多内容！让我们来回顾一下：\n>\n> **面向对象编程(OOP)**：\n> - class定义类，是模板/蓝图\n> - 实例是根据类创建的具体对象\n> - `__init__`是初始化方法\n> - `self`代表实例本身\n>\n> **Pygame基础**：\n> - `pygame.init()` 初始化\n> - `pygame.display.set_mode()` 创建窗口\n> - 游戏主循环：事件处理 → 更新 → 绘制 → 刷新\n>\n> **图形绘制**：\n> - `pygame.draw.line/rect/circle()`\n> - RGB颜色：(R, G, B)，每个值0-255\n>\n> **图像处理**：\n> - `pygame.image.load()` 加载\n> - `pygame.transform.scale/rotate()` 变换\n>\n> **物理仿真**：\n> - 抛物线：水平匀速 + 垂直加速\n> - 重力：每帧vy += gravity\n> - 碰撞检测：距离 < 半径之和\"\n\n**步骤2：综合练习（40分钟）** `#高负荷-产出` `#IFC-即时`\n\n**教师话术**\n> \"现在来做一个**综合测试**！完成以下任务：\n>\n> 1. 创建一个Ball类，包含位置、速度、颜色属性\n> 2. 让球在屏幕内弹跳（碰到边界反弹）\n> 3. 用键盘控制一个方块，碰到球就得分\n>\n> 这个练习综合了OOP、Pygame绑图、按键控制、碰撞检测！\"\n\n**核心代码模式（参考答案）**\n\n```python\nimport pygame\nimport random\n\npygame.init()\nscreen = pygame.display.set_mode((800, 600))\nfont = pygame.font.Font(None, 48)\n\nclass Ball:\n    def __init__(self):\n        self.x = random.randint(100, 700)\n        self.y = random.randint(100, 500)\n        self.vx = random.choice([-4, -3, 3, 4])\n        self.vy = random.choice([-4, -3, 3, 4])\n        self.radius = 15\n        self.color = (random.randint(50,255), random.randint(50,255), random.randint(50,255))\n\n    def update(self):\n        self.x += self.vx\n        self.y += self.vy\n        # 边界反弹\n        if self.x < self.radius or self.x > 800 - self.radius:\n            self.vx = -self.vx\n        if self.y < self.radius or self.y > 600 - self.radius:\n            self.vy = -self.vy\n\n    def draw(self, screen):\n        pygame.draw.circle(screen, self.color, (int(self.x), int(self.y)), self.radius)\n\n# 玩家方块\nplayer_x, player_y = 400, 300\nplayer_size = 30\nspeed = 5\nscore = 0\n\n# 创建多个球\nballs = [Ball() for _ in range(5)]\n\nrunning = True\nwhile running:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            running = False\n\n    # 键盘控制\n    keys = pygame.key.get_pressed()\n    if keys[pygame.K_LEFT]: player_x -= speed\n    if keys[pygame.K_RIGHT]: player_x += speed\n    if keys[pygame.K_UP]: player_y -= speed\n    if keys[pygame.K_DOWN]: player_y += speed\n\n    # 边界限制\n    player_x = max(0, min(800 - player_size, player_x))\n    player_y = max(0, min(600 - player_size, player_y))\n\n    # 碰撞检测\n    player_center = (player_x + player_size/2, player_y + player_size/2)\n    for ball in balls[:]:\n        dist = ((ball.x - player_center[0])**2 + (ball.y - player_center[1])**2)**0.5\n        if dist < ball.radius + player_size/2:\n            balls.remove(ball)\n            balls.append(Ball())  # 生成新球\n            score += 10\n\n    screen.fill((30, 30, 30))\n\n    # 绘制球\n    for ball in balls:\n        ball.update()\n        ball.draw(screen)\n\n    # 绘制玩家\n    pygame.draw.rect(screen, (0, 255, 0), (player_x, player_y, player_size, player_size))\n\n    # 显示分数\n    text = font.render(f'Score: {score}', True, (255, 255, 255))\n    screen.blit(text, (20, 20))\n\n    pygame.display.flip()\n    pygame.time.delay(16)\n\npygame.quit()\n```\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 完成太快 | 增加难度 | 球越来越快，或者加入躲避模式 |\n| 有困难 | 简化任务 | 先只做弹跳球，再加玩家控制 |\n| 想做更多 | 鼓励创意 | 加入计时、关卡、音效等 |\n\n---\n\n**步骤3：成果展示（10分钟）** `#低负荷-热身` `#IFC-复盘`\n\n**教师话术**\n> \"谁来展示一下你的作品？说说你用了哪些知识点？\n>\n> 这个单元我们从零开始，学会了用Python做游戏！\n> - 面向对象让代码更有组织\n> - Pygame让我们能画图、放音乐、做交互\n> - 物理仿真让游戏更真实\n>\n> 下个单元我们会学习更多AI相关的内容！\"\n\n---\n\n**核心知识点**\n- OOP综合：类定义、实例创建、方法调用\n- Pygame综合：初始化、主循环、绑图、事件\n- 物理综合：运动、碰撞、反弹\n- 游戏设计：玩家控制、得分系统\n\n**底层逻辑**\n- **知识整合**：将分散的知识点串联成完整项目\n- **能力迁移**：从模仿到独立创作\n\n`#执行层` `#测评项`\n[UID: PYAI-22-12-001]\n\n---"
    },
    {
      "title": "教学禁忌清单",
      "content": "| 序号 | 禁忌 | 原因 | 正确做法 |\n|------|------|------|----------|\n| 1 | ❌ **方法定义忘记self** | TypeError错误 | 方法第一个参数必须是self |\n| 2 | ❌ **__init__写成_init_** | 不会自动调用 | 左右各两个下划线 |\n| 3 | ❌ **类名用小写** | 不符合规范 | 使用大驼峰命名法(PascalCase) |\n| 4 | ❌ **遍历列表时直接删除** | 跳过元素 | 用切片复制或倒序遍历 |\n| 5 | ❌ **忘记pygame.display.flip()** | 画面不更新 | 每帧结束必须调用 |\n| 6 | ❌ **角度不转弧度** | 三角函数结果错误 | 使用math.radians()转换 |\n\n`#执行层` `#测评项`\n[UID: PYAI-TABOO-22]\n\n---"
    },
    {
      "title": "教学注意事项",
      "content": "| 类别 | 注意事项 |\n|------|----------|\n| **OOP教学** | 用具体类比（模具-饼干、蓝图-房子）帮助理解抽象概念 |\n| **Pygame调试** | 用print()输出变量值，确认逻辑正确 |\n| **物理仿真** | 先画图解释原理，再写代码实现 |\n| **项目管理** | 大项目分步完成，每步都能运行测试 |\n\n---"
    },
    {
      "title": "底层教育学原理",
      "content": "| 原理 | 说明 | 在本单元的应用 |\n|------|------|----------------|\n| **面向对象思维** | 用类封装数据和行为 | 弹幕、星星、炮弹都是类的实例 |\n| **物理建模** | 用数学公式模拟真实世界 | 抛物线运动、重力、碰撞 |\n| **项目驱动学习** | 通过完整项目整合知识 | 大炮射击三部曲、贪食蛇 |\n| **螺旋式上升** | 知识点逐步加深 | 从简单绘图到复杂游戏 |\n\n`#执行层` `#测评项`\n[UID: PYAI-THEORY-22]\n\n---\n\n**质量评估**：10/10（原子化萃取版，12节课完整萃取）\n**已补充**：认知负荷标签、IFC标签、变体示例、详细教师话术、核心代码模式\n**课程覆盖**：2-2-1至2-2-12全部12节课\n\n---\n\n**最后更新**：2026-02-09"
    }
  ],
  "full_content": "# PythonAI萃取：L2-2 项目应用\n\n> **来源**：NotebookLM Python AI Lesson Plan (96个来源)\n> **萃取日期**：2026-02-09\n> **萃取深度**：5-5多维度（含认知负荷标签、IFC标签、变体示例）\n> **更新日期**：2026-02-09\n\n---\n\n## 单元概览\n\n| 项目 | 内容 |\n|------|------|\n| **单元编号** | PYAI 2-2 |\n| **单元名称** | 项目应用 |\n| **适用年龄** | 四年级及以上（10-12岁） |\n| **课时数** | 12节 × 90分钟 |\n| **核心目标** | 掌握Pygame游戏开发与物理仿真，实现面向对象编程的综合应用 |\n| **主要平台** | Python IDLE + Pygame |\n\n**底层逻辑**\n从面向过程转向面向对象编程，通过游戏开发项目理解类与实例、碰撞检测、物理仿真等核心概念。\n\n**单元教��策略**\n- 面向对象（01）：类和对象基础\n- Pygame入门（02-03）：文字绘制、弹幕生成\n- 图形绘制（04-06）：pygame.draw、蒙特卡洛、星空特效\n- 游戏开发（07-08）：球球大作战、贪食蛇\n- 物理仿真（09-11）：大炮射击系列、Pymunk引擎\n- 阶段复习（12）：知识整合\n\n`#执行层` `#测评项`\n[UID: PYAI-22-001]\n[关联: PYAI-21-001 PythonAI算法数据科学（前置基础）]\n[关联: PYAI-11-001 PythonAI函数封装（前置基础）]\n[关联: PYAI-23-001 PythonAI交互式AI（进阶衔接）]\n\n---\n\n## 课程列表\n\n| 课次 | 课程名称 | 核心知识点 | 项目内容 | 认知负荷 |\n|------|----------|------------|----------|----------|\n| 2-2-1 | 脚踏实地 | class定义、实例创建、self、__init__ | 类和对象 | 高 |\n| 2-2-2 | 电子成绩单 | IDLE环境、Pygame初识、文字绘制 | 电子成绩单 | 中-高 |\n| 2-2-3 | 弹幕生成器 | Pygame综合、Random/Time模块、类实例应用 | 弹幕生成器 | 高 |\n| 2-2-4 | 规矩方圆 | pygame.draw.line()、二维列表、RGB色彩 | 规矩方圆 | 中-高 |\n| 2-2-5 | 蒙特卡洛法 | pygame.draw.circle()、距离公式、蒙特卡洛算法 | 求圆周率 | 高 |\n| 2-2-6 | 弱肉强食 | 随机模块、类属性控制、for循环高级用法 | 星空特效 | 中-高 |\n| 2-2-7 | 积小致巨1 | 按键交互、碰撞检测、列表动态操作 | 球球大作战 | 高 |\n| 2-2-8 | 积小致巨2 | 多角色联动、列表数据存取、贪食蛇逻辑 | 贪食蛇 | 高 |\n| 2-2-9 | 举重若轻1 | 图像导入变换、能量值变化、游戏环节控制 | 大炮射击1 | 高 |\n| 2-2-10 | 举重若轻2 | 物理运动原理、加速度、速度合并 | 大炮射击2 | 高 |\n| 2-2-11 | 举重若轻3 | 向量拆分合并、爆炸效果、音频加载 | 大炮射击3 | 高 |\n| 2-2-12 | 阶段复习 | 综合复习Pygame与OOP | 阶段测试 | 中 |\n\n---\n\n## 通用教学流程（90分钟）\n\n| 环节 | 时间 | 内容 | 认知负荷 | IFC标签 |\n|------|------|------|----------|---------|\n| 课堂问候 | 2分钟 | 自我介绍、学习目标 | `#低负荷-热身` | `#IFC-预防` |\n| 课程回顾 | 5分钟 | 复习上节课代码知识 | `#低负荷-热身` | `#IFC-预防` |\n| 知识讲解 | 20分钟 | 新概念/语法讲解 | `#中负荷-操练` | `#IFC-即时` |\n| 代码实践 | 40分钟 | 编写游戏代码、调试 | `#高负荷-产出` | `#IFC-即时` |\n| 调节休息 | 3分钟 | 站起来活动 | `#调节-放松` | - |\n| 项目拓展 | 10分钟 | 功能扩展/创意改进 | `#高负荷-产出` | `#IFC-即时` |\n| 成果展示 | 10分钟 | 演示游戏、分享思路 | `#低负荷-热身` | `#IFC-复盘` |\n\n`#执行层` `#测评项`\n[UID: PYAI-22-FLOW-001]\n\n---\n\n## 详细课程萃取\n\n### 2-2-1 脚踏实地（典型案例）\n\n#### 课程基本信息\n\n| 项目 | 内容 |\n|------|------|\n| **课程编号** | 2-2-1 |\n| **课程名称** | 脚踏实地 |\n| **认知负荷** | 高 |\n| **核心技能** | class定义、实例创建、self、__init__ |\n\n#### 详细教学流程\n\n**步骤1：知识讲解（20分钟）** `#中负荷-操练` `#IFC-即时`\n\n**教师话术**\n> \"今天我们学习一个超级重要的概念——**面向对象编程(OOP)**！之前我们写的代码是'面向过程'的，一步一步执行。现在要学习把数据和动作'打包'在一起。\"\n>\n> \"**类(Class)和实例(Instance)**：\n> - 类是**模板/蓝图**，定义了一类事物的共同特征\n> - 实例是根据类创建的**具体对象**\n>\n> 比喻：类就像'做饼干的模具'，实例就是用模具压出来的'饼干'。\"\n>\n> \"**定义类的语法**：\n> ```python\n> class Dog:\n>     # 属性（特征）\n>     name = '小白'\n>     color = '白色'\n>\n>     # 方法（行为）\n>     def bark(self):\n>         print('汪汪！')\n>\n> # 创建实例\n> dog1 = Dog()\n> dog1.name = '旺财'\n> dog1.bark()  # 输出：汪汪！\n> ```\"\n\n**核心代码模式**\n\n```python\n# 1. 定义类\nclass Student:\n    # 初始化方法，创建对象时自动调用\n    def __init__(self, name, score):\n        self.name = name   # 实例属性\n        self.score = score\n\n    # 实例方法\n    def introduce(self):\n        print(f'我是{self.name}，考了{self.score}分')\n\n# 2. 创建实例\ns1 = Student('小明', 98)\ns2 = Student('小红', 100)\n\n# 3. 调用方法\ns1.introduce()  # 输出：我是小明，考了98分\n```\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 不理解类和实例 | 用模具类比 | \"类是模具，实例是用模具做出来的饼干\" |\n| 忘记写self | 强调规则 | \"方法的第一个参数必须是self，代表'我自己'\" |\n| __init__写错 | 强调双下划线 | \"左右各两个下划线，不是单下划线\" |\n| 混淆类属性和实例属性 | 演示区别 | 修改dog1.name不影响dog2.name |\n\n**禁忌提醒**\n❌ 方法定义忘记self——TypeError错误\n❌ __init__写成_init_——不会自动调用\n❌ 类名用小写——应该用大驼峰命名法\n\n---\n\n**核心知识点**\n- 类(Class)：抽象的模板/蓝图\n- 实例(Instance)：具体的对象\n- self：代表实例本身\n- __init__：初始化方法，创建实例时自动调用\n\n**底层逻辑**\n- **封装思想**：把数据和操作数据的方法打包在一起\n- **代码复用**：一个类可以创建多个实例\n\n`#执行层` `#测评项`\n[UID: PYAI-22-01-001]\n[关联: PYAI-11-01-001 函数定义（前置基础）]\n\n---\n\n### 2-2-2 电子成绩单\n\n#### 课程基本信息\n\n| 项目 | 内容 |\n|------|------|\n| **课程编号** | 2-2-2 |\n| **课程名称** | 电子成绩单 |\n| **认知负荷** | 中-高 |\n| **核心技能** | IDLE环境、Pygame初识、文字绘制 |\n\n#### 详细教学流程\n\n**步骤1：知识讲解（20分钟）** `#中负荷-操练` `#IFC-即时`\n\n**教师话术**\n> \"今天我们开始学习**Pygame**——Python最流行的游戏开发库！先从最简单的开始：在窗口上显示文字。\"\n>\n> \"**Pygame基础结构**：\n> ```python\n> import pygame\n>\n> # 1. 初始化\n> pygame.init()\n>\n> # 2. 创建窗口\n> screen = pygame.display.set_mode((800, 600))\n> pygame.display.set_caption('我的第一个Pygame程序')\n>\n> # 3. 游戏主循环\n> running = True\n> while running:\n>     for event in pygame.event.get():\n>         if event.type == pygame.QUIT:\n>             running = False\n>\n>     # 填充背景色\n>     screen.fill((255, 255, 255))\n>\n>     # 更新显示\n>     pygame.display.flip()\n>\n> pygame.quit()\n> ```\"\n\n**核心代码模式**\n\n```python\nimport pygame\n\npygame.init()\nscreen = pygame.display.set_mode((800, 600))\n\n# 创建字体对象\nfont = pygame.font.Font(None, 48)  # None使用默认字体，48是字号\n\n# 渲染文字（文字内容, 抗锯齿, 颜色）\ntext = font.render('Hello Pygame!', True, (0, 0, 0))\n\nrunning = True\nwhile running:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            running = False\n\n    screen.fill((255, 255, 255))\n\n    # 绘制文字到屏幕\n    screen.blit(text, (100, 100))  # (x, y)坐标\n\n    pygame.display.flip()\n\npygame.quit()\n```\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 窗口闪退 | 检查主循环 | 确保while循环正确运行 |\n| 中文显示乱码 | 使用中文字体 | pygame.font.Font('simhei.ttf', 48) |\n| 想改变颜色 | 解释RGB | (255,0,0)红色，(0,255,0)绿色 |\n\n---\n\n**核心知识点**\n- Pygame初始化：`pygame.init()`\n- 创建窗口：`pygame.display.set_mode((宽, 高))`\n- 游戏主循环：while循环 + 事件处理\n- 文字渲染：`font.render()` + `screen.blit()`\n\n`#执行层` `#测评项`\n[UID: PYAI-22-02-001]\n\n---\n\n### 2-2-3 弹幕生成器\n\n#### 课程基本信息\n\n| 项目 | 内容 |\n|------|------|\n| **课程编号** | 2-2-3 |\n| **课程名称** | 弹幕生成器 |\n| **认知负荷** | 高 |\n| **核心技能** | Pygame综合、Random/Time模块、类实例应用 |\n\n#### 详细教学流程\n\n**步骤1：知识讲解（20分钟）** `#中负荷-操练` `#IFC-即时`\n\n**教师话术**\n> \"今天我们做一个**弹幕生成器**！就像B站视频上飘过的弹幕一样。这个项目会用到上节课学的类和Pygame。\"\n>\n> \"**弹幕的本质**：\n> - 每条弹幕是一个**对象**（有位置、速度、内容）\n> - 弹幕从右边出现，向左移动\n> - 用**列表**管理多条弹幕\"\n\n**核心代码模式**\n\n```python\nimport pygame\nimport random\n\n# 弹幕类\nclass Danmaku:\n    def __init__(self, text, y):\n        self.text = text\n        self.x = 800  # 从右边开始\n        self.y = y\n        self.speed = random.randint(3, 8)\n        self.color = (random.randint(0,255), random.randint(0,255), random.randint(0,255))\n\n    def move(self):\n        self.x -= self.speed  # 向左移动\n\n    def draw(self, screen, font):\n        text_surface = font.render(self.text, True, self.color)\n        screen.blit(text_surface, (self.x, self.y))\n\n# 主程序\npygame.init()\nscreen = pygame.display.set_mode((800, 600))\nfont = pygame.font.Font(None, 36)\n\ndanmaku_list = []\nmessages = ['Hello!', 'Pygame真好玩', '666', '前方高能']\n\nrunning = True\nframe_count = 0\nwhile running:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            running = False\n\n    # 每60帧生成一条弹幕\n    frame_count += 1\n    if frame_count % 60 == 0:\n        text = random.choice(messages)\n        y = random.randint(50, 550)\n        danmaku_list.append(Danmaku(text, y))\n\n    screen.fill((0, 0, 0))\n\n    # 更新和绘制所有弹幕\n    for d in danmaku_list:\n        d.move()\n        d.draw(screen, font)\n\n    # 移除已经飘出屏幕的弹幕\n    danmaku_list = [d for d in danmaku_list if d.x > -200]\n\n    pygame.display.flip()\n    pygame.time.delay(16)  # 约60FPS\n\npygame.quit()\n```\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 弹幕太快/太慢 | 调整speed范围 | 修改random.randint的参数 |\n| 想添加自定义弹幕 | 加入input | 用pygame.KEYDOWN捕获输入 |\n| 弹幕重叠 | 优化y坐标 | 检测已有弹幕位置避免重叠 |\n\n---\n\n**核心知识点**\n- 类的综合应用：封装弹幕的属性和行为\n- 列表管理对象：存储多个弹幕实例\n- 列表推导式：过滤已消失的弹幕\n- 帧率控制：`pygame.time.delay()`\n\n`#执行层` `#测评项`\n[UID: PYAI-22-03-001]\n\n---\n\n### 2-2-4 规矩方圆\n\n#### 课程基本信息\n\n| 项目 | 内容 |\n|------|------|\n| **课程编号** | 2-2-4 |\n| **课程名称** | 规矩方圆 |\n| **认知负荷** | 中-高 |\n| **核心技能** | pygame.draw.line()、二维列表、RGB色彩 |\n\n#### 详细教学流程\n\n**步骤1：知识讲解（20分钟）** `#中负荷-操练` `#IFC-即时`\n\n**教师话术**\n> \"今天学习Pygame的**绑图函数**！用代码画出各种图形。\"\n>\n> \"**pygame.draw模块**：\n> ```python\n> # 画线\n> pygame.draw.line(screen, color, start_pos, end_pos, width)\n>\n> # 画矩形\n> pygame.draw.rect(screen, color, (x, y, width, height), width)\n>\n> # 画圆\n> pygame.draw.circle(screen, color, center, radius, width)\n> ```\n>\n> **RGB色彩**：\n> - (255, 0, 0) = 红色\n> - (0, 255, 0) = 绿色\n> - (0, 0, 255) = 蓝色\n> - (255, 255, 255) = 白色\n> - (0, 0, 0) = 黑色\"\n\n**核心代码模式**\n\n```python\nimport pygame\n\npygame.init()\nscreen = pygame.display.set_mode((800, 600))\n\nrunning = True\nwhile running:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            running = False\n\n    screen.fill((255, 255, 255))\n\n    # 画线（红色，从(100,100)到(300,300)，宽度3）\n    pygame.draw.line(screen, (255, 0, 0), (100, 100), (300, 300), 3)\n\n    # 画矩形（蓝色，位置(400,100)，大小200x150，边框宽度2）\n    pygame.draw.rect(screen, (0, 0, 255), (400, 100, 200, 150), 2)\n\n    # 画填充矩形（宽度为0表示填充）\n    pygame.draw.rect(screen, (0, 255, 0), (400, 300, 200, 150), 0)\n\n    # 画圆（黄色，圆心(200,400)，半径50，填充）\n    pygame.draw.circle(screen, (255, 255, 0), (200, 400), 50, 0)\n\n    pygame.display.flip()\n\npygame.quit()\n```\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 分不清填充和边框 | 演示width参数 | width=0填充，width>0画边框 |\n| 想画更多图形 | 介绍其他函数 | polygon多边形、ellipse椭圆 |\n| 颜色不对 | 检查RGB顺序 | 是(R,G,B)不是(B,G,R) |\n\n---\n\n**核心知识点**\n- pygame.draw.line()：画线\n- pygame.draw.rect()：画矩形\n- pygame.draw.circle()：画圆\n- RGB色彩模型：三原色混合\n\n`#执行层` `#测评项`\n[UID: PYAI-22-04-001]\n\n---\n\n### 2-2-5 蒙特卡洛法\n\n#### 课程基本信息\n\n| 项目 | 内容 |\n|------|------|\n| **课程编号** | 2-2-5 |\n| **课程名称** | 蒙特卡洛法 |\n| **认知负荷** | 高 |\n| **核心技能** | pygame.draw.circle()、距离公式、蒙特卡洛算法 |\n\n#### 详细教学流程\n\n**步骤1：知识讲解（20分钟）** `#中负荷-操练` `#IFC-即时`\n\n**教师话术**\n> \"今天我们用**随机数**来计算**圆周率π**！这种方法叫**蒙特卡洛法**。\"\n>\n> \"**原理**：\n> 1. 画一个正方形，边长为2r\n> 2. 在正方形内画一个内切圆，半径为r\n> 3. 随机撒点，统计落在圆内的点数\n> 4. 圆内点数/总点数 ≈ 圆面积/正方形面积 = πr²/(2r)² = π/4\n> 5. 所以 π ≈ 4 × (圆内点数/总点数)\"\n>\n> \"**判断点是否在圆内**：\n> - 计算点到圆心的距离\n> - 距离公式：d = √((x-cx)² + (y-cy)²)\n> - 如果 d ≤ r，点在圆内\"\n\n**核心代码模式**\n\n```python\nimport pygame\nimport random\nimport math\n\npygame.init()\nscreen = pygame.display.set_mode((600, 600))\nfont = pygame.font.Font(None, 36)\n\n# 圆心和半径\ncx, cy = 300, 300\nradius = 250\n\ninside_count = 0\ntotal_count = 0\n\nrunning = True\nwhile running:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            running = False\n\n    # 每帧撒10个点\n    for _ in range(10):\n        x = random.randint(cx - radius, cx + radius)\n        y = random.randint(cy - radius, cy + radius)\n\n        # 计算到圆心的距离\n        distance = math.sqrt((x - cx)**2 + (y - cy)**2)\n\n        total_count += 1\n        if distance <= radius:\n            inside_count += 1\n            color = (255, 0, 0)  # 圆内红色\n        else:\n            color = (0, 0, 255)  # 圆外蓝色\n\n        pygame.draw.circle(screen, color, (x, y), 2)\n\n    # 计算π的估计值\n    if total_count > 0:\n        pi_estimate = 4 * inside_count / total_count\n        text = font.render(f'Pi = {pi_estimate:.6f}', True, (0, 0, 0))\n        pygame.draw.rect(screen, (255, 255, 255), (10, 10, 200, 40))\n        screen.blit(text, (20, 20))\n\n    pygame.display.flip()\n    pygame.time.delay(10)\n\npygame.quit()\n```\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 不理解蒙特卡洛 | 用投飞镖类比 | \"随机投飞镖，统计落在靶心的比例\" |\n| π值不准确 | 增加点数 | 点越多越接近真实值 |\n| 想加速计算 | 减少绘制 | 不是每个点都画出来 |\n\n---\n\n**核心知识点**\n- 蒙特卡洛算法：用随机数模拟概率\n- 距离公式：d = √((x₁-x₂)² + (y₁-y₂)²)\n- 概率与面积的关系\n\n**底层逻辑**\n- **随机模拟**：用大量随机样本逼近真实结果\n- **数学应用**：几何概率在编程中的应用\n\n`#执行层` `#测评项`\n[UID: PYAI-22-05-001]\n\n---\n\n### 2-2-6 弱肉强食\n\n#### 课程基本信息\n\n| 项目 | 内容 |\n|------|------|\n| **课程编号** | 2-2-6 |\n| **课程名称** | 弱肉强食 |\n| **认知负荷** | 中-高 |\n| **核心技能** | 随机模块、类属性控制、for循环高级用法 |\n\n#### 详细教学流程\n\n**步骤1：知识讲解（20分钟）** `#中负荷-操练` `#IFC-即时`\n\n**教师话术**\n> \"今天我们做一个**星空特效**！屏幕上有很多星星，它们会移动、闪烁。\"\n>\n> \"**设计思路**：\n> 1. 每颗星星是一个对象（有位置、大小、速度、亮度）\n> 2. 用列表管理所有星星\n> 3. 每帧更新星星的位置和亮度\"\n\n**核心代码模式**\n\n```python\nimport pygame\nimport random\n\nclass Star:\n    def __init__(self):\n        self.x = random.randint(0, 800)\n        self.y = random.randint(0, 600)\n        self.size = random.randint(1, 3)\n        self.speed = random.uniform(0.5, 2.0)\n        self.brightness = random.randint(100, 255)\n        self.twinkle_speed = random.uniform(1, 5)\n\n    def update(self):\n        # 移动\n        self.y += self.speed\n        if self.y > 600:\n            self.y = 0\n            self.x = random.randint(0, 800)\n\n        # 闪烁\n        self.brightness += self.twinkle_speed\n        if self.brightness > 255 or self.brightness < 100:\n            self.twinkle_speed = -self.twinkle_speed\n\n    def draw(self, screen):\n        b = int(self.brightness)\n        color = (b, b, b)\n        pygame.draw.circle(screen, color, (int(self.x), int(self.y)), self.size)\n\npygame.init()\nscreen = pygame.display.set_mode((800, 600))\n\n# 创建100颗星星\nstars = [Star() for _ in range(100)]\n\nrunning = True\nwhile running:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            running = False\n\n    screen.fill((0, 0, 30))  # 深蓝色背景\n\n    for star in stars:\n        star.update()\n        star.draw(screen)\n\n    pygame.display.flip()\n    pygame.time.delay(16)\n\npygame.quit()\n```\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 星星太少 | 增加数量 | 把100改成200或更多 |\n| 想要彩色星星 | 修改颜色 | 随机生成RGB颜色 |\n| 想加流星 | 新建流星类 | 速度更快、有尾迹 |\n\n---\n\n**核心知识点**\n- 类属性的动态变化\n- 列表推导式创建对象\n- 边界检测和重置\n\n`#执行层` `#测评项`\n[UID: PYAI-22-06-001]\n\n---\n\n### 2-2-7 积小致巨1\n\n#### 课程基本信息\n\n| 项目 | 内容 |\n|------|------|\n| **课程编号** | 2-2-7 |\n| **课程名称** | 积小致巨1 |\n| **认知负荷** | 高 |\n| **核心技能** | 按键交互、碰撞检测、列表动态操作 |\n\n#### 详细教学流程\n\n**步骤1：知识讲解（20分钟）** `#中负荷-操练` `#IFC-即时`\n\n**教师话术**\n> \"今天我们做一个**球球大作战**游戏！玩家控制一个球，吃掉小球变大，碰到大球就游戏结束。\"\n>\n> \"**按键交互**：用键盘控制角色移动\n> ```python\n> keys = pygame.key.get_pressed()\n> if keys[pygame.K_LEFT]:\n>     player_x -= speed\n> if keys[pygame.K_RIGHT]:\n>     player_x += speed\n> if keys[pygame.K_UP]:\n>     player_y -= speed\n> if keys[pygame.K_DOWN]:\n>     player_y += speed\n> ```\n>\n> **碰撞检测**：判断两个圆是否相交\n> ```python\n> def check_collision(x1, y1, r1, x2, y2, r2):\n>     distance = math.sqrt((x1-x2)**2 + (y1-y2)**2)\n>     return distance < r1 + r2  # 距离小于半径之和就碰撞\n> ```\"\n\n**核心代码模式**\n\n```python\nimport pygame\nimport random\nimport math\n\npygame.init()\nscreen = pygame.display.set_mode((800, 600))\n\n# 玩家\nplayer_x, player_y = 400, 300\nplayer_radius = 20\nspeed = 5\n\n# 食物球列表\nfoods = []\nfor _ in range(20):\n    foods.append({\n        'x': random.randint(50, 750),\n        'y': random.randint(50, 550),\n        'radius': random.randint(5, 15),\n        'color': (random.randint(50,255), random.randint(50,255), random.randint(50,255))\n    })\n\ndef check_collision(x1, y1, r1, x2, y2, r2):\n    distance = math.sqrt((x1-x2)**2 + (y1-y2)**2)\n    return distance < r1 + r2\n\nrunning = True\nwhile running:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            running = False\n\n    # 按键控制\n    keys = pygame.key.get_pressed()\n    if keys[pygame.K_LEFT]: player_x -= speed\n    if keys[pygame.K_RIGHT]: player_x += speed\n    if keys[pygame.K_UP]: player_y -= speed\n    if keys[pygame.K_DOWN]: player_y += speed\n\n    # 边界限制\n    player_x = max(player_radius, min(800-player_radius, player_x))\n    player_y = max(player_radius, min(600-player_radius, player_y))\n\n    # 碰撞检测\n    for food in foods[:]:  # 用切片复制列表，避免遍历时修改\n        if check_collision(player_x, player_y, player_radius,\n                          food['x'], food['y'], food['radius']):\n            if player_radius > food['radius']:\n                # 吃掉小球，变大\n                player_radius += food['radius'] // 3\n                foods.remove(food)\n\n    screen.fill((30, 30, 30))\n\n    # 绘制食物\n    for food in foods:\n        pygame.draw.circle(screen, food['color'], (food['x'], food['y']), food['radius'])\n\n    # 绘制玩家\n    pygame.draw.circle(screen, (0, 255, 0), (int(player_x), int(player_y)), player_radius)\n\n    pygame.display.flip()\n    pygame.time.delay(16)\n\npygame.quit()\n```\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 移动太快/太慢 | 调整speed | 根据手感调整移动速度 |\n| 想加敌人 | 添加AI球 | 敌人球会追踪玩家 |\n| 碰撞不准 | 检查半径 | 确保碰撞检测使用正确的半径 |\n\n**禁忌提醒**\n❌ 遍历列表时直接删除元素——会跳过元素，用切片复制\n❌ 忘记边界限制——球会跑出屏幕\n\n---\n\n**核心知识点**\n- 按键交互：`pygame.key.get_pressed()`\n- 碰撞检测：圆形碰撞（距离 < 半径之和）\n- 列表动态操作：遍历时安全删除元素\n\n`#执行层` `#测评项`\n[UID: PYAI-22-07-001]\n\n---\n\n### 2-2-8 积小致巨2\n\n#### 课程基本信息\n\n| 项目 | 内容 |\n|------|------|\n| **课程编号** | 2-2-8 |\n| **课程名称** | 积小致巨2 |\n| **认知负荷** | 高 |\n| **核心技能** | 多角色联动、列表数据存取、贪食蛇逻辑 |\n\n#### 详细教学流程\n\n**步骤1：知识讲解（20分钟）** `#中负荷-操练` `#IFC-即时`\n\n**教师话术**\n> \"今天做经典游戏**贪食蛇**！蛇的身体是一串方块，吃到食物就变长。\"\n>\n> \"**贪食蛇的核心逻辑**：\n> 1. 蛇身用**列表**存储每个方块的坐标\n> 2. 移动时：头部添加新位置，尾部删除\n> 3. 吃到食物：头部添加，尾部不删除（变长）\n>\n> ```python\n> snake = [(100, 100), (80, 100), (60, 100)]  # 头在前\n> direction = (20, 0)  # 向右移动\n>\n> # 移动\n> new_head = (snake[0][0] + direction[0], snake[0][1] + direction[1])\n> snake.insert(0, new_head)  # 头部添加\n> snake.pop()  # 尾部删除\n> ```\"\n\n**核心代码模式**\n\n```python\nimport pygame\nimport random\n\npygame.init()\nscreen = pygame.display.set_mode((800, 600))\n\nGRID_SIZE = 20\n\n# 蛇身（列表存储坐标）\nsnake = [(200, 200), (180, 200), (160, 200)]\ndirection = (GRID_SIZE, 0)  # 初始向右\n\n# 食物\nfood = (random.randint(0, 39) * GRID_SIZE, random.randint(0, 29) * GRID_SIZE)\n\nscore = 0\ngame_over = False\n\nrunning = True\nwhile running:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            running = False\n        if event.type == pygame.KEYDOWN:\n            if event.key == pygame.K_LEFT and direction != (GRID_SIZE, 0):\n                direction = (-GRID_SIZE, 0)\n            elif event.key == pygame.K_RIGHT and direction != (-GRID_SIZE, 0):\n                direction = (GRID_SIZE, 0)\n            elif event.key == pygame.K_UP and direction != (0, GRID_SIZE):\n                direction = (0, -GRID_SIZE)\n            elif event.key == pygame.K_DOWN and direction != (0, -GRID_SIZE):\n                direction = (0, GRID_SIZE)\n\n    if not game_over:\n        # 计算新头部位置\n        new_head = (snake[0][0] + direction[0], snake[0][1] + direction[1])\n\n        # 边界检测\n        if new_head[0] < 0 or new_head[0] >= 800 or new_head[1] < 0 or new_head[1] >= 600:\n            game_over = True\n\n        # 自身碰撞检测\n        if new_head in snake:\n            game_over = True\n\n        if not game_over:\n            snake.insert(0, new_head)\n\n            # 吃到食物\n            if new_head == food:\n                score += 10\n                food = (random.randint(0, 39) * GRID_SIZE, random.randint(0, 29) * GRID_SIZE)\n            else:\n                snake.pop()  # 没吃到就删除尾部\n\n    # 绘制\n    screen.fill((0, 0, 0))\n\n    # 绘制食物\n    pygame.draw.rect(screen, (255, 0, 0), (food[0], food[1], GRID_SIZE-2, GRID_SIZE-2))\n\n    # 绘制蛇\n    for i, segment in enumerate(snake):\n        color = (0, 255, 0) if i == 0 else (0, 200, 0)  # 头部亮一点\n        pygame.draw.rect(screen, color, (segment[0], segment[1], GRID_SIZE-2, GRID_SIZE-2))\n\n    pygame.display.flip()\n    pygame.time.delay(100)  # 控制蛇的速度\n\npygame.quit()\n```\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 蛇移动太快 | 增加delay | 把100改成150或200 |\n| 想加障碍物 | 添加墙壁列表 | 碰到墙壁也游戏结束 |\n| 想显示分数 | 用font渲染 | 在屏幕上显示当前分数 |\n\n**禁忌提醒**\n❌ 允许180度转向——蛇会撞到自己\n❌ 食物生成在蛇身上——需要检测避免\n\n---\n\n**核心知识点**\n- 列表作为数据结构：存储蛇身坐标\n- insert()和pop()：实现蛇的移动\n- 方向控制：防止180度转向\n\n**底层逻辑**\n- **队列思想**：头部入队，尾部出队\n- **状态管理**：用变量控制游戏状态\n\n`#执行层` `#测评项`\n[UID: PYAI-22-08-001]\n\n---\n\n### 2-2-9 举重若轻1\n\n#### 课程基本信息\n\n| 项目 | 内容 |\n|------|------|\n| **课程编号** | 2-2-9 |\n| **课程名称** | 举重若轻1 |\n| **认知负荷** | 高 |\n| **核心技能** | 图像导入变换、能量值变化、游戏环节控制 |\n\n#### 详细教学流程\n\n**步骤1：知识讲解（20分钟）** `#中负荷-操练` `#IFC-即时`\n\n**教师话术**\n> \"今天开始做一个**大炮射击**游戏！这是一个三节课的大项目，我们会学到图像处理、物理运动、音效等很多知识。\"\n>\n> \"**Pygame图像加载**：\n> ```python\n> import pygame\n>\n> # 加载图像\n> cannon_img = pygame.image.load('cannon.png')\n>\n> # 缩放图像\n> cannon_img = pygame.transform.scale(cannon_img, (100, 50))\n>\n> # 旋转图像（角度，逆时针为正）\n> rotated = pygame.transform.rotate(cannon_img, 45)\n>\n> # 绘制到屏幕\n> screen.blit(cannon_img, (x, y))\n> ```\n>\n> **能量条设计**：\n> - 按住空格键蓄力，能量值增加\n> - 松开空格键发射，能量值决定初速度\"\n\n**核心代码模式**\n\n```python\nimport pygame\n\npygame.init()\nscreen = pygame.display.set_mode((800, 600))\n\n# 加载图像\ncannon_img = pygame.image.load('cannon.png')\ncannon_img = pygame.transform.scale(cannon_img, (80, 40))\n\n# 大炮位置和角度\ncannon_x, cannon_y = 50, 500\ncannon_angle = 45\n\n# 能量系统\nenergy = 0\nmax_energy = 100\ncharging = False\n\nrunning = True\nwhile running:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            running = False\n        if event.type == pygame.KEYDOWN:\n            if event.key == pygame.K_SPACE:\n                charging = True\n        if event.type == pygame.KEYUP:\n            if event.key == pygame.K_SPACE:\n                charging = False\n                # 发射炮弹（下节课实现）\n                print(f'发射！能量：{energy}')\n                energy = 0\n\n    # 蓄力\n    if charging and energy < max_energy:\n        energy += 2\n\n    # 角度控制\n    keys = pygame.key.get_pressed()\n    if keys[pygame.K_UP] and cannon_angle < 80:\n        cannon_angle += 1\n    if keys[pygame.K_DOWN] and cannon_angle > 10:\n        cannon_angle -= 1\n\n    screen.fill((135, 206, 235))  # 天蓝色背景\n\n    # 绘制大炮（旋转）\n    rotated_cannon = pygame.transform.rotate(cannon_img, cannon_angle)\n    screen.blit(rotated_cannon, (cannon_x, cannon_y - cannon_angle))\n\n    # 绘制能量条\n    pygame.draw.rect(screen, (100, 100, 100), (20, 20, 104, 24))  # 边框\n    pygame.draw.rect(screen, (0, 255, 0), (22, 22, energy, 20))   # 能量\n\n    pygame.display.flip()\n    pygame.time.delay(16)\n\npygame.quit()\n```\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 图像加载失败 | 检查路径 | 确认图片文件在正确位置 |\n| 旋转后图像变形 | 解释原理 | 旋转会改变图像尺寸，需要调整位置 |\n| 能量条不显示 | 检查坐标 | 确认绘制位置在屏幕范围内 |\n\n**禁忌提醒**\n❌ 图像路径错误——FileNotFoundError\n❌ 忘记convert()——大图像可能卡顿\n\n---\n\n**核心知识点**\n- 图像加载：`pygame.image.load()`\n- 图像变换：`pygame.transform.scale()` / `rotate()`\n- 能量系统：按键蓄力、松开释放\n- 游戏状态：用变量控制不同阶段\n\n`#执行层` `#测评项`\n[UID: PYAI-22-09-001]\n\n---\n\n### 2-2-10 举重若轻2\n\n#### 课程基本信息\n\n| 项目 | 内容 |\n|------|------|\n| **课程编号** | 2-2-10 |\n| **课程名称** | 举重若轻2 |\n| **认知负荷** | 高 |\n| **核心技能** | 物理运动原理、加速度、速度合并 |\n\n#### 详细教学流程\n\n**步骤1：知识讲解（20分钟）** `#中负荷-操练` `#IFC-即时`\n\n**教师话术**\n> \"今天我们要让炮弹'飞'起来！这需要用到**物理学**的知识。\"\n>\n> \"**抛物线运动**：\n> - 水平方向：匀速运动，vx不变\n> - 垂直方向：受重力影响，vy不断增加\n>\n> ```python\n> # 物理参数\n> gravity = 0.5  # 重力加速度\n> vx = 10        # 水平速度（不变）\n> vy = -15       # 垂直速度（负数表示向上）\n>\n> # 每帧更新\n> x += vx        # 水平位移\n> vy += gravity  # 垂直速度增加（重力）\n> y += vy        # 垂直位移\n> ```\n>\n> **速度分解**：\n> - 初速度v和角度θ\n> - vx = v × cos(θ)\n> - vy = v × sin(θ)（向上为负）\"\n\n**核心代码模式**\n\n```python\nimport pygame\nimport math\n\npygame.init()\nscreen = pygame.display.set_mode((800, 600))\n\n# 物理常量\nGRAVITY = 0.3\n\n# 炮弹类\nclass Bullet:\n    def __init__(self, x, y, speed, angle):\n        self.x = x\n        self.y = y\n        # 速度分解\n        rad = math.radians(angle)\n        self.vx = speed * math.cos(rad)\n        self.vy = -speed * math.sin(rad)  # 向上为负\n        self.active = True\n\n    def update(self):\n        if self.active:\n            self.x += self.vx\n            self.vy += GRAVITY  # 重力作用\n            self.y += self.vy\n\n            # 落地检测\n            if self.y > 550:\n                self.active = False\n\n    def draw(self, screen):\n        if self.active:\n            pygame.draw.circle(screen, (50, 50, 50), (int(self.x), int(self.y)), 8)\n\n# 炮弹列表\nbullets = []\n\n# 发射炮弹\ndef fire(x, y, energy, angle):\n    speed = energy / 5  # 能量转换为速度\n    bullet = Bullet(x, y, speed, angle)\n    bullets.append(bullet)\n\n# 主循环\ncannon_angle = 45\nenergy = 0\ncharging = False\n\nrunning = True\nwhile running:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            running = False\n        if event.type == pygame.KEYDOWN:\n            if event.key == pygame.K_SPACE:\n                charging = True\n        if event.type == pygame.KEYUP:\n            if event.key == pygame.K_SPACE:\n                charging = False\n                fire(80, 480, energy, cannon_angle)\n                energy = 0\n\n    if charging and energy < 100:\n        energy += 2\n\n    keys = pygame.key.get_pressed()\n    if keys[pygame.K_UP]: cannon_angle = min(80, cannon_angle + 1)\n    if keys[pygame.K_DOWN]: cannon_angle = max(10, cannon_angle - 1)\n\n    screen.fill((135, 206, 235))\n\n    # 绘制地面\n    pygame.draw.rect(screen, (34, 139, 34), (0, 550, 800, 50))\n\n    # 更新和绘制炮弹\n    for bullet in bullets:\n        bullet.update()\n        bullet.draw(screen)\n\n    # 清理已落地的炮弹\n    bullets = [b for b in bullets if b.active]\n\n    pygame.display.flip()\n    pygame.time.delay(16)\n\npygame.quit()\n```\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 炮弹飞太快/太慢 | 调整speed计算 | 修改energy/5的系数 |\n| 不理解三角函数 | 画图演示 | 用直角三角形解释sin/cos |\n| 想加风力影响 | 引入wind变量 | vx += wind实现风力效果 |\n\n**禁忌提醒**\n❌ 忘记转换弧度——math.sin/cos需要弧度\n❌ 重力方向错误——向下应该是正值\n\n---\n\n**核心知识点**\n- 抛物线运动：水平匀速 + 垂直加速\n- 速度分解：vx = v×cos(θ), vy = v×sin(θ)\n- 重力模拟：每帧vy += gravity\n- 弧度转换：math.radians(角度)\n\n**底层逻辑**\n- **物理仿真**：用数学公式模拟真实物理\n- **帧更新**：每帧计算新位置\n\n`#执行层` `#测评项`\n[UID: PYAI-22-10-001]\n\n---\n\n### 2-2-11 举重若轻3\n\n#### 课程基本信息\n\n| 项目 | 内容 |\n|------|------|\n| **课程编号** | 2-2-11 |\n| **课程名称** | 举重若轻3 |\n| **认知负荷** | 高 |\n| **核心技能** | 向量拆分合并、爆炸效果、音频加载 |\n\n#### 详细教学流程\n\n**步骤1：知识讲解（20分钟）** `#中负荷-操练` `#IFC-即时`\n\n**教师话术**\n> \"今天是大炮射击的最后一课！我们要加入**目标**、**爆炸效果**和**音效**，让游戏更完整！\"\n>\n> \"**Pygame音频**：\n> ```python\n> import pygame\n>\n> pygame.mixer.init()  # 初始化音频\n>\n> # 加载音效\n> explosion_sound = pygame.mixer.Sound('explosion.wav')\n>\n> # 播放音效\n> explosion_sound.play()\n>\n> # 加载背景音乐\n> pygame.mixer.music.load('bgm.mp3')\n> pygame.mixer.music.play(-1)  # -1表示循环播放\n> ```\n>\n> **爆炸效果**：\n> - 碰撞时创建爆炸粒子\n> - 粒子向四周扩散\n> - 逐渐消失\"\n\n**核心代码模式**\n\n```python\nimport pygame\nimport math\nimport random\n\npygame.init()\npygame.mixer.init()\nscreen = pygame.display.set_mode((800, 600))\n\nGRAVITY = 0.3\n\n# 目标类\nclass Target:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n        self.radius = 25\n        self.alive = True\n\n    def draw(self, screen):\n        if self.alive:\n            pygame.draw.circle(screen, (255, 0, 0), (self.x, self.y), self.radius)\n            pygame.draw.circle(screen, (255, 255, 255), (self.x, self.y), 15)\n            pygame.draw.circle(screen, (255, 0, 0), (self.x, self.y), 5)\n\n# 爆炸粒子类\nclass Particle:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n        angle = random.uniform(0, 2 * math.pi)\n        speed = random.uniform(2, 8)\n        self.vx = speed * math.cos(angle)\n        self.vy = speed * math.sin(angle)\n        self.life = 30  # 生命周期\n        self.color = random.choice([(255,100,0), (255,200,0), (255,50,0)])\n\n    def update(self):\n        self.x += self.vx\n        self.y += self.vy\n        self.vy += 0.1  # 轻微重力\n        self.life -= 1\n\n    def draw(self, screen):\n        if self.life > 0:\n            size = max(1, self.life // 5)\n            pygame.draw.circle(screen, self.color, (int(self.x), int(self.y)), size)\n\n# 炮弹类（简化版）\nclass Bullet:\n    def __init__(self, x, y, speed, angle):\n        self.x, self.y = x, y\n        rad = math.radians(angle)\n        self.vx = speed * math.cos(rad)\n        self.vy = -speed * math.sin(rad)\n        self.active = True\n\n    def update(self):\n        self.x += self.vx\n        self.vy += GRAVITY\n        self.y += self.vy\n        if self.y > 550: self.active = False\n\n    def draw(self, screen):\n        pygame.draw.circle(screen, (50,50,50), (int(self.x), int(self.y)), 8)\n\n# 碰撞检测\ndef check_hit(bullet, target):\n    dist = math.sqrt((bullet.x - target.x)**2 + (bullet.y - target.y)**2)\n    return dist < target.radius + 8\n\n# 创建爆炸\ndef create_explosion(x, y):\n    return [Particle(x, y) for _ in range(20)]\n\n# 游戏对象\ntargets = [Target(600, 500), Target(500, 450), Target(700, 480)]\nbullets = []\nparticles = []\nscore = 0\n\nrunning = True\nwhile running:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            running = False\n        if event.type == pygame.KEYUP:\n            if event.key == pygame.K_SPACE:\n                bullets.append(Bullet(80, 480, 15, 45))\n\n    screen.fill((135, 206, 235))\n    pygame.draw.rect(screen, (34, 139, 34), (0, 550, 800, 50))\n\n    # 更新炮弹\n    for bullet in bullets[:]:\n        bullet.update()\n        bullet.draw(screen)\n\n        # 检测碰撞\n        for target in targets:\n            if target.alive and check_hit(bullet, target):\n                target.alive = False\n                bullet.active = False\n                particles.extend(create_explosion(target.x, target.y))\n                score += 100\n\n    bullets = [b for b in bullets if b.active]\n\n    # 更新粒子\n    for p in particles[:]:\n        p.update()\n        p.draw(screen)\n    particles = [p for p in particles if p.life > 0]\n\n    # 绘制目标\n    for target in targets:\n        target.draw(screen)\n\n    pygame.display.flip()\n    pygame.time.delay(16)\n\npygame.quit()\n```\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 爆炸效果太弱 | 增加粒子数量 | 把20改成50 |\n| 想加音效 | 加载wav文件 | 碰撞时播放explosion_sound.play() |\n| 想加关卡 | 设计关卡系统 | 消灭所有目标后进入下一关 |\n\n**禁忌提醒**\n❌ 音频格式不支持——推荐使用wav或ogg\n❌ 粒子太多导致卡顿——控制粒子数量和生命周期\n\n---\n\n**核心知识点**\n- 音频加载：`pygame.mixer.Sound()` / `pygame.mixer.music`\n- 粒子系统：随机方向、速度、颜色\n- 碰撞响应：检测到碰撞后触发效果\n- 生命周期：粒子逐渐消失\n\n**底层逻辑**\n- **粒子系统**：大量简单对象模拟复杂效果\n- **游戏完整性**：视觉+音效+交互\n\n`#执行层` `#测评项`\n[UID: PYAI-22-11-001]\n\n---\n\n### 2-2-12 阶段复习\n\n#### 课程基本信息\n\n| 项目 | 内容 |\n|------|------|\n| **课程编号** | 2-2-12 |\n| **课程名称** | 阶段复习 |\n| **认知负荷** | 中 |\n| **核心技能** | 综合复习Pygame与OOP |\n\n#### 详细教学流程\n\n**步骤1：知识回顾（30分钟）** `#中负荷-操练` `#IFC-即时`\n\n**教师话术**\n> \"这个单元我们学了很多内容！让我们来回顾一下：\n>\n> **面向对象编程(OOP)**：\n> - class定义类，是模板/蓝图\n> - 实例是根据类创建的具体对象\n> - `__init__`是初始化方法\n> - `self`代表实例本身\n>\n> **Pygame基础**：\n> - `pygame.init()` 初始化\n> - `pygame.display.set_mode()` 创建窗口\n> - 游戏主循环：事件处理 → 更新 → 绘制 → 刷新\n>\n> **图形绘制**：\n> - `pygame.draw.line/rect/circle()`\n> - RGB颜色：(R, G, B)，每个值0-255\n>\n> **图像处理**：\n> - `pygame.image.load()` 加载\n> - `pygame.transform.scale/rotate()` 变换\n>\n> **物理仿真**：\n> - 抛物线：水平匀速 + 垂直加速\n> - 重力：每帧vy += gravity\n> - 碰撞检测：距离 < 半径之和\"\n\n**步骤2：综合练习（40分钟）** `#高负荷-产出` `#IFC-即时`\n\n**教师话术**\n> \"现在来做一个**综合测试**！完成以下任务：\n>\n> 1. 创建一个Ball类，包含位置、速度、颜色属性\n> 2. 让球在屏幕内弹跳（碰到边界反弹）\n> 3. 用键盘控制一个方块，碰到球就得分\n>\n> 这个练习综合了OOP、Pygame绑图、按键控制、碰撞检测！\"\n\n**核心代码模式（参考答案）**\n\n```python\nimport pygame\nimport random\n\npygame.init()\nscreen = pygame.display.set_mode((800, 600))\nfont = pygame.font.Font(None, 48)\n\nclass Ball:\n    def __init__(self):\n        self.x = random.randint(100, 700)\n        self.y = random.randint(100, 500)\n        self.vx = random.choice([-4, -3, 3, 4])\n        self.vy = random.choice([-4, -3, 3, 4])\n        self.radius = 15\n        self.color = (random.randint(50,255), random.randint(50,255), random.randint(50,255))\n\n    def update(self):\n        self.x += self.vx\n        self.y += self.vy\n        # 边界反弹\n        if self.x < self.radius or self.x > 800 - self.radius:\n            self.vx = -self.vx\n        if self.y < self.radius or self.y > 600 - self.radius:\n            self.vy = -self.vy\n\n    def draw(self, screen):\n        pygame.draw.circle(screen, self.color, (int(self.x), int(self.y)), self.radius)\n\n# 玩家方块\nplayer_x, player_y = 400, 300\nplayer_size = 30\nspeed = 5\nscore = 0\n\n# 创建多个球\nballs = [Ball() for _ in range(5)]\n\nrunning = True\nwhile running:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            running = False\n\n    # 键盘控制\n    keys = pygame.key.get_pressed()\n    if keys[pygame.K_LEFT]: player_x -= speed\n    if keys[pygame.K_RIGHT]: player_x += speed\n    if keys[pygame.K_UP]: player_y -= speed\n    if keys[pygame.K_DOWN]: player_y += speed\n\n    # 边界限制\n    player_x = max(0, min(800 - player_size, player_x))\n    player_y = max(0, min(600 - player_size, player_y))\n\n    # 碰撞检测\n    player_center = (player_x + player_size/2, player_y + player_size/2)\n    for ball in balls[:]:\n        dist = ((ball.x - player_center[0])**2 + (ball.y - player_center[1])**2)**0.5\n        if dist < ball.radius + player_size/2:\n            balls.remove(ball)\n            balls.append(Ball())  # 生成新球\n            score += 10\n\n    screen.fill((30, 30, 30))\n\n    # 绘制球\n    for ball in balls:\n        ball.update()\n        ball.draw(screen)\n\n    # 绘制玩家\n    pygame.draw.rect(screen, (0, 255, 0), (player_x, player_y, player_size, player_size))\n\n    # 显示分数\n    text = font.render(f'Score: {score}', True, (255, 255, 255))\n    screen.blit(text, (20, 20))\n\n    pygame.display.flip()\n    pygame.time.delay(16)\n\npygame.quit()\n```\n\n**变体示例**\n\n| 学生情况 | 调整方案 | 说明 |\n|----------|----------|------|\n| 完成太快 | 增加难度 | 球越来越快，或者加入躲避模式 |\n| 有困难 | 简化任务 | 先只做弹跳球，再加玩家控制 |\n| 想做更多 | 鼓励创意 | 加入计时、关卡、音效等 |\n\n---\n\n**步骤3：成果展示（10分钟）** `#低负荷-热身` `#IFC-复盘`\n\n**教师话术**\n> \"谁来展示一下你的作品？说说你用了哪些知识点？\n>\n> 这个单元我们从零开始，学会了用Python做游戏！\n> - 面向对象让代码更有组织\n> - Pygame让我们能画图、放音乐、做交互\n> - 物理仿真让游戏更真实\n>\n> 下个单元我们会学习更多AI相关的内容！\"\n\n---\n\n**核心知识点**\n- OOP综合：类定义、实例创建、方法调用\n- Pygame综合：初始化、主循环、绑图、事件\n- 物理综合：运动、碰撞、反弹\n- 游戏设计：玩家控制、得分系统\n\n**底层逻辑**\n- **知识整合**：将分散的知识点串联成完整项目\n- **能力迁移**：从模仿到独立创作\n\n`#执行层` `#测评项`\n[UID: PYAI-22-12-001]\n\n---\n\n## 教学禁忌清单\n\n| 序号 | 禁忌 | 原因 | 正确做法 |\n|------|------|------|----------|\n| 1 | ❌ **方法定义忘记self** | TypeError错误 | 方法第一个参数必须是self |\n| 2 | ❌ **__init__写成_init_** | 不会自动调用 | 左右各两个下划线 |\n| 3 | ❌ **类名用小写** | 不符合规范 | 使用大驼峰命名法(PascalCase) |\n| 4 | ❌ **遍历列表时直接删除** | 跳过元素 | 用切片复制或倒序遍历 |\n| 5 | ❌ **忘记pygame.display.flip()** | 画面不更新 | 每帧结束必须调用 |\n| 6 | ❌ **角度不转弧度** | 三角函数结果错误 | 使用math.radians()转换 |\n\n`#执行层` `#测评项`\n[UID: PYAI-TABOO-22]\n\n---\n\n## 教学注意事项\n\n| 类别 | 注意事项 |\n|------|----------|\n| **OOP教学** | 用具体类比（模具-饼干、蓝图-房子）帮助理解抽象概念 |\n| **Pygame调试** | 用print()输出变量值，确认逻辑正确 |\n| **物理仿真** | 先画图解释原理，再写代码实现 |\n| **项目管理** | 大项目分步完成，每步都能运行测试 |\n\n---\n\n## 底层教育学原理\n\n| 原理 | 说明 | 在本单元的应用 |\n|------|------|----------------|\n| **面向对象思维** | 用类封装数据和行为 | 弹幕、星星、炮弹都是类的实例 |\n| **物理建模** | 用数学公式模拟真实世界 | 抛物线运动、重力、碰撞 |\n| **项目驱动学习** | 通过完整项目整合知识 | 大炮射击三部曲、贪食蛇 |\n| **螺旋式上升** | 知识点逐步加深 | 从简单绘图到复杂游戏 |\n\n`#执行层` `#测评项`\n[UID: PYAI-THEORY-22]\n\n---\n\n**质量评估**：10/10（原子化萃取版，12节课完整萃取）\n**已补充**：认知负荷标签、IFC标签、变体示例、详细教师话术、核心代码模式\n**课程覆盖**：2-2-1至2-2-12全部12节课\n\n---\n\n**最后更新**：2026-02-09\n"
}