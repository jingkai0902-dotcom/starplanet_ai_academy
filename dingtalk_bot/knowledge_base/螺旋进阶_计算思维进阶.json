{
  "title": "计算思维进阶",
  "source": "C:\\Users\\Frank.J\\starplanet_ai_academy\\知识库\\02_知识点数据库\\螺旋进阶图\\计算思维进阶.md",
  "sections": [
    {
      "title": "什么是计算思维？",
      "content": "计算思维（Computational Thinking）是一种解决问题的思维方式，包含四大核心能力：\n\n```\n┌─────────────────────────────────────────────────────────┐\n│                     计算思维                             │\n├─────────────┬─────────────┬─────────────┬───────────────┤\n│   分解       │  模式识别    │   抽象      │   算法设计    │\n│Decomposition│  Pattern    │ Abstraction │  Algorithm    │\n│             │ Recognition │             │   Design      │\n├─────────────┼─────────────┼─────────────┼───────────────┤\n│ 把大问题    │ 发现规律    │ 提取本质    │ 设计步骤      │\n│ 拆成小问题  │ 找出相似    │ 忽略细节    │ 解决问题      │\n└─────────────┴─────────────┴─────────────┴───────────────┘\n```\n\n---"
    },
    {
      "title": "进阶路线总图",
      "content": "```\n        STEM(3-6岁)      CODE1(6-8岁)     CODE2-3(8-10岁)   PYAI L1(10-12岁)  PYAI L2(12岁+)\n\n分解     任务分步    →    积木拆解    →    模块划分    →    函数分解    →    系统架构\n         ↓                ↓                ↓                ↓                ↓\n        \"先...再...\"    \"分成几部分\"    \"哪些是独立的\"   \"封装成函数\"    \"分层设计\"\n\n模式     观察相似    →    发现重复    →    归纳规律    →    代码复用    →    设计模式\n识别     ↓                ↓                ↓                ↓                ↓\n        \"都是圆的\"      \"每次都这样\"    \"总结公式\"      \"写成函数\"      \"用类封装\"\n\n抽象     忽略细节    →    变量命名    →    参数化      →    接口设计    →    架构抽象\n         ↓                ↓                ↓                ↓                ↓\n        \"都叫车\"        \"用名字代替\"    \"可以改的数\"    \"只看输入输出\"  \"分层解耦\"\n\n算法     顺序思维    →    流程设计    →    优化改进    →    算法实现    →    复杂度分析\n设计     ↓                ↓                ↓                ↓                ↓\n        \"第一步...\"     \"画流程图\"      \"怎么更快\"      \"写出代码\"      \"效率分析\"\n```\n\n---"
    },
    {
      "title": "一、分解能力（Decomposition）",
      "content": "### 1.1 能力定义\n\n将复杂问题拆分成更小、更易管理的子问题。\n\n### 1.2 各阶段表现\n\n| 阶段 | 年龄 | 分解表现 | 典型任务 |\n|------|------|---------|---------|\n| STEM | 3-6岁 | 任务分步 | \"先搭底座，再装轮子\" |\n| CODE1 | 6-8岁 | 积木拆解 | \"移动+转向+移动\" |\n| CODE2-3 | 8-10岁 | 模块划分 | \"玩家、敌人、计分分开做\" |\n| PYAI L1 | 10-12岁 | 函数分解 | \"每个功能写一个函数\" |\n| PYAI L2 | 12岁+ | 系统架构 | \"分成感知层、处理层、执行层\" |\n\n### 1.3 课程出现\n\n| 课程编号 | 课程名称 | 分解能力训练 |\n|----------|---------|-------------|\n| STEM 3-1-01 | 杠杆与平衡 | 搭建步骤分解 |\n| CODE1-3-05 | 画正方形 | 动作序列分解 |\n| CODE1-4-08 | 自制积木 | 代码模块分解 |\n| CODE3-2-08 | 植物大战僵尸 | 游戏系统分解 |\n| PYAI 1-1-1 | 函数定义 | 功能函数分解 |\n| PYAI 2-2-1 | 类与对象 | 面向对象分解 |\n\n### 1.4 分解能力进阶示例\n\n#### STEM阶段：任务分步\n\n```\n搭建一辆小车：\n1. 先搭底盘\n2. 再装轮子\n3. 最后加车身\n\n\"大任务分成小步骤\"\n```\n\n#### CODE1阶段：积木拆解\n\n```scratch\n画正方形 =\n    移动100步 + 右转90度 +\n    移动100步 + 右转90度 +\n    移动100步 + 右转90度 +\n    移动100步 + 右转90度\n\n\"复杂动作分成简单动作\"\n```\n\n#### CODE2-3阶段：模块划分\n\n```scratch\n游戏 = 玩家模块 + 敌人模块 + 计分模块 + 音效模块\n\n玩家模块：移动、攻击、受伤\n敌人模块：生成、移动、攻击\n计分模块：加分、显示、存档\n\n\"系统分成独立模块\"\n```\n\n#### PYAI L1阶段：函数分解\n\n```python\ndef main():\n    init_game()      # 初始化\n    while running:\n        handle_input()   # 处理输入\n        update_state()   # 更新状态\n        render()         # 渲染画面\n    cleanup()        # 清理资源\n\n\"每个功能封装成函数\"\n```\n\n#### PYAI L2阶段：系统架构\n\n```python\n# 三层架构\nclass SensorLayer:      # 感知层\n    def capture(self): pass\n\nclass ProcessLayer:     # 处理层\n    def analyze(self): pass\n\nclass ActionLayer:      # 执行层\n    def execute(self): pass\n\n\"系统分成多个层次\"\n```\n\n### 1.5 教学话术\n\n| 阶段 | 教学话术 |\n|------|---------|\n| STEM | \"我们把这个大任务分成几个小步骤，先做什么，再做什么？\" |\n| CODE1 | \"画正方形需要几个动作？我们一个一个来。\" |\n| CODE2-3 | \"这个游戏有哪些部分？玩家、敌人、计分...我们分开做。\" |\n| PYAI L1 | \"这个功能太复杂了，我们把它拆成几个小函数。\" |\n| PYAI L2 | \"系统太大了，我们分成几个层，每层负责一件事。\" |\n\n---"
    },
    {
      "title": "二、模式识别（Pattern Recognition）",
      "content": "### 2.1 能力定义\n\n发现问题中的规律、相似性和重复模式。\n\n### 2.2 各阶段表现\n\n| 阶段 | 年龄 | 模式识别表现 | 典型任务 |\n|------|------|-------------|---------|\n| STEM | 3-6岁 | 观察相似 | \"这些都是圆形的\" |\n| CODE1 | 6-8岁 | 发现重复 | \"每次都是移动+转向\" |\n| CODE2-3 | 8-10岁 | 归纳规律 | \"敌人都是这样移动的\" |\n| PYAI L1 | 10-12岁 | 代码复用 | \"这段代码可以重复用\" |\n| PYAI L2 | 12岁+ | 设计模式 | \"这是观察者模式\" |\n\n### 2.3 课程出现\n\n| 课程编号 | 课程名称 | 模式识别训练 |\n|----------|---------|-------------|\n| STEM 2-1-03 | 快乐跷跷板 | 平衡规律发现 |\n| CODE1-3-06 | 画多边形 | 重复模式发现 |\n| CODE1-4-02 | 斯斯接苹果 | 游戏规律总结 |\n| CODE3-2-02 | 太空防卫战 | 敌人行为模式 |\n| PYAI 1-1-3 | 棱角分明 | 多边形公式 |\n| PYAI 2-2-2 | 类的继承 | 代码复用模式 |\n\n### 2.4 模式识别进阶示例\n\n#### STEM阶段：观察相似\n\n```\n观察：轮子、硬币、盘子\n发现：它们都是圆形的\n规律：圆形的东西可以滚动\n\n\"找出相同点\"\n```\n\n#### CODE1阶段：发现重复\n\n```scratch\n画正方形：\n    移动 + 转90° → 重复4次\n\n画三角形：\n    移动 + 转120° → 重复3次\n\n画五边形：\n    移动 + 转72° → 重复5次\n\n发现：都是\"移动+转向\"的重复！\n\n\"发现重复的动作\"\n```\n\n#### CODE2-3阶段：归纳规律\n\n```scratch\n敌人行为模式：\n    从顶部出现 → 向下移动 → 碰到底部消失\n\n所有敌人都遵循这个模式！\n\n\"总结出通用规律\"\n```\n\n#### PYAI L1阶段：代码复用\n\n```python\n# 发现：计算距离的代码重复出现\n# 提取成函数复用\n\ndef distance(x1, y1, x2, y2):\n    return ((x2-x1)**2 + (y2-y1)**2) ** 0.5\n\n# 到处都可以用\nd1 = distance(player.x, player.y, enemy.x, enemy.y)\nd2 = distance(bullet.x, bullet.y, target.x, target.y)\n\n\"把重复代码提取成函数\"\n```\n\n#### PYAI L2阶段：设计模式\n\n```python\n# 观察者模式：多个对象需要响应同一个事件\n\nclass EventManager:\n    def __init__(self):\n        self.listeners = []\n\n    def subscribe(self, listener):\n        self.listeners.append(listener)\n\n    def notify(self, event):\n        for listener in self.listeners:\n            listener.on_event(event)\n\n\"识别并应用设计模式\"\n```\n\n### 2.5 教学话术\n\n| 阶段 | 教学话术 |\n|------|---------|\n| STEM | \"这些东西有什么相同的地方？\" |\n| CODE1 | \"你发现了吗？每次都是先移动再转向，重复了好多次！\" |\n| CODE2-3 | \"所有敌人的行为是不是都一样？我们总结一下规律。\" |\n| PYAI L1 | \"这段代码出现了好几次，我们把它提取成函数。\" |\n| PYAI L2 | \"这种情况很常见，有一个设计模式专门解决它。\" |\n\n---"
    },
    {
      "title": "三、抽象能力（Abstraction）",
      "content": "### 3.1 能力定义\n\n提取问题的本质特征，忽略不重要的细节。\n\n### 3.2 各阶段表现\n\n| 阶段 | 年龄 | 抽象表现 | 典型任务 |\n|------|------|---------|---------|\n| STEM | 3-6岁 | 忽略细节 | \"不管颜色，都叫车\" |\n| CODE1 | 6-8岁 | 变量命名 | \"用'得分'代替具体数字\" |\n| CODE2-3 | 8-10岁 | 参数化 | \"边数可以改变\" |\n| PYAI L1 | 10-12岁 | 接口设计 | \"只关心输入输出\" |\n| PYAI L2 | 12岁+ | 架构抽象 | \"分层解耦\" |\n\n### 3.3 课程出现\n\n| 课程编号 | 课程名称 | 抽象能力训练 |\n|----------|---------|-------------|\n| STEM 3-1-02 | 齿轮传动 | 传动原理抽象 |\n| CODE1-3-10 | 变量 | 用名字代替值 |\n| CODE1-4-09 | 带参数积木 | 参数化设计 |\n| CODE3-2-09 | 植物大战僵尸 | 角色抽象 |\n| PYAI 1-1-2 | 函数参数 | 接口抽象 |\n| PYAI 2-2-1 | 类定义 | 对象抽象 |\n\n### 3.4 抽象能力进阶示例\n\n#### STEM阶段：忽略细节\n\n```\n具体：红色小汽车、蓝色大卡车、黄色出租车\n抽象：车（忽略颜色、大小）\n\n具体：苹果、香蕉、橙子\n抽象：水果（忽略具体种类）\n\n\"提取共同特征，忽略差异\"\n```\n\n#### CODE1阶段：变量命名\n\n```scratch\n具体：得了10分、得了20分、得了35分\n抽象：得分（用变量名代替具体数字）\n\n设定 [得分] 为 (0)\n将 [得分] 改变 (10)\n\n\"用名字代替具体的值\"\n```\n\n#### CODE2-3阶段：参数化\n\n```scratch\n具体：画正方形、画三角形、画五边形\n抽象：画多边形(边数)\n\n定义 画多边形 (边数)\n重复 (边数) 次\n    移动 (100) 步\n    右转 ((360) / (边数)) 度\n\n\"把变化的部分变成参数\"\n```\n\n#### PYAI L1阶段：接口设计\n\n```python\n# 具体实现可以不同，但接口一致\n\ndef calculate_area(shape):\n    # 不管是什么形状，都有计算面积的方法\n    return shape.area()\n\nclass Circle:\n    def area(self):\n        return 3.14 * self.r ** 2\n\nclass Rectangle:\n    def area(self):\n        return self.width * self.height\n\n\"只关心能做什么，不关心怎么做\"\n```\n\n#### PYAI L2阶段：架构抽象\n\n```python\n# 抽象的三层架构\n\nclass InputHandler:      # 输入层（抽象）\n    def get_input(self): pass\n\nclass GameLogic:         # 逻辑层（抽象）\n    def update(self): pass\n\nclass Renderer:          # 渲染层（抽象）\n    def draw(self): pass\n\n# 具体实现可以替换，架构不变\n# 键盘输入 → 手柄输入\n# 2D渲染 → 3D渲染\n\n\"分层抽象，解耦依赖\"\n```\n\n### 3.5 教学话术\n\n| 阶段 | 教学话术 |\n|------|---------|\n| STEM | \"不管是什么颜色，它们都是车，对吧？\" |\n| CODE1 | \"我们给这个数字起个名字叫'得分'，以后就用这个名字。\" |\n| CODE2-3 | \"边数可以变，我们把它变成一个参数。\" |\n| PYAI L1 | \"我们只关心这个函数需要什么、返回什么，不管里面怎么实现。\" |\n| PYAI L2 | \"把系统分成几层，每层只负责一件事，互不干扰。\" |\n\n---"
    },
    {
      "title": "四、算法设计（Algorithm Design）",
      "content": "### 4.1 能力定义\n\n设计解决问题的步骤和流程。\n\n### 4.2 各阶段表现\n\n| 阶段 | 年龄 | 算法设计表现 | 典型任务 |\n|------|------|-------------|---------|\n| STEM | 3-6岁 | 顺序思维 | \"第一步...第二步...\" |\n| CODE1 | 6-8岁 | 流程设计 | \"画流程图\" |\n| CODE2-3 | 8-10岁 | 优化改进 | \"怎么让它更快\" |\n| PYAI L1 | 10-12岁 | 算法实现 | \"写出代码\" |\n| PYAI L2 | 12岁+ | 复杂度分析 | \"效率是O(n)\" |\n\n### 4.3 课程出现\n\n| 课程编号 | 课程名称 | 算法设计训练 |\n|----------|---------|-------------|\n| STEM 3-4-03 | 红绿灯 | 顺序控制 |\n| CODE1-3-07 | 条件循环 | 循环算法 |\n| CODE2-3-01 | 猜数游戏 | 二分查找思想 |\n| CODE3-2-08 | 植物大战僵尸 | 游戏AI算法 |\n| PYAI 1-2-1 | 排序算法 | 冒泡/选择排序 |\n| PYAI 2-1-3 | 递归 | 递归算法 |\n\n### 4.4 算法设计进阶示例\n\n#### STEM阶段：顺序思维\n\n```\n红绿灯算法：\n1. 红灯亮 → 等3秒\n2. 红灯灭，绿灯亮 → 等3秒\n3. 绿灯灭，黄灯亮 → 等1秒\n4. 黄灯灭，回到第1步\n\n\"按顺序一步一步来\"\n```\n\n#### CODE1阶段：流程设计\n\n```\n接苹果游戏流程：\n\n开始\n  ↓\n初始化得分=0\n  ↓\n┌→ 苹果从顶部掉落\n│    ↓\n│  玩家移动接苹果\n│    ↓\n│  接到了吗？──是→ 得分+1\n│    │\n│   否\n│    ↓\n│  苹果到底部了吗？──是→ 生命-1\n│    │\n│   否\n│    ↓\n│  生命>0？──否→ 游戏结束\n│    │\n│   是\n└────┘\n\n\"用流程图表示算法\"\n```\n\n#### CODE2-3阶段：优化改进\n\n```scratch\n// 原始算法：逐个检查碰撞\n重复执行\n    对于 [敌人列表] 中的每个敌人\n        如果 <碰到 [子弹]> 那么\n            删除敌人\n\n// 优化算法：只检查附近的敌人\n重复执行\n    对于 [附近敌人] 中的每个敌人\n        如果 <碰到 [子弹]> 那么\n            删除敌人\n\n\"思考怎么让算法更快\"\n```\n\n#### PYAI L1阶段：算法实现\n\n```python\n# 冒泡排序算法\ndef bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    return arr\n\n# 二分查找算法\ndef binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\n\"把算法思想转化为代码\"\n```\n\n#### PYAI L2阶段：复杂度分析\n\n```python\n# 时间复杂度分析\n\n# O(1) - 常数时间\ndef get_first(arr):\n    return arr[0]\n\n# O(n) - 线性时间\ndef find_max(arr):\n    max_val = arr[0]\n    for x in arr:        # 遍历n次\n        if x > max_val:\n            max_val = x\n    return max_val\n\n# O(n²) - 平方时间\ndef bubble_sort(arr):\n    for i in range(n):       # 外层n次\n        for j in range(n):   # 内层n次\n            ...              # 总共n×n次\n\n# O(log n) - 对数时间\ndef binary_search(arr, target):\n    # 每次排除一半，log₂n次就能找到\n\n\"分析算法的效率\"\n```\n\n### 4.5 教学话术\n\n| 阶段 | 教学话术 |\n|------|---------|\n| STEM | \"我们来想想，第一步做什么，第二步做什么？\" |\n| CODE1 | \"我们画个流程图，看看程序是怎么运行的。\" |\n| CODE2-3 | \"现在程序有点慢，你能想到怎么让它更快吗？\" |\n| PYAI L1 | \"这个算法的思路是...现在我们把它写成代码。\" |\n| PYAI L2 | \"这个算法要执行多少次？随着数据变大会怎样？\" |\n\n---"
    },
    {
      "title": "五、四大能力综合应用",
      "content": "### 5.1 解决问题的完整流程\n\n```\n遇到问题\n    ↓\n【分解】把大问题拆成小问题\n    ↓\n【模式识别】找出相似的部分\n    ↓\n【抽象】提取本质，忽略细节\n    ↓\n【算法设计】设计解决步骤\n    ↓\n实现解决方案\n```\n\n### 5.2 综合应用示例：贪食蛇游戏\n\n```\n【分解】\n├── 蛇的移动\n├── 食物生成\n├── 碰撞检测\n└── 计分系统\n\n【模式识别】\n├── 蛇身是一串坐标 → 用列表存储\n├── 每次移动都是\"加头去尾\" → 提取成函数\n└── 碰撞检测都是\"坐标比较\" → 复用代码\n\n【抽象】\n├── 蛇 → Snake类（位置、方向、长度）\n├── 食物 → Food类（位置）\n└── 游戏 → Game类（蛇、食物、得分）\n\n【算法设计】\n├── 移动算法：新头 = 旧头 + 方向\n├── 吃食物：不去尾，蛇变长\n├── 碰撞检测：头在身体列表中？\n└── 游戏循环：输入→更新→渲染\n```\n\n---"
    },
    {
      "title": "六、认知发展对照",
      "content": "### 6.1 皮亚杰认知发展阶段映射\n\n| 认知阶段 | 年龄 | 课程体系 | 计算思维特点 |\n|---------|------|---------|-------------|\n| 前运算期 | 2-7岁 | STEM | 具体操作，直观感知 |\n| 具体运算期 | 7-11岁 | CODE | 逻辑思维，但需具体情境 |\n| 形式运算期 | 11岁+ | PYAI | 抽象思维，假设推理 |\n\n### 6.2 各阶段认知特点与教学策略\n\n| 阶段 | 认知特点 | 教学策略 |\n|------|---------|---------|\n| STEM | 以感知为主，需要具体操作 | 动手搭建，观察现象 |\n| CODE1 | 开始逻辑思维，但需图形化 | 积木编程，可视化 |\n| CODE2-3 | 逻辑思维发展，能处理复杂情境 | 项目驱动，问题解决 |\n| PYAI L1 | 抽象思维萌芽，能理解符号 | 代码编程，概念讲解 |\n| PYAI L2 | 抽象思维成熟，能假设推理 | 算法分析，系统设计 |\n\n---"
    },
    {
      "title": "七、评估标准",
      "content": "### 7.1 分解能力评估\n\n| 等级 | 表现 |\n|------|------|\n| 初级 | 能按提示分步完成任务 |\n| 中级 | 能自主将任务分成2-3步 |\n| 高级 | 能将复杂任务分成多个模块 |\n| 专家 | 能设计系统架构 |\n\n### 7.2 模式识别评估\n\n| 等级 | 表现 |\n|------|------|\n| 初级 | 能发现明显的相似 |\n| 中级 | 能发现重复的代码/动作 |\n| 高级 | 能归纳出通用规律 |\n| 专家 | 能识别并应用设计模式 |\n\n### 7.3 抽象能力评估\n\n| 等级 | 表现 |\n|------|------|\n| 初级 | 能用变量代替具体值 |\n| 中级 | 能设计带参数的函数 |\n| 高级 | 能设计类和接口 |\n| 专家 | 能设计分层架构 |\n\n### 7.4 算法设计评估\n\n| 等级 | 表现 |\n|------|------|\n| 初级 | 能描述解决步骤 |\n| 中级 | 能画流程图 |\n| 高级 | 能实现常见算法 |\n| 专家 | 能分析算法复杂度 |\n\n---"
    },
    {
      "title": "八、教学建议",
      "content": "### 8.1 各能力培养重点\n\n| 能力 | 培养重点 | 常用方法 |\n|------|---------|---------|\n| 分解 | 任务拆解习惯 | 先问\"分成几步\" |\n| 模式识别 | 观察比较习惯 | 先问\"有什么相同\" |\n| 抽象 | 提炼本质习惯 | 先问\"最重要的是什么\" |\n| 算法设计 | 步骤规划习惯 | 先问\"怎么一步步做\" |\n\n### 8.2 常见教学难点\n\n| 难点 | 解决方案 |\n|------|---------|\n| 不会分解 | 提供分解模板，逐步引导 |\n| 找不到模式 | 并排展示相似案例 |\n| 抽象困难 | 从具体到抽象，多举例子 |\n| 算法混乱 | 先画流程图，再写代码 |\n\n---\n\n**维护者**：知识库管理员\n**关联文件**：[螺旋进阶总图.md](螺旋进阶总图.md)、[思维能力进阶.md](思维能力进阶.md)"
    }
  ],
  "full_content": "# 计算思维进阶\n\n> **用途**：计算思维四大核心能力在各课程体系中的螺旋式进阶详解\n> **更新日期**：2026-02-10\n> **数据来源**：萃取报告/CODE/、萃取报告/PythonAI/、萃取报告/STEM/\n\n---\n\n## 什么是计算思维？\n\n计算思维（Computational Thinking）是一种解决问题的思维方式，包含四大核心能力：\n\n```\n┌─────────────────────────────────────────────────────────┐\n│                     计算思维                             │\n├─────────────┬─────────────┬─────────────┬───────────────┤\n│   分解       │  模式识别    │   抽象      │   算法设计    │\n│Decomposition│  Pattern    │ Abstraction │  Algorithm    │\n│             │ Recognition │             │   Design      │\n├─────────────┼─────────────┼─────────────┼───────────────┤\n│ 把大问题    │ 发现规律    │ 提取本质    │ 设计步骤      │\n│ 拆成小问题  │ 找出相似    │ 忽略细节    │ 解决问题      │\n└─────────────┴─────────────┴─────────────┴───────────────┘\n```\n\n---\n\n## 进阶路线总图\n\n```\n        STEM(3-6岁)      CODE1(6-8岁)     CODE2-3(8-10岁)   PYAI L1(10-12岁)  PYAI L2(12岁+)\n\n分解     任务分步    →    积木拆解    →    模块划分    →    函数分解    →    系统架构\n         ↓                ↓                ↓                ↓                ↓\n        \"先...再...\"    \"分成几部分\"    \"哪些是独立的\"   \"封装成函数\"    \"分层设计\"\n\n模式     观察相似    →    发现重复    →    归纳规律    →    代码复用    →    设计模式\n识别     ↓                ↓                ↓                ↓                ↓\n        \"都是圆的\"      \"每次都这样\"    \"总结公式\"      \"写成函数\"      \"用类封装\"\n\n抽象     忽略细节    →    变量命名    →    参数化      →    接口设计    →    架构抽象\n         ↓                ↓                ↓                ↓                ↓\n        \"都叫车\"        \"用名字代替\"    \"可以改的数\"    \"只看输入输出\"  \"分层解耦\"\n\n算法     顺序思维    →    流程设计    →    优化改进    →    算法实现    →    复杂度分析\n设计     ↓                ↓                ↓                ↓                ↓\n        \"第一步...\"     \"画流程图\"      \"怎么更快\"      \"写出代码\"      \"效率分析\"\n```\n\n---\n\n## 一、分解能力（Decomposition）\n\n### 1.1 能力定义\n\n将复杂问题拆分成更小、更易管理的子问题。\n\n### 1.2 各阶段表现\n\n| 阶段 | 年龄 | 分解表现 | 典型任务 |\n|------|------|---------|---------|\n| STEM | 3-6岁 | 任务分步 | \"先搭底座，再装轮子\" |\n| CODE1 | 6-8岁 | 积木拆解 | \"移动+转向+移动\" |\n| CODE2-3 | 8-10岁 | 模块划分 | \"玩家、敌人、计分分开做\" |\n| PYAI L1 | 10-12岁 | 函数分解 | \"每个功能写一个函数\" |\n| PYAI L2 | 12岁+ | 系统架构 | \"分成感知层、处理层、执行层\" |\n\n### 1.3 课程出现\n\n| 课程编号 | 课程名称 | 分解能力训练 |\n|----------|---------|-------------|\n| STEM 3-1-01 | 杠杆与平衡 | 搭建步骤分解 |\n| CODE1-3-05 | 画正方形 | 动作序列分解 |\n| CODE1-4-08 | 自制积木 | 代码模块分解 |\n| CODE3-2-08 | 植物大战僵尸 | 游戏系统分解 |\n| PYAI 1-1-1 | 函数定义 | 功能函数分解 |\n| PYAI 2-2-1 | 类与对象 | 面向对象分解 |\n\n### 1.4 分解能力进阶示例\n\n#### STEM阶段：任务分步\n\n```\n搭建一辆小车：\n1. 先搭底盘\n2. 再装轮子\n3. 最后加车身\n\n\"大任务分成小步骤\"\n```\n\n#### CODE1阶段：积木拆解\n\n```scratch\n画正方形 =\n    移动100步 + 右转90度 +\n    移动100步 + 右转90度 +\n    移动100步 + 右转90度 +\n    移动100步 + 右转90度\n\n\"复杂动作分成简单动作\"\n```\n\n#### CODE2-3阶段：模块划分\n\n```scratch\n游戏 = 玩家模块 + 敌人模块 + 计分模块 + 音效模块\n\n玩家模块：移动、攻击、受伤\n敌人模块：生成、移动、攻击\n计分模块：加分、显示、存档\n\n\"系统分成独立模块\"\n```\n\n#### PYAI L1阶段：函数分解\n\n```python\ndef main():\n    init_game()      # 初始化\n    while running:\n        handle_input()   # 处理输入\n        update_state()   # 更新状态\n        render()         # 渲染画面\n    cleanup()        # 清理资源\n\n\"每个功能封装成函数\"\n```\n\n#### PYAI L2阶段：系统架构\n\n```python\n# 三层架构\nclass SensorLayer:      # 感知层\n    def capture(self): pass\n\nclass ProcessLayer:     # 处理层\n    def analyze(self): pass\n\nclass ActionLayer:      # 执行层\n    def execute(self): pass\n\n\"系统分成多个层次\"\n```\n\n### 1.5 教学话术\n\n| 阶段 | 教学话术 |\n|------|---------|\n| STEM | \"我们把这个大任务分成几个小步骤，先做什么，再做什么？\" |\n| CODE1 | \"画正方形需要几个动作？我们一个一个来。\" |\n| CODE2-3 | \"这个游戏有哪些部分？玩家、敌人、计分...我们分开做。\" |\n| PYAI L1 | \"这个功能太复杂了，我们把它拆成几个小函数。\" |\n| PYAI L2 | \"系统太大了，我们分成几个层，每层负责一件事。\" |\n\n---\n\n## 二、模式识别（Pattern Recognition）\n\n### 2.1 能力定义\n\n发现问题中的规律、相似性和重复模式。\n\n### 2.2 各阶段表现\n\n| 阶段 | 年龄 | 模式识别表现 | 典型任务 |\n|------|------|-------------|---------|\n| STEM | 3-6岁 | 观察相似 | \"这些都是圆形的\" |\n| CODE1 | 6-8岁 | 发现重复 | \"每次都是移动+转向\" |\n| CODE2-3 | 8-10岁 | 归纳规律 | \"敌人都是这样移动的\" |\n| PYAI L1 | 10-12岁 | 代码复用 | \"这段代码可以重复用\" |\n| PYAI L2 | 12岁+ | 设计模式 | \"这是观察者模式\" |\n\n### 2.3 课程出现\n\n| 课程编号 | 课程名称 | 模式识别训练 |\n|----------|---------|-------------|\n| STEM 2-1-03 | 快乐跷跷板 | 平衡规律发现 |\n| CODE1-3-06 | 画多边形 | 重复模式发现 |\n| CODE1-4-02 | 斯斯接苹果 | 游戏规律总结 |\n| CODE3-2-02 | 太空防卫战 | 敌人行为模式 |\n| PYAI 1-1-3 | 棱角分明 | 多边形公式 |\n| PYAI 2-2-2 | 类的继承 | 代码复用模式 |\n\n### 2.4 模式识别进阶示例\n\n#### STEM阶段：观察相似\n\n```\n观察：轮子、硬币、盘子\n发现：它们都是圆形的\n规律：圆形的东西可以滚动\n\n\"找出相同点\"\n```\n\n#### CODE1阶段：发现重复\n\n```scratch\n画正方形：\n    移动 + 转90° → 重复4次\n\n画三角形：\n    移动 + 转120° → 重复3次\n\n画五边形：\n    移动 + 转72° → 重复5次\n\n发现：都是\"移动+转向\"的重复！\n\n\"发现重复的动作\"\n```\n\n#### CODE2-3阶段：归纳规律\n\n```scratch\n敌人行为模式：\n    从顶部出现 → 向下移动 → 碰到底部消失\n\n所有敌人都遵循这个模式！\n\n\"总结出通用规律\"\n```\n\n#### PYAI L1阶段：代码复用\n\n```python\n# 发现：计算距离的代码重复出现\n# 提取成函数复用\n\ndef distance(x1, y1, x2, y2):\n    return ((x2-x1)**2 + (y2-y1)**2) ** 0.5\n\n# 到处都可以用\nd1 = distance(player.x, player.y, enemy.x, enemy.y)\nd2 = distance(bullet.x, bullet.y, target.x, target.y)\n\n\"把重复代码提取成函数\"\n```\n\n#### PYAI L2阶段：设计模式\n\n```python\n# 观察者模式：多个对象需要响应同一个事件\n\nclass EventManager:\n    def __init__(self):\n        self.listeners = []\n\n    def subscribe(self, listener):\n        self.listeners.append(listener)\n\n    def notify(self, event):\n        for listener in self.listeners:\n            listener.on_event(event)\n\n\"识别并应用设计模式\"\n```\n\n### 2.5 教学话术\n\n| 阶段 | 教学话术 |\n|------|---------|\n| STEM | \"这些东西有什么相同的地方？\" |\n| CODE1 | \"你发现了吗？每次都是先移动再转向，重复了好多次！\" |\n| CODE2-3 | \"所有敌人的行为是不是都一样？我们总结一下规律。\" |\n| PYAI L1 | \"这段代码出现了好几次，我们把它提取成函数。\" |\n| PYAI L2 | \"这种情况很常见，有一个设计模式专门解决它。\" |\n\n---\n\n## 三、抽象能力（Abstraction）\n\n### 3.1 能力定义\n\n提取问题的本质特征，忽略不重要的细节。\n\n### 3.2 各阶段表现\n\n| 阶段 | 年龄 | 抽象表现 | 典型任务 |\n|------|------|---------|---------|\n| STEM | 3-6岁 | 忽略细节 | \"不管颜色，都叫车\" |\n| CODE1 | 6-8岁 | 变量命名 | \"用'得分'代替具体数字\" |\n| CODE2-3 | 8-10岁 | 参数化 | \"边数可以改变\" |\n| PYAI L1 | 10-12岁 | 接口设计 | \"只关心输入输出\" |\n| PYAI L2 | 12岁+ | 架构抽象 | \"分层解耦\" |\n\n### 3.3 课程出现\n\n| 课程编号 | 课程名称 | 抽象能力训练 |\n|----------|---------|-------------|\n| STEM 3-1-02 | 齿轮传动 | 传动原理抽象 |\n| CODE1-3-10 | 变量 | 用名字代替值 |\n| CODE1-4-09 | 带参数积木 | 参数化设计 |\n| CODE3-2-09 | 植物大战僵尸 | 角色抽象 |\n| PYAI 1-1-2 | 函数参数 | 接口抽象 |\n| PYAI 2-2-1 | 类定义 | 对象抽象 |\n\n### 3.4 抽象能力进阶示例\n\n#### STEM阶段：忽略细节\n\n```\n具体：红色小汽车、蓝色大卡车、黄色出租车\n抽象：车（忽略颜色、大小）\n\n具体：苹果、香蕉、橙子\n抽象：水果（忽略具体种类）\n\n\"提取共同特征，忽略差异\"\n```\n\n#### CODE1阶段：变量命名\n\n```scratch\n具体：得了10分、得了20分、得了35分\n抽象：得分（用变量名代替具体数字）\n\n设定 [得分] 为 (0)\n将 [得分] 改变 (10)\n\n\"用名字代替具体的值\"\n```\n\n#### CODE2-3阶段：参数化\n\n```scratch\n具体：画正方形、画三角形、画五边形\n抽象：画多边形(边数)\n\n定义 画多边形 (边数)\n重复 (边数) 次\n    移动 (100) 步\n    右转 ((360) / (边数)) 度\n\n\"把变化的部分变成参数\"\n```\n\n#### PYAI L1阶段：接口设计\n\n```python\n# 具体实现可以不同，但接口一致\n\ndef calculate_area(shape):\n    # 不管是什么形状，都有计算面积的方法\n    return shape.area()\n\nclass Circle:\n    def area(self):\n        return 3.14 * self.r ** 2\n\nclass Rectangle:\n    def area(self):\n        return self.width * self.height\n\n\"只关心能做什么，不关心怎么做\"\n```\n\n#### PYAI L2阶段：架构抽象\n\n```python\n# 抽象的三层架构\n\nclass InputHandler:      # 输入层（抽象）\n    def get_input(self): pass\n\nclass GameLogic:         # 逻辑层（抽象）\n    def update(self): pass\n\nclass Renderer:          # 渲染层（抽象）\n    def draw(self): pass\n\n# 具体实现可以替换，架构不变\n# 键盘输入 → 手柄输入\n# 2D渲染 → 3D渲染\n\n\"分层抽象，解耦依赖\"\n```\n\n### 3.5 教学话术\n\n| 阶段 | 教学话术 |\n|------|---------|\n| STEM | \"不管是什么颜色，它们都是车，对吧？\" |\n| CODE1 | \"我们给这个数字起个名字叫'得分'，以后就用这个名字。\" |\n| CODE2-3 | \"边数可以变，我们把它变成一个参数。\" |\n| PYAI L1 | \"我们只关心这个函数需要什么、返回什么，不管里面怎么实现。\" |\n| PYAI L2 | \"把系统分成几层，每层只负责一件事，互不干扰。\" |\n\n---\n\n## 四、算法设计（Algorithm Design）\n\n### 4.1 能力定义\n\n设计解决问题的步骤和流程。\n\n### 4.2 各阶段表现\n\n| 阶段 | 年龄 | 算法设计表现 | 典型任务 |\n|------|------|-------------|---------|\n| STEM | 3-6岁 | 顺序思维 | \"第一步...第二步...\" |\n| CODE1 | 6-8岁 | 流程设计 | \"画流程图\" |\n| CODE2-3 | 8-10岁 | 优化改进 | \"怎么让它更快\" |\n| PYAI L1 | 10-12岁 | 算法实现 | \"写出代码\" |\n| PYAI L2 | 12岁+ | 复杂度分析 | \"效率是O(n)\" |\n\n### 4.3 课程出现\n\n| 课程编号 | 课程名称 | 算法设计训练 |\n|----------|---------|-------------|\n| STEM 3-4-03 | 红绿灯 | 顺序控制 |\n| CODE1-3-07 | 条件循环 | 循环算法 |\n| CODE2-3-01 | 猜数游戏 | 二分查找思想 |\n| CODE3-2-08 | 植物大战僵尸 | 游戏AI算法 |\n| PYAI 1-2-1 | 排序算法 | 冒泡/选择排序 |\n| PYAI 2-1-3 | 递归 | 递归算法 |\n\n### 4.4 算法设计进阶示例\n\n#### STEM阶段：顺序思维\n\n```\n红绿灯算法：\n1. 红灯亮 → 等3秒\n2. 红灯灭，绿灯亮 → 等3秒\n3. 绿灯灭，黄灯亮 → 等1秒\n4. 黄灯灭，回到第1步\n\n\"按顺序一步一步来\"\n```\n\n#### CODE1阶段：流程设计\n\n```\n接苹果游戏流程：\n\n开始\n  ↓\n初始化得分=0\n  ↓\n┌→ 苹果从顶部掉落\n│    ↓\n│  玩家移动接苹果\n│    ↓\n│  接到了吗？──是→ 得分+1\n│    │\n│   否\n│    ↓\n│  苹果到底部了吗？──是→ 生命-1\n│    │\n│   否\n│    ↓\n│  生命>0？──否→ 游戏结束\n│    │\n│   是\n└────┘\n\n\"用流程图表示算法\"\n```\n\n#### CODE2-3阶段：优化改进\n\n```scratch\n// 原始算法：逐个检查碰撞\n重复执行\n    对于 [敌人列表] 中的每个敌人\n        如果 <碰到 [子弹]> 那么\n            删除敌人\n\n// 优化算法：只检查附近的敌人\n重复执行\n    对于 [附近敌人] 中的每个敌人\n        如果 <碰到 [子弹]> 那么\n            删除敌人\n\n\"思考怎么让算法更快\"\n```\n\n#### PYAI L1阶段：算法实现\n\n```python\n# 冒泡排序算法\ndef bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    return arr\n\n# 二分查找算法\ndef binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\n\"把算法思想转化为代码\"\n```\n\n#### PYAI L2阶段：复杂度分析\n\n```python\n# 时间复杂度分析\n\n# O(1) - 常数时间\ndef get_first(arr):\n    return arr[0]\n\n# O(n) - 线性时间\ndef find_max(arr):\n    max_val = arr[0]\n    for x in arr:        # 遍历n次\n        if x > max_val:\n            max_val = x\n    return max_val\n\n# O(n²) - 平方时间\ndef bubble_sort(arr):\n    for i in range(n):       # 外层n次\n        for j in range(n):   # 内层n次\n            ...              # 总共n×n次\n\n# O(log n) - 对数时间\ndef binary_search(arr, target):\n    # 每次排除一半，log₂n次就能找到\n\n\"分析算法的效率\"\n```\n\n### 4.5 教学话术\n\n| 阶段 | 教学话术 |\n|------|---------|\n| STEM | \"我们来想想，第一步做什么，第二步做什么？\" |\n| CODE1 | \"我们画个流程图，看看程序是怎么运行的。\" |\n| CODE2-3 | \"现在程序有点慢，你能想到怎么让它更快吗？\" |\n| PYAI L1 | \"这个算法的思路是...现在我们把它写成代码。\" |\n| PYAI L2 | \"这个算法要执行多少次？随着数据变大会怎样？\" |\n\n---\n\n## 五、四大能力综合应用\n\n### 5.1 解决问题的完整流程\n\n```\n遇到问题\n    ↓\n【分解】把大问题拆成小问题\n    ↓\n【模式识别】找出相似的部分\n    ↓\n【抽象】提取本质，忽略细节\n    ↓\n【算法设计】设计解决步骤\n    ↓\n实现解决方案\n```\n\n### 5.2 综合应用示例：贪食蛇游戏\n\n```\n【分解】\n├── 蛇的移动\n├── 食物生成\n├── 碰撞检测\n└── 计分系统\n\n【模式识别】\n├── 蛇身是一串坐标 → 用列表存储\n├── 每次移动都是\"加头去尾\" → 提取成函数\n└── 碰撞检测都是\"坐标比较\" → 复用代码\n\n【抽象】\n├── 蛇 → Snake类（位置、方向、长度）\n├── 食物 → Food类（位置）\n└── 游戏 → Game类（蛇、食物、得分）\n\n【算法设计】\n├── 移动算法：新头 = 旧头 + 方向\n├── 吃食物：不去尾，蛇变长\n├── 碰撞检测：头在身体列表中？\n└── 游戏循环：输入→更新→渲染\n```\n\n---\n\n## 六、认知发展对照\n\n### 6.1 皮亚杰认知发展阶段映射\n\n| 认知阶段 | 年龄 | 课程体系 | 计算思维特点 |\n|---------|------|---------|-------------|\n| 前运算期 | 2-7岁 | STEM | 具体操作，直观感知 |\n| 具体运算期 | 7-11岁 | CODE | 逻辑思维，但需具体情境 |\n| 形式运算期 | 11岁+ | PYAI | 抽象思维，假设推理 |\n\n### 6.2 各阶段认知特点与教学策略\n\n| 阶段 | 认知特点 | 教学策略 |\n|------|---------|---------|\n| STEM | 以感知为主，需要具体操作 | 动手搭建，观察现象 |\n| CODE1 | 开始逻辑思维，但需图形化 | 积木编程，可视化 |\n| CODE2-3 | 逻辑思维发展，能处理复杂情境 | 项目驱动，问题解决 |\n| PYAI L1 | 抽象思维萌芽，能理解符号 | 代码编程，概念讲解 |\n| PYAI L2 | 抽象思维成熟，能假设推理 | 算法分析，系统设计 |\n\n---\n\n## 七、评估标准\n\n### 7.1 分解能力评估\n\n| 等级 | 表现 |\n|------|------|\n| 初级 | 能按提示分步完成任务 |\n| 中级 | 能自主将任务分成2-3步 |\n| 高级 | 能将复杂任务分成多个模块 |\n| 专家 | 能设计系统架构 |\n\n### 7.2 模式识别评估\n\n| 等级 | 表现 |\n|------|------|\n| 初级 | 能发现明显的相似 |\n| 中级 | 能发现重复的代码/动作 |\n| 高级 | 能归纳出通用规律 |\n| 专家 | 能识别并应用设计模式 |\n\n### 7.3 抽象能力评估\n\n| 等级 | 表现 |\n|------|------|\n| 初级 | 能用变量代替具体值 |\n| 中级 | 能设计带参数的函数 |\n| 高级 | 能设计类和接口 |\n| 专家 | 能设计分层架构 |\n\n### 7.4 算法设计评估\n\n| 等级 | 表现 |\n|------|------|\n| 初级 | 能描述解决步骤 |\n| 中级 | 能画流程图 |\n| 高级 | 能实现常见算法 |\n| 专家 | 能分析算法复杂度 |\n\n---\n\n## 八、教学建议\n\n### 8.1 各能力培养重点\n\n| 能力 | 培养重点 | 常用方法 |\n|------|---------|---------|\n| 分解 | 任务拆解习惯 | 先问\"分成几步\" |\n| 模式识别 | 观察比较习惯 | 先问\"有什么相同\" |\n| 抽象 | 提炼本质习惯 | 先问\"最重要的是什么\" |\n| 算法设计 | 步骤规划习惯 | 先问\"怎么一步步做\" |\n\n### 8.2 常见教学难点\n\n| 难点 | 解决方案 |\n|------|---------|\n| 不会分解 | 提供分解模板，逐步引导 |\n| 找不到模式 | 并排展示相似案例 |\n| 抽象困难 | 从具体到抽象，多举例子 |\n| 算法混乱 | 先画流程图，再写代码 |\n\n---\n\n**维护者**：知识库管理员\n**关联文件**：[螺旋进阶总图.md](螺旋进阶总图.md)、[思维能力进阶.md](思维能力进阶.md)\n"
}