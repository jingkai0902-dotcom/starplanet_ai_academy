# 人脸识别

> **用途**：人脸检测与识别技术在各课程中的应用详解
> **更新日期**：2026-02-10
> **数据来源**：萃取报告/PythonAI/

---

## 一、技术概述

### 1.1 人脸识别流程

```
图像采集 → 人脸检测 → 特征提取 → 特征匹配 → 身份确认
```

### 1.2 跨课程出现

| 课程编号 | 课程名称 | 具体内容 |
|----------|---------|---------|
| PYAI 1-4-6 | 智能门禁(1) | 人脸捕捉 |
| PYAI 1-4-7 | 智能门禁(2) | 人脸比对 |
| PYAI 1-4-8 | 智能门禁(3) | 刷脸开门 |
| PYAI 2-3-1 | 眼控开关 | FaceMesh |

---

## 二、MediaPipe FaceMesh

### 2.1 简介

MediaPipe FaceMesh 可以检测468个面部关键点，用于表情识别、眨眼检测等。

### 2.2 安装

```bash
pip install mediapipe
```

### 2.3 基本使用

```python
import cv2
import mediapipe as mp

# 初始化
mp_face_mesh = mp.solutions.face_mesh
face_mesh = mp_face_mesh.FaceMesh(
    max_num_faces=1,
    refine_landmarks=True,
    min_detection_confidence=0.5,
    min_tracking_confidence=0.5
)

# 绘制工具
mp_drawing = mp.solutions.drawing_utils
mp_drawing_styles = mp.solutions.drawing_styles

cap = cv2.VideoCapture(0)

while True:
    ret, frame = cap.read()
    if not ret:
        break

    # 转换颜色空间（重要！）
    rgb_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)

    # 检测人脸
    results = face_mesh.process(rgb_frame)

    if results.multi_face_landmarks:
        for face_landmarks in results.multi_face_landmarks:
            # 绘制关键点
            mp_drawing.draw_landmarks(
                frame,
                face_landmarks,
                mp_face_mesh.FACEMESH_TESSELATION,
                landmark_drawing_spec=None,
                connection_drawing_spec=mp_drawing_styles.get_default_face_mesh_tesselation_style()
            )

    cv2.imshow('FaceMesh', frame)
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

cap.release()
cv2.destroyAllWindows()
```

### 2.4 获取关键点坐标

```python
if results.multi_face_landmarks:
    landmarks = results.multi_face_landmarks[0].landmark

    # 获取特定关键点
    h, w, c = frame.shape
    point = landmarks[0]  # 第0个关键点
    x = int(point.x * w)
    y = int(point.y * h)
    z = point.z  # 深度（相对值）
```

---

## 三、关键点索引

### 3.1 眼睛关键点

```
左眼：
  - 上眼皮: 159
  - 下眼皮: 145
  - 左眼角: 33
  - 右眼角: 133

右眼：
  - 上眼皮: 386
  - 下眼皮: 374
  - 左眼角: 362
  - 右眼角: 263
```

### 3.2 嘴巴关键点

```
嘴巴：
  - 上嘴唇中心: 13
  - 下嘴唇中心: 14
  - 左嘴角: 61
  - 右嘴角: 291
```

### 3.3 其他关键点

```
鼻尖: 1
下巴: 152
左眉: 70
右眉: 300
```

---

## 四、眨眼检测

### 4.1 原理

通过计算上下眼皮的距离判断眼睛开合状态。

### 4.2 跨课程出现

| 课程编号 | 课程名称 | 具体内容 |
|----------|---------|---------|
| PYAI 2-3-1 | 眼控开关 | 眨眼检测基础 |
| PYAI 2-3-2 | 眼控开关 | 状态机设计 |

### 4.3 实现代码

```python
def get_eye_aspect_ratio(landmarks, eye_indices):
    """计算眼睛纵横比（EAR）"""
    # 垂直距离
    v1 = abs(landmarks[eye_indices[1]].y - landmarks[eye_indices[5]].y)
    v2 = abs(landmarks[eye_indices[2]].y - landmarks[eye_indices[4]].y)
    # 水平距离
    h = abs(landmarks[eye_indices[0]].x - landmarks[eye_indices[3]].x)
    # EAR
    ear = (v1 + v2) / (2.0 * h)
    return ear

# 左眼关键点索引
LEFT_EYE = [33, 160, 158, 133, 153, 144]
# 右眼关键点索引
RIGHT_EYE = [362, 385, 387, 263, 373, 380]

# 简化版：只用上下眼皮
def is_eye_closed(landmarks, threshold=0.02):
    """检测眼睛是否闭合"""
    # 左眼
    left_dist = abs(landmarks[159].y - landmarks[145].y)
    # 右眼
    right_dist = abs(landmarks[386].y - landmarks[374].y)
    # 平均
    avg_dist = (left_dist + right_dist) / 2
    return avg_dist < threshold
```

### 4.4 眨眼计数

```python
class BlinkCounter:
    def __init__(self, threshold=0.02):
        self.threshold = threshold
        self.blink_count = 0
        self.eye_closed = False

    def update(self, landmarks):
        """更新眨眼状态"""
        closed = is_eye_closed(landmarks, self.threshold)

        if closed and not self.eye_closed:
            # 眼睛刚闭上
            self.eye_closed = True
        elif not closed and self.eye_closed:
            # 眼睛刚睁开 = 完成一次眨眼
            self.eye_closed = False
            self.blink_count += 1

        return self.blink_count
```

---

## 五、表情识别

### 5.1 微笑检测

```python
def detect_smile(landmarks, threshold=0.01):
    """检测微笑"""
    # 嘴角位置
    left_corner = landmarks[61]
    right_corner = landmarks[291]
    mouth_center = landmarks[13]

    # 嘴角上扬程度
    left_lift = mouth_center.y - left_corner.y
    right_lift = mouth_center.y - right_corner.y

    # 判断是否微笑
    if left_lift > threshold and right_lift > threshold:
        intensity = (left_lift + right_lift) / 2
        return True, intensity
    return False, 0
```

### 5.2 张嘴检测

```python
def detect_mouth_open(landmarks, threshold=0.05):
    """检测张嘴"""
    upper_lip = landmarks[13]
    lower_lip = landmarks[14]

    mouth_open = abs(upper_lip.y - lower_lip.y)
    return mouth_open > threshold, mouth_open
```

### 5.3 跨课程出现

| 课程编号 | 课程名称 | 具体内容 |
|----------|---------|---------|
| PYAI 2-3-5 | 表情音乐播放器 | 微笑/张嘴检测 |
| PYAI 2-3-6 | 表情仪表盘 | 表情强度计算 |

---

## 六、人脸比对

### 6.1 模板匹配方法

```python
import cv2

def compare_faces(template_path, current_frame):
    """简单的人脸比对（模板匹配）"""
    # 读取模板
    template = cv2.imread(template_path, cv2.IMREAD_GRAYSCALE)
    if template is None:
        return False, 0

    # 当前帧转灰度
    gray = cv2.cvtColor(current_frame, cv2.COLOR_BGR2GRAY)

    # 模板匹配
    result = cv2.matchTemplate(gray, template, cv2.TM_CCOEFF_NORMED)

    # 获取最大匹配值
    min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)

    # 判断是否匹配
    threshold = 0.7
    return max_val > threshold, max_val
```

### 6.2 跨课程出现

| 课程编号 | 课程名称 | 具体内容 |
|----------|---------|---------|
| PYAI 1-4-7 | 智能门禁(2) | 人脸比对算法 |

---

## 七、完整项目：刷脸开门

### 7.1 系统架构

```
摄像头 → 人脸检测 → 人脸比对 → 舵机控制
                              ↓
                         开门/拒绝
```

### 7.2 核心代码

```python
import cv2
import mediapipe as mp
# from servo import Servo  # 假设有舵机控制模块

class FaceDoorSystem:
    def __init__(self, registered_face_path):
        self.template = cv2.imread(registered_face_path, cv2.IMREAD_GRAYSCALE)
        self.mp_face = mp.solutions.face_detection
        self.face_detection = self.mp_face.FaceDetection(min_detection_confidence=0.5)
        # self.servo = Servo(pin=9)

    def detect_and_verify(self, frame):
        """检测并验证人脸"""
        # 检测人脸
        rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        results = self.face_detection.process(rgb)

        if not results.detections:
            return False, "未检测到人脸"

        # 提取人脸区域
        detection = results.detections[0]
        bbox = detection.location_data.relative_bounding_box
        h, w, _ = frame.shape
        x = int(bbox.xmin * w)
        y = int(bbox.ymin * h)
        face_w = int(bbox.width * w)
        face_h = int(bbox.height * h)

        face_roi = frame[y:y+face_h, x:x+face_w]
        if face_roi.size == 0:
            return False, "人脸区域无效"

        # 比对
        gray_face = cv2.cvtColor(face_roi, cv2.COLOR_BGR2GRAY)
        gray_face = cv2.resize(gray_face, self.template.shape[::-1])

        result = cv2.matchTemplate(gray_face, self.template, cv2.TM_CCOEFF_NORMED)
        _, max_val, _, _ = cv2.minMaxLoc(result)

        if max_val > 0.6:
            # self.servo.write_angle(90)  # 开门
            return True, f"验证通过 ({max_val:.2f})"
        else:
            return False, f"验证失败 ({max_val:.2f})"
```

### 7.3 跨课程出现

| 课程编号 | 课程名称 | 具体内容 |
|----------|---------|---------|
| PYAI 1-4-8 | 智能门禁(3) | 完整系统集成 |

---

## 八、常见错误与禁忌

| 错误 | 后果 | 正确做法 |
|------|------|---------|
| ❌ BGR直接传给MediaPipe | 检测失败 | 先转换为RGB |
| ❌ 不检查检测结果 | 程序崩溃 | 检查`results.multi_face_landmarks` |
| ❌ 阈值设置不当 | 误判 | 根据实际环境调整 |
| ❌ 光照条件差 | 检测不稳定 | 确保充足均匀的光照 |

---

## 九、教学建议

### 9.1 认知进阶路线

```
PYAI 1-4-6          PYAI 2-3-1          PYAI 2-3-5          PYAI 1-4-8
人脸捕捉     →      关键点检测   →      表情识别     →      系统集成
   ↓                   ↓                   ↓                   ↓
 摄像头基础          FaceMesh            特征计算            AI+硬件
```

### 9.2 常见教学难点

| 难点 | 解决方案 |
|------|---------|
| 关键点索引记忆 | 提供关键点图示，只记常用的 |
| 阈值调整 | 让学生实验不同阈值，理解影响 |
| 状态机设计 | 用流程图可视化状态转换 |

---

**维护者**：知识库管理员
**关联文件**：[AI知识总表.md](AI知识总表.md)、[手势识别.md](手势识别.md)
