# 手势识别

> **用途**：手势检测与识别技术在各课程中的应用详解
> **更新日期**：2026-02-10
> **数据来源**：萃取报告/PythonAI/

---

## 一、技术概述

### 1.1 手势识别流程

```
图像采集 → 手部检测 → 关键点提取 → 手势分类 → 指令执行
```

### 1.2 跨课程出现

| 课程编号 | 课程名称 | 具体内容 |
|----------|---------|---------|
| PYAI 2-3-7 | 手势识别基础 | MediaPipe Hands |
| PYAI 2-3-8 | 手势控制游戏 | 手势映射 |
| PYAI 2-3-9 | 手势绘画板 | 指尖追踪 |
| PYAI 2-3-10 | 机械手游戏(1) | 石头剪刀布 |
| PYAI 2-3-11 | 机械手游戏(2) | 策略优化 |

---

## 二、MediaPipe Hands

### 2.1 简介

MediaPipe Hands 可以检测21个手部关键点，支持单手或双手检测，用于手势识别、手语翻译等。

### 2.2 安装

```bash
pip install mediapipe
```

### 2.3 基本使用

```python
import cv2
import mediapipe as mp

# 初始化
mp_hands = mp.solutions.hands
hands = mp_hands.Hands(
    static_image_mode=False,      # 视频模式
    max_num_hands=2,              # 最多检测2只手
    min_detection_confidence=0.7, # 检测置信度
    min_tracking_confidence=0.5   # 追踪置信度
)

# 绘制工具
mp_drawing = mp.solutions.drawing_utils
mp_drawing_styles = mp.solutions.drawing_styles

cap = cv2.VideoCapture(0)

while True:
    ret, frame = cap.read()
    if not ret:
        break

    # 水平翻转（镜像效果）
    frame = cv2.flip(frame, 1)

    # 转换颜色空间（重要！）
    rgb_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)

    # 检测手部
    results = hands.process(rgb_frame)

    if results.multi_hand_landmarks:
        for hand_landmarks in results.multi_hand_landmarks:
            # 绘制关键点和连接线
            mp_drawing.draw_landmarks(
                frame,
                hand_landmarks,
                mp_hands.HAND_CONNECTIONS,
                mp_drawing_styles.get_default_hand_landmarks_style(),
                mp_drawing_styles.get_default_hand_connections_style()
            )

    cv2.imshow('Hand Detection', frame)
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

cap.release()
cv2.destroyAllWindows()
```

### 2.4 获取关键点坐标

```python
if results.multi_hand_landmarks:
    hand_landmarks = results.multi_hand_landmarks[0]
    landmarks = hand_landmarks.landmark

    # 获取特定关键点
    h, w, c = frame.shape
    point = landmarks[8]  # 食指指尖
    x = int(point.x * w)
    y = int(point.y * h)
    z = point.z  # 深度（相对值）
```

---

## 三、手部关键点索引

### 3.1 21个关键点分布

```
        8   12  16  20
        |   |   |   |
    4   7   11  15  19
    |   |   |   |   |
    3   6   10  14  18
    |   |   |   |   |
    2   5   9   13  17
     \   \  |  /   /
      \   \ | /   /
       1----0----
           手腕
```

### 3.2 关键点索引表

| 索引 | 名称 | 说明 |
|------|------|------|
| 0 | WRIST | 手腕 |
| 1 | THUMB_CMC | 拇指根部 |
| 2 | THUMB_MCP | 拇指第一关节 |
| 3 | THUMB_IP | 拇指第二关节 |
| 4 | THUMB_TIP | 拇指指尖 |
| 5 | INDEX_FINGER_MCP | 食指根部 |
| 6 | INDEX_FINGER_PIP | 食指第一关节 |
| 7 | INDEX_FINGER_DIP | 食指第二关节 |
| 8 | INDEX_FINGER_TIP | 食指指尖 |
| 9 | MIDDLE_FINGER_MCP | 中指根部 |
| 10 | MIDDLE_FINGER_PIP | 中指第一关节 |
| 11 | MIDDLE_FINGER_DIP | 中指第二关节 |
| 12 | MIDDLE_FINGER_TIP | 中指指尖 |
| 13 | RING_FINGER_MCP | 无名指根部 |
| 14 | RING_FINGER_PIP | 无名指第一关节 |
| 15 | RING_FINGER_DIP | 无名指第二关节 |
| 16 | RING_FINGER_TIP | 无名指指尖 |
| 17 | PINKY_MCP | 小拇指根部 |
| 18 | PINKY_PIP | 小拇指第一关节 |
| 19 | PINKY_DIP | 小拇指第二关节 |
| 20 | PINKY_TIP | 小拇指指尖 |

### 3.3 常用关键点组

```python
# 指尖索引
FINGER_TIPS = [4, 8, 12, 16, 20]

# 指根索引（MCP关节）
FINGER_MCPS = [1, 5, 9, 13, 17]

# 第二关节索引（PIP关节）
FINGER_PIPS = [2, 6, 10, 14, 18]
```

---

## 四、手指状态检测

### 4.1 原理

通过比较指尖和关节的位置判断手指是否伸直：
- **四指**：指尖y坐标 < 第二关节y坐标 → 伸直
- **拇指**：指尖x坐标与第一关节x坐标比较（需考虑左右手）

### 4.2 跨课程出现

| 课程编号 | 课程名称 | 具体内容 |
|----------|---------|---------|
| PYAI 2-3-7 | 手势识别基础 | 手指状态检测 |
| PYAI 2-3-8 | 手势控制游戏 | 手势分类 |

### 4.3 实现代码

```python
def get_finger_states(landmarks, handedness='Right'):
    """
    检测每根手指是否伸直
    返回: [拇指, 食指, 中指, 无名指, 小拇指] 的状态列表
    1 = 伸直, 0 = 弯曲
    """
    fingers = []

    # 拇指（需要考虑左右手）
    if handedness == 'Right':
        # 右手：指尖x < 第一关节x 表示伸直
        if landmarks[4].x < landmarks[3].x:
            fingers.append(1)
        else:
            fingers.append(0)
    else:
        # 左手：指尖x > 第一关节x 表示伸直
        if landmarks[4].x > landmarks[3].x:
            fingers.append(1)
        else:
            fingers.append(0)

    # 其他四指：指尖y < 第二关节y 表示伸直
    for tip_idx in [8, 12, 16, 20]:
        pip_idx = tip_idx - 2  # 对应的第二关节
        if landmarks[tip_idx].y < landmarks[pip_idx].y:
            fingers.append(1)
        else:
            fingers.append(0)

    return fingers
```

### 4.4 获取手的左右信息

```python
if results.multi_hand_landmarks and results.multi_handedness:
    for hand_landmarks, handedness in zip(
        results.multi_hand_landmarks,
        results.multi_handedness
    ):
        # 获取左右手信息
        hand_label = handedness.classification[0].label  # 'Left' 或 'Right'
        confidence = handedness.classification[0].score

        landmarks = hand_landmarks.landmark
        fingers = get_finger_states(landmarks, hand_label)
```

---

## 五、手势分类

### 5.1 基本手势定义

```python
# 手势映射表
# 格式: (拇指, 食指, 中指, 无名指, 小拇指) -> 手势名称
GESTURE_MAP = {
    (0, 0, 0, 0, 0): 'FIST',      # 握拳
    (1, 1, 1, 1, 1): 'FIVE',      # 张开五指
    (0, 1, 0, 0, 0): 'ONE',       # 数字1
    (0, 1, 1, 0, 0): 'TWO',       # 数字2 / 剪刀
    (0, 1, 1, 1, 0): 'THREE',     # 数字3
    (0, 1, 1, 1, 1): 'FOUR',      # 数字4
    (1, 0, 0, 0, 0): 'THUMB_UP',  # 点赞
    (0, 1, 0, 0, 1): 'ROCK',      # 摇滚手势
    (1, 1, 0, 0, 1): 'CALL',      # 打电话手势
    (0, 0, 0, 0, 1): 'PINKY',     # 小拇指
}

def classify_gesture(finger_states):
    """根据手指状态分类手势"""
    return GESTURE_MAP.get(tuple(finger_states), 'UNKNOWN')
```

### 5.2 石头剪刀布识别

```python
# 石头剪刀布手势
RPS_GESTURES = {
    (0, 0, 0, 0, 0): 'ROCK',      # 石头 = 握拳
    (0, 1, 1, 0, 0): 'SCISSORS',  # 剪刀 = 食指+中指
    (1, 1, 1, 1, 1): 'PAPER',     # 布 = 五指张开
}

def classify_rps(finger_states):
    """识别石头剪刀布手势"""
    return RPS_GESTURES.get(tuple(finger_states), None)
```

### 5.3 跨课程出现

| 课程编号 | 课程名称 | 具体内容 |
|----------|---------|---------|
| PYAI 2-3-10 | 机械手游戏(1) | 石头剪刀布识别 |
| PYAI 2-3-11 | 机械手游戏(2) | 策略优化 |

---

## 六、指尖追踪

### 6.1 基本追踪

```python
def get_fingertip_position(landmarks, frame_shape, finger_idx=8):
    """
    获取指尖在画面中的像素坐标
    finger_idx: 4=拇指, 8=食指, 12=中指, 16=无名指, 20=小拇指
    """
    h, w, c = frame_shape
    tip = landmarks[finger_idx]
    x = int(tip.x * w)
    y = int(tip.y * h)
    return x, y
```

### 6.2 空中绘画

```python
import cv2
import mediapipe as mp
import numpy as np

mp_hands = mp.solutions.hands
hands = mp_hands.Hands(max_num_hands=1, min_detection_confidence=0.7)

cap = cv2.VideoCapture(0)

# 创建画布
canvas = None
prev_x, prev_y = None, None
draw_color = (0, 255, 0)  # 绿色
brush_size = 5

while True:
    ret, frame = cap.read()
    if not ret:
        break

    frame = cv2.flip(frame, 1)
    h, w, c = frame.shape

    # 初始化画布
    if canvas is None:
        canvas = np.zeros((h, w, 3), dtype=np.uint8)

    rgb_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
    results = hands.process(rgb_frame)

    if results.multi_hand_landmarks:
        landmarks = results.multi_hand_landmarks[0].landmark

        # 获取食指指尖位置
        x = int(landmarks[8].x * w)
        y = int(landmarks[8].y * h)

        # 检测是否在绘画模式（食指伸直，其他弯曲）
        fingers = get_finger_states(landmarks)
        if fingers == [0, 1, 0, 0, 0]:  # 只伸食指
            # 绘制轨迹
            if prev_x is not None:
                cv2.line(canvas, (prev_x, prev_y), (x, y), draw_color, brush_size)
            prev_x, prev_y = x, y
        else:
            prev_x, prev_y = None, None

        # 绘制指尖位置
        cv2.circle(frame, (x, y), 10, (255, 0, 0), -1)

    # 合并画布和摄像头画面
    frame = cv2.addWeighted(frame, 1, canvas, 0.5, 0)

    cv2.imshow('Air Drawing', frame)
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

cap.release()
cv2.destroyAllWindows()
```

### 6.3 跨课程出现

| 课程编号 | 课程名称 | 具体内容 |
|----------|---------|---------|
| PYAI 2-3-9 | 手势绘画板 | 空中绘画 |

---

## 七、手势控制应用

### 7.1 手势映射到游戏控制

```python
import pygame

# 手势到按键的映射
GESTURE_TO_KEY = {
    (0, 1, 0, 0, 0): pygame.K_UP,     # 食指 = 上
    (0, 1, 1, 0, 0): pygame.K_DOWN,   # 食指+中指 = 下
    (1, 0, 0, 0, 0): pygame.K_LEFT,   # 拇指 = 左
    (0, 0, 0, 0, 1): pygame.K_RIGHT,  # 小拇指 = 右
    (1, 1, 1, 1, 1): pygame.K_SPACE,  # 五指 = 空格
}

def gesture_to_key(finger_states):
    """将手势转换为按键"""
    return GESTURE_TO_KEY.get(tuple(finger_states), None)
```

### 7.2 手势控制LED

```python
# 假设使用GPIO控制LED
# from gpiozero import LED

def gesture_control_led(finger_states, leds):
    """
    根据手势控制LED
    leds: [led1, led2, led3, led4, led5] 对应五根手指
    """
    for i, state in enumerate(finger_states):
        if state == 1:
            leds[i].on()
        else:
            leds[i].off()
```

### 7.3 跨课程出现

| 课程编号 | 课程名称 | 具体内容 |
|----------|---------|---------|
| PYAI 2-3-8 | 手势控制游戏 | 手势映射控制 |

---

## 八、完整项目：石头剪刀布机器人

### 8.1 系统架构

```
摄像头 → 手势识别 → 游戏逻辑 → 结果显示
                        ↓
                   电脑随机出拳
```

### 8.2 核心代码

```python
import cv2
import mediapipe as mp
import random
import time

class RPSGame:
    def __init__(self):
        self.mp_hands = mp.solutions.hands
        self.hands = self.mp_hands.Hands(
            max_num_hands=1,
            min_detection_confidence=0.7
        )
        self.cap = cv2.VideoCapture(0)

        self.player_score = 0
        self.computer_score = 0
        self.last_play_time = 0
        self.cooldown = 2  # 2秒冷却

    def get_finger_states(self, landmarks):
        """检测手指状态"""
        fingers = []

        # 拇指
        if landmarks[4].x < landmarks[3].x:
            fingers.append(1)
        else:
            fingers.append(0)

        # 其他四指
        for tip_idx in [8, 12, 16, 20]:
            if landmarks[tip_idx].y < landmarks[tip_idx - 2].y:
                fingers.append(1)
            else:
                fingers.append(0)

        return fingers

    def classify_rps(self, fingers):
        """识别石头剪刀布"""
        if fingers == [0, 0, 0, 0, 0]:
            return 'ROCK'
        elif fingers == [0, 1, 1, 0, 0]:
            return 'SCISSORS'
        elif fingers == [1, 1, 1, 1, 1]:
            return 'PAPER'
        return None

    def computer_play(self):
        """电脑随机出拳"""
        return random.choice(['ROCK', 'SCISSORS', 'PAPER'])

    def judge(self, player, computer):
        """判断胜负"""
        if player == computer:
            return 'TIE'
        elif (player == 'ROCK' and computer == 'SCISSORS') or \
             (player == 'SCISSORS' and computer == 'PAPER') or \
             (player == 'PAPER' and computer == 'ROCK'):
            return 'WIN'
        else:
            return 'LOSE'

    def run(self):
        """运行游戏"""
        while True:
            ret, frame = self.cap.read()
            if not ret:
                break

            frame = cv2.flip(frame, 1)
            h, w, c = frame.shape

            rgb_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            results = self.hands.process(rgb_frame)

            current_time = time.time()

            if results.multi_hand_landmarks:
                landmarks = results.multi_hand_landmarks[0].landmark
                fingers = self.get_finger_states(landmarks)
                player_gesture = self.classify_rps(fingers)

                if player_gesture and current_time - self.last_play_time > self.cooldown:
                    computer_gesture = self.computer_play()
                    result = self.judge(player_gesture, computer_gesture)

                    if result == 'WIN':
                        self.player_score += 1
                    elif result == 'LOSE':
                        self.computer_score += 1

                    self.last_play_time = current_time

                    # 显示结果
                    cv2.putText(frame, f"You: {player_gesture}", (10, 50),
                                cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2)
                    cv2.putText(frame, f"Computer: {computer_gesture}", (10, 100),
                                cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 0, 255), 2)
                    cv2.putText(frame, f"Result: {result}", (10, 150),
                                cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 255, 0), 2)

            # 显示分数
            cv2.putText(frame, f"Score - You: {self.player_score} Computer: {self.computer_score}",
                        (10, h - 20), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 255, 255), 2)

            cv2.imshow('Rock Paper Scissors', frame)
            if cv2.waitKey(1) & 0xFF == ord('q'):
                break

        self.cap.release()
        cv2.destroyAllWindows()

# 运行游戏
if __name__ == '__main__':
    game = RPSGame()
    game.run()
```

### 8.3 跨课程出现

| 课程编号 | 课程名称 | 具体内容 |
|----------|---------|---------|
| PYAI 2-3-10 | 机械手游戏(1) | 基础版 |
| PYAI 2-3-11 | 机械手游戏(2) | 策略优化版 |

---

## 九、常见错误与禁忌

| 错误 | 后果 | 正确做法 |
|------|------|---------|
| ❌ BGR直接传给MediaPipe | 检测失败 | 先转换为RGB |
| ❌ 不翻转画面 | 左右颠倒 | 使用`cv2.flip(frame, 1)` |
| ❌ 不区分左右手 | 拇指判断错误 | 检查handedness |
| ❌ 阈值设置不当 | 手势误判 | 根据实际环境调整 |
| ❌ 不处理检测失败 | 程序崩溃 | 检查`results.multi_hand_landmarks` |

---

## 十、教学建议

### 10.1 认知进阶路线

```
PYAI 2-3-7          PYAI 2-3-8          PYAI 2-3-9          PYAI 2-3-10
手部检测     →      手势分类     →      指尖追踪     →      游戏应用
   ↓                   ↓                   ↓                   ↓
 21关键点            手指状态            坐标转换            完整项目
```

### 10.2 常见教学难点

| 难点 | 解决方案 |
|------|---------|
| 关键点索引记忆 | 提供手部关键点图示，只记指尖索引 |
| 左右手判断 | 用镜像翻转简化，或明确说明左右手差异 |
| 手势分类逻辑 | 先从简单手势开始（握拳、张开） |
| 追踪抖动 | 添加平滑滤波或降低灵敏度 |

### 10.3 教学话术

> "手势识别就像教电脑'看手语'。MediaPipe帮我们找到手上的21个关键点，就像在手上贴了21个小标签。通过比较这些标签的位置，我们就能知道哪根手指伸直了、哪根弯曲了。"

---

**维护者**：知识库管理员
**关联文件**：[AI知识总表.md](AI知识总表.md)、[人脸识别.md](人脸识别.md)
