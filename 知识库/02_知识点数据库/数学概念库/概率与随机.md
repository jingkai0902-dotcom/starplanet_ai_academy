# 概率与随机

> **用途**：概率和随机数在各课程中的应用详解
> **更新日期**：2026-02-10
> **数据来源**：萃取报告/CODE/、萃取报告/PythonAI/

---

## 一、随机数基础

### 1.1 基本概念

随机数：在指定范围内随机生成的数值，每次结果不可预测。

### 1.2 跨课程出现

| 课程编号 | 课程名称 | 具体内容 |
|----------|---------|---------|
| CODE1-4-02 | 斯斯接苹果 | 苹果随机位置 |
| CODE3-2-02 | 太空防卫战 | 敌机随机生成 |
| PYAI 2-3-10 | 机械手游戏 | 石头剪刀布 |

### 1.3 Scratch随机数

```scratch
// 生成1到10的随机整数
(随机取数 (1) 到 (10))

// 随机位置
移到 x: (随机取数 (-200) 到 (200)) y: (随机取数 (-150) 到 (150))

// 随机等待
等待 (随机取数 (1) 到 (3)) 秒
```

### 1.4 Python随机数

```python
import random

# 随机整数（包含两端）
num = random.randint(1, 10)  # 1到10

# 随机浮点数
num = random.random()  # 0.0到1.0
num = random.uniform(1.5, 5.5)  # 1.5到5.5

# 随机选择
choice = random.choice(['A', 'B', 'C'])

# 打乱列表
items = [1, 2, 3, 4, 5]
random.shuffle(items)
```

### 1.5 教学话术

> "随机数就像掷骰子，每次结果都不一样。我们可以用它让游戏更有趣——敌人从不同位置出现，道具随机掉落。"

---

## 二、随机位置生成

### 2.1 跨课程出现

| 课程编号 | 课程名称 | 具体内容 |
|----------|---------|---------|
| CODE1-4-02 | 斯斯接苹果 | 苹果从顶部随机位置掉落 |
| CODE3-2-02 | 太空防卫战 | 敌机从顶部随机出现 |
| CODE3-2-09 | 植物大战僵尸 | 僵尸从右侧随机行出现 |

### 2.2 Scratch实现

```scratch
// 苹果从顶部随机位置掉落
当作为克隆体启动时
移到 x: (随机取数 (-200) 到 (200)) y: (180)
重复执行直到 <(y 座标) < (-170)>
    将 y 改变 (-5)
删除此克隆体
```

### 2.3 Python实现

```python
import random

def spawn_enemy(screen_width, screen_height):
    """在屏幕顶部随机位置生成敌人"""
    x = random.randint(50, screen_width - 50)
    y = 0  # 顶部
    return x, y

# 在指定行随机生成（植物大战僵尸）
def spawn_zombie(rows, screen_width):
    """在随机行生成僵尸"""
    row = random.randint(0, rows - 1)
    x = screen_width
    y = row * 80 + 40  # 假设每行80像素
    return x, y, row
```

---

## 三、随机选择

### 3.1 跨课程出现

| 课程编号 | 课程名称 | 具体内容 |
|----------|---------|---------|
| PYAI 2-3-10 | 机械手游戏 | 电脑随机出拳 |
| CODE2-3-01 | 猜数游戏 | 随机生成目标数 |

### 3.2 等概率选择

```python
import random

# 石头剪刀布
choices = ['rock', 'paper', 'scissors']
computer_choice = random.choice(choices)

# 随机颜色
colors = ['red', 'green', 'blue', 'yellow']
color = random.choice(colors)
```

### 3.3 Scratch实现

```scratch
// 随机选择
将 [电脑出拳] 设为 ((列表 [出拳选项] 的第 (随机取数 (1) 到 (3)) 项))
```

---

## 四、权重随机

### 4.1 基本概念

权重随机：不同选项有不同的被选中概率。

### 4.2 跨课程出现

| 课程编号 | 课程名称 | 具体内容 |
|----------|---------|---------|
| PYAI 2-3-11 | 机械手游戏进阶 | 策略性出拳 |
| CODE3-2-03 | 太空防卫战-大招与平衡 | 道具掉落概率 |

### 4.3 Python权重随机

```python
import random

# 使用random.choices()（Python 3.6+）
result = random.choices(
    ['rock', 'paper', 'scissors'],
    weights=[0.5, 0.3, 0.2],  # 50%石头, 30%布, 20%剪刀
    k=1
)[0]

# 道具掉落概率
items = ['金币', '血瓶', '大招', '无']
weights = [0.3, 0.2, 0.05, 0.45]  # 30%金币, 20%血瓶, 5%大招, 45%无
drop = random.choices(items, weights=weights)[0]
```

### 4.4 手动实现权重随机

```python
import random

def weighted_choice(options, weights):
    """手动实现权重随机"""
    total = sum(weights)
    r = random.uniform(0, total)
    cumulative = 0
    for option, weight in zip(options, weights):
        cumulative += weight
        if r <= cumulative:
            return option
    return options[-1]

# 使用
result = weighted_choice(['A', 'B', 'C'], [0.5, 0.3, 0.2])
```

### 4.5 Scratch权重随机

```scratch
// 权重随机实现
将 [随机值] 设为 (随机取数 (1) 到 (100))
如果 <(随机值) < (50)> 那么
    将 [结果] 设为 [石头]  // 50%
否则
    如果 <(随机值) < (80)> 那么
        将 [结果] 设为 [布]  // 30%
    否则
        将 [结果] 设为 [剪刀]  // 20%
```

### 4.6 教学话术

> "普通随机是公平的，每个选项机会一样。但有时候我们想让某些东西更容易出现，比如金币多一点，大招少一点。这就是权重随机——给每个选项设置不同的'重量'。"

---

## 五、随机种子

### 5.1 基本概念

随机种子：控制随机数生成的起始状态，相同种子产生相同的随机序列。

### 5.2 应用场景

- 游戏存档：重现相同的随机事件
- 调试：复现随机相关的bug
- 测试：确保测试结果可重复

### 5.3 Python实现

```python
import random

# 设置随机种子
random.seed(42)

# 之后的随机数序列是固定的
print(random.randint(1, 100))  # 总是82
print(random.randint(1, 100))  # 总是15
print(random.randint(1, 100))  # 总是4

# 重新设置相同种子，序列重复
random.seed(42)
print(random.randint(1, 100))  # 又是82
```

---

## 六、概率计算

### 6.1 基本公式

```
概率 = 有利结果数 / 总结果数
```

### 6.2 跨课程出现

| 课程编号 | 课程名称 | 具体内容 |
|----------|---------|---------|
| PYAI 2-2-5 | 蒙特卡洛法 | 用随机模拟计算π |

### 6.3 蒙特卡洛法计算π

```python
import random

def estimate_pi(num_points):
    """用蒙特卡洛法估算π"""
    inside_circle = 0

    for _ in range(num_points):
        x = random.uniform(-1, 1)
        y = random.uniform(-1, 1)
        if x**2 + y**2 <= 1:
            inside_circle += 1

    # π ≈ 4 × (圆内点数 / 总点数)
    return 4 * inside_circle / num_points

# 点数越多，估算越准确
print(estimate_pi(1000))    # 约3.1
print(estimate_pi(100000))  # 约3.14
print(estimate_pi(1000000)) # 约3.1415
```

### 6.4 教学话术

> "蒙特卡洛法很神奇——我们往正方形里随机撒点，数一数有多少点落在圆里，就能算出π！撒的点越多，算得越准。"

---

## 七、游戏中的随机应用

### 7.1 敌人生成

```python
import random
import time

class EnemySpawner:
    def __init__(self):
        self.last_spawn = time.time()
        self.spawn_interval = 2  # 基础间隔2秒

    def should_spawn(self):
        """判断是否应该生成敌人"""
        now = time.time()
        # 添加随机性：1.5到2.5秒
        interval = self.spawn_interval + random.uniform(-0.5, 0.5)
        if now - self.last_spawn > interval:
            self.last_spawn = now
            return True
        return False
```

### 7.2 道具掉落

```python
def drop_item(enemy_type):
    """敌人死亡时掉落道具"""
    if enemy_type == 'boss':
        # Boss必掉好东西
        items = ['大招', '满血', '金币x10']
        weights = [0.3, 0.3, 0.4]
    else:
        # 普通敌人
        items = ['金币', '血瓶', '无']
        weights = [0.2, 0.1, 0.7]

    return random.choices(items, weights=weights)[0]
```

### 7.3 伤害浮动

```python
def calculate_damage(base_damage):
    """计算带浮动的伤害"""
    # 基础伤害 ± 20%
    min_damage = int(base_damage * 0.8)
    max_damage = int(base_damage * 1.2)
    return random.randint(min_damage, max_damage)

# 示例
damage = calculate_damage(100)  # 80到120之间
```

---

## 八、教学建议

### 8.1 认知进阶路线

```
CODE1-4-02          CODE3-2-02          PYAI 2-3-10          PYAI 2-2-5
基础随机     →      随机生成     →      权重随机     →      概率计算
   ↓                   ↓                   ↓                   ↓
 随机位置            敌人生成            策略设计            蒙特卡洛
```

### 8.2 常见教学难点

| 难点 | 解决方案 |
|------|---------|
| 随机不是"真随机" | 解释伪随机数概念，用种子演示 |
| 权重概念抽象 | 用"抽奖转盘"类比，扇形大小代表概率 |
| 蒙特卡洛法 | 用实物演示：往纸上撒豆子 |

---

**维护者**：知识库管理员
**关联文件**：[数学概念总表.md](数学概念总表.md)
