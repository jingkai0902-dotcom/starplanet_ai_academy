# 算法基础

> **用途**：跨课程算法基础（搜索、排序、递归）详细说明
> **更新日期**：2026-02-10
> **数据来源**：萃取报告/CODE/、萃取报告/PythonAI/
> **整合原则**：基于现有萃取报告，不压缩删减

---

## 一、搜索算法

### 1.1 线性搜索

#### 概念定义
从头到尾依次检查每个元素，直到找到目标或遍历完所有元素。

#### 跨课程出现

| 课程编号 | 课程名称 | 具体内容 |
|----------|---------|---------|
| PYAI 2-1-5 | 线性搜索 | 搜索效率、列表遍历 |

#### Python示例
```python
def linear_search(arr, target):
    """线性搜索：返回目标的索引，未找到返回-1"""
    for i in range(len(arr)):
        if arr[i] == target:
            return i
    return -1

# 使用
numbers = [5, 2, 8, 1, 9, 3]
index = linear_search(numbers, 8)
print(f"找到8在索引: {index}")  # 输出: 找到8在索引: 2
```

#### 特点
- 时间复杂度：O(n)
- 适用于无序列表
- 简单但效率较低

### 1.2 二分搜索

#### 概念定义
在有序列表中，每次将搜索范围缩小一半，快速定位目标。

#### 跨课程出现

| 课程编号 | 课程名称 | 具体内容 |
|----------|---------|---------|
| CODE2-3-01 | 二分查找思维 | 通过反馈缩小范围 |
| PYAI 2-1-1 | 二分法 | math库应用 |
| PYAI 2-1-6 | 二分搜索 | 有序列表、搜索优化 |

#### Scratch思维示例（猜数字）
```
设定 [最小值] 为 (1)
设定 [最大值] 为 (100)
重复执行直到 <(猜测) = (答案)>
    设定 [猜测] 为 ((最小值) + (最大值)) / 2 取整
    如果 <(猜测) < (答案)> 那么
        设定 [最小值] 为 (猜测 + 1)
    否则
        设定 [最大值] 为 (猜测 - 1)
```

#### Python示例
```python
def binary_search(arr, target):
    """二分搜索：返回目标的索引，未找到返回-1"""
    left = 0
    right = len(arr) - 1

    while left <= right:
        mid = (left + right) // 2

        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    return -1

# 使用（列表必须有序）
numbers = [1, 2, 3, 5, 8, 9, 12, 15, 20]
index = binary_search(numbers, 8)
print(f"找到8在索引: {index}")  # 输出: 找到8在索引: 4
```

#### 特点
- 时间复杂度：O(log n)
- **必须是有序列表**
- 效率远高于线性搜索

#### 搜索效率对比

| 列表大小 | 线性搜索最坏情况 | 二分搜索最坏情况 |
|---------|-----------------|-----------------|
| 10 | 10次 | 4次 |
| 100 | 100次 | 7次 |
| 1000 | 1000次 | 10次 |
| 1000000 | 1000000次 | 20次 |

---

## 二、排序算法

### 2.1 冒泡排序

#### 概念定义
重复遍历列表，比较相邻元素，如果顺序错误就交换，直到没有需要交换的元素。

#### 跨课程出现

| 课程编号 | 课程名称 | 具体内容 |
|----------|---------|---------|
| PYAI 2-1-8 | 冒泡排序 | 时间复杂度 |

#### Python示例
```python
def bubble_sort(arr):
    """冒泡排序"""
    n = len(arr)
    for i in range(n):
        # 每轮将最大的元素"冒泡"到末尾
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                # 交换
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr

# 使用
numbers = [64, 34, 25, 12, 22, 11, 90]
sorted_numbers = bubble_sort(numbers)
print(sorted_numbers)  # [11, 12, 22, 25, 34, 64, 90]
```

#### 可视化过程
```
原始: [64, 34, 25, 12]

第1轮:
  比较64和34 → 交换 → [34, 64, 25, 12]
  比较64和25 → 交换 → [34, 25, 64, 12]
  比较64和12 → 交换 → [34, 25, 12, 64]  ← 64到位

第2轮:
  比较34和25 → 交换 → [25, 34, 12, 64]
  比较34和12 → 交换 → [25, 12, 34, 64]  ← 34到位

第3轮:
  比较25和12 → 交换 → [12, 25, 34, 64]  ← 完成
```

#### 特点
- 时间复杂度：O(n²)
- 简单易懂，适合教学
- 效率较低，不适合大数据

### 2.2 选择排序

#### 概念定义
每次从未排序部分选择最小的元素，放到已排序部分的末尾。

#### 跨课程出现

| 课程编号 | 课程名称 | 具体内容 |
|----------|---------|---------|
| PYAI 2-1-9 | 选择排序 | 排序对比 |

#### Python示例
```python
def selection_sort(arr):
    """选择排序"""
    n = len(arr)
    for i in range(n):
        # 找到未排序部分的最小值索引
        min_idx = i
        for j in range(i + 1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        # 交换
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    return arr

# 使用
numbers = [64, 25, 12, 22, 11]
sorted_numbers = selection_sort(numbers)
print(sorted_numbers)  # [11, 12, 22, 25, 64]
```

### 2.3 插入排序

#### 概念定义
将未排序的元素逐个插入到已排序部分的正确位置。

#### 跨课程出现

| 课程编号 | 课程名称 | 具体内容 |
|----------|---------|---------|
| PYAI 2-1-9 | 插入排序 | 排序对比 |

#### Python示例
```python
def insertion_sort(arr):
    """插入排序"""
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        # 将大于key的元素向后移动
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
    return arr

# 使用
numbers = [12, 11, 13, 5, 6]
sorted_numbers = insertion_sort(numbers)
print(sorted_numbers)  # [5, 6, 11, 12, 13]
```

### 排序算法对比

| 算法 | 时间复杂度 | 空间复杂度 | 稳定性 | 特点 |
|------|-----------|-----------|--------|------|
| 冒泡排序 | O(n²) | O(1) | 稳定 | 简单，适合教学 |
| 选择排序 | O(n²) | O(1) | 不稳定 | 交换次数少 |
| 插入排序 | O(n²) | O(1) | 稳定 | 小数据效率高 |

---

## 三、递归

### 概念定义
函数调用自身的编程技巧，将问题分解为更小的相同子问题。

### 跨课程出现

| 课程编号 | 课程名称 | 具体内容 |
|----------|---------|---------|
| PYAI 2-1-3 | 递归函数 | 递归终止条件、调用栈 |
| PYAI 2-1-4 | 递归应用 | 分治思想、汉诺塔 |

### 3.1 递归三要素

1. **终止条件**：何时停止递归
2. **递归调用**：调用自身
3. **问题缩小**：每次调用问题规模变小

### 3.2 经典递归示例

#### 阶乘
```python
def factorial(n):
    """计算n的阶乘: n! = n × (n-1) × ... × 1"""
    # 终止条件
    if n <= 1:
        return 1
    # 递归调用
    return n * factorial(n - 1)

print(factorial(5))  # 120 = 5 × 4 × 3 × 2 × 1
```

#### 调用过程可视化
```
factorial(5)
  → 5 × factorial(4)
       → 4 × factorial(3)
            → 3 × factorial(2)
                 → 2 × factorial(1)
                      → 1  (终止条件)
                 ← 2 × 1 = 2
            ← 3 × 2 = 6
       ← 4 × 6 = 24
  ← 5 × 24 = 120
```

#### 斐波那契数列
```python
def fibonacci(n):
    """计算第n个斐波那契数"""
    if n <= 1:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)

# 0, 1, 1, 2, 3, 5, 8, 13, 21, 34...
for i in range(10):
    print(fibonacci(i), end=' ')
```

### 3.3 汉诺塔问题

#### 跨课程出现

| 课程编号 | 课程名称 | 具体内容 |
|----------|---------|---------|
| PYAI 2-1-4 | 汉诺塔 | 分治思想 |

#### Python示例
```python
def hanoi(n, source, auxiliary, target):
    """
    汉诺塔问题
    n: 盘子数量
    source: 起始柱
    auxiliary: 辅助柱
    target: 目标柱
    """
    if n == 1:
        print(f"移动盘子从 {source} 到 {target}")
        return

    # 1. 将n-1个盘子从source移到auxiliary
    hanoi(n - 1, source, target, auxiliary)

    # 2. 将最大的盘子从source移到target
    print(f"移动盘子从 {source} 到 {target}")

    # 3. 将n-1个盘子从auxiliary移到target
    hanoi(n - 1, auxiliary, source, target)

# 使用
hanoi(3, 'A', 'B', 'C')
```

#### 输出
```
移动盘子从 A 到 C
移动盘子从 A 到 B
移动盘子从 C 到 B
移动盘子从 A 到 C
移动盘子从 B 到 A
移动盘子从 B 到 C
移动盘子从 A 到 C
```

---

## 四、算法在游戏中的应用

### 4.1 碰撞检测算法

#### 跨课程出现

| 课程编号 | 课程名称 | 具体内容 |
|----------|---------|---------|
| PYAI 1-2-1 | 圆形碰撞检测 | 距离公式 |
| PYAI 1-2-2 | 矩形碰撞检测 | 比较运算符 |
| CODE3-2-02 | 碰撞检测 | 检测两个角色是否接触 |

#### 圆形碰撞检测
```python
import math

def circle_collision(x1, y1, r1, x2, y2, r2):
    """检测两个圆是否碰撞"""
    distance = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)
    return distance < r1 + r2

# 使用
if circle_collision(100, 100, 30, 150, 120, 25):
    print("碰撞了！")
```

#### 矩形碰撞检测（AABB）
```python
def rect_collision(x1, y1, w1, h1, x2, y2, w2, h2):
    """检测两个矩形是否碰撞"""
    x_overlap = x1 < x2 + w2 and x1 + w1 > x2
    y_overlap = y1 < y2 + h2 and y1 + h1 > y2
    return x_overlap and y_overlap

# 使用
if rect_collision(100, 100, 50, 50, 130, 120, 40, 40):
    print("碰撞了！")
```

### 4.2 数值映射算法

#### 跨课程出现

| 课程编号 | 课程名称 | 具体内容 |
|----------|---------|---------|
| CODE2-1-10 | 数值映射 | 将一个范围映射到另一个范围 |
| MP1-L8 | 舵机与映射 | 旋钮值映射到角度 |

#### Python示例
```python
def map_value(x, in_min, in_max, out_min, out_max):
    """将x从[in_min, in_max]映射到[out_min, out_max]"""
    return (x - in_min) * (out_max - out_min) // (in_max - in_min) + out_min

# 将旋钮值(0-4095)映射到舵机角度(0-180)
knob_value = 2048
angle = map_value(knob_value, 0, 4095, 0, 180)
print(f"角度: {angle}")  # 约90度
```

---

## 五、算法进阶路线

```
CODE2-3-01          PYAI 2-1-5          PYAI 2-1-6          PYAI 2-1-8          PYAI 2-1-3
二分思维     →      线性搜索     →      二分搜索     →      排序算法     →      递归
   ↓                   ↓                   ↓                   ↓                   ↓
 猜数字             遍历查找            折半查找            冒泡/选择           自我调用
```

---

## 六、常见错误与禁忌

| 错误 | 后果 | 正确做法 |
|------|------|---------|
| ❌ 二分搜索用于无序列表 | 结果错误 | 先排序或使用线性搜索 |
| ❌ 递归无终止条件 | 栈溢出 | 必须有终止条件 |
| ❌ 递归深度过大 | RecursionError | 改用迭代或增加递归限制 |
| ❌ 排序时修改原列表 | 数据丢失 | 需要时先复制列表 |

---

**维护者**：知识库管理员
**数据来源**：萃取报告/CODE/、萃取报告/PythonAI/
**整合原则**：基于现有萃取报告，不压缩删减
