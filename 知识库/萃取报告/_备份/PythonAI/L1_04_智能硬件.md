# PythonAI萃取：L1-4 智能硬件与AI应用

> **来源**：NotebookLM Python AI Lesson Plan (96个来源)
> **萃取日期**：2026-02-02
> **萃取深度**：5-5多维度（含认知负荷标签、IFC标签、变体示例）
> **更新日期**：2026-02-04

---

## 单元概览

| 项目 | 内容 |
|------|------|
| **单元编号** | PYAI 1-4 |
| **单元名称** | 智能硬件与AI应用 |
| **适用年龄** | 三年级及以上（8-10岁） |
| **课时数** | 10节 × 90分钟 |
| **核心目标** | 实现软硬结合，使用Python控制ESP32掌控板及传感器，引入OpenCV机器视觉 |
| **主要教具** | ESP32/掌控板、光线传感器、气体传感器、土壤湿度传感器、舵机、RGB灯 |

**底层逻辑**
实现软硬结合，了解物联网(IoT)与机器视觉基础，建立"感知层-处理层-应用层"的系统思维。

**单元教学策略**
- 硬件基础（01）：认识ESP32、引脚、电路基础
- 传感器应用（03-05）：光线传感器、气体传感器、自动化控制
- AI视觉（06-08）：OpenCV、人脸检测、系统集成
- 综合项目（10-12）：智能花房、物联网架构复盘

`#执行层` `#测评项`
[UID: PYAI-14-001]
[关联: STEM-S3-004 STEM大班智能硬件（前置基础）]
[关联: CODE3-M1-001 CODE智能系统（前置基础）]
[关联: PYAI-24-001 PythonAI计算机视觉（进阶衔接）]

---

## 课程列表

| 课次 | 课程名称 | 核心知识点 | 项目内容 | 认知负荷 |
|------|----------|------------|----------|----------|
| 1-4-1 | 硬件系统 | 软硬件关系、ESP32引脚、电路基础 | 硬件认知 | 中 |
| 1-4-2 | 按钮控制LED | GPIO输入、button.value()、消抖处理 | 按钮开关灯 | 中 |
| 1-4-3 | 智能光控(1) | mpython_conn库、LED/RGB控制、光线传感器 | 光控灯搭建 | 中-高 |
| 1-4-4 | 智能光控(2) | 模拟量读取get_analog()、阈值判断 | 自动夜灯 | 中-高 |
| 1-4-5 | 智能通风 | MQ-2B气体传感器、电机控制 | 智能通风系统 | 高 |
| 1-4-6 | 智能门禁(1) | AI视觉基础、cv2.VideoCapture | 人脸捕捉相机 | 高 |
| 1-4-7 | 智能门禁(2) | 灰度处理cvtColor、特征匹配matchTemplate | 人脸比对算法 | 高 |
| 1-4-8 | 智能门禁(3) | 舵机控制Servo、系统集成 | 刷脸开门 | 高 |
| 1-4-9 | 音强流水灯 | NeoPixel灯带、声音传感器、流水灯算法 | 音乐律动灯 | 中-高 |
| 1-4-10 | 智能花房(1) | 土壤湿度传感器、水泵控制 | 自动浇水系统 | 中-高 |
| 1-4-11 | 智能花房(2) | OLED屏幕显示、数据可视化 | 可视化智能灌溉 | 高 |
| 1-4-12 | 家居回顾 | 物联网架构复习、AI流程复盘 | 智能家居方案展示 | 中 |

---

## 通用教学流程（90分钟）

| 环节 | 时间 | 内容 | 认知负荷 | IFC标签 |
|------|------|------|----------|---------|
| 课堂问候 | 2分钟 | 自我介绍、安全规则强调 | `#低负荷-热身` | `#IFC-预防` |
| 课程回顾 | 5分钟 | 复习上节课代码和硬件知识 | `#低负荷-热身` | `#IFC-预防` |
| 知识讲解 | 15分钟 | 新传感器/新概念讲解 | `#中负荷-操练` | `#IFC-即时` |
| 硬件搭建 | 20分钟 | 接线、组装硬件 | `#高负荷-产出` | `#IFC-即时` |
| 调节休息 | 3分钟 | 站起来活动、眼保健操 | `#调节-放松` | - |
| 编程调试 | 30分钟 | 编写代码、调试系统 | `#高负荷-产出` | `#IFC-即时` |
| 成果展示 | 10分钟 | 演示项目、分享思路 | `#低负荷-热身` | `#IFC-复盘` |

`#执行层` `#测评项`
[UID: PYAI-14-FLOW-001]

---

## 详细课程萃取

### 1-4-1 硬件系统

#### 课程基本信息

| 项目 | 内容 |
|------|------|
| **课程编号** | 1-4-1 |
| **课程名称** | 硬件系统 - 认识ESP32 |
| **认知负荷** | 中 |
| **核心技能** | 软硬件关系、ESP32引脚、电路基础 |

#### 详细教学流程

**步骤1：课程导入（5分钟）** `#低负荷-热身` `#IFC-预防`

**教师话术**
> "同学们，之前我们写的Python代码都是在电脑上运行的。今天开始，我们要让代码控制真实的硬件！这就是**物联网(IoT)**的魅力——用代码控制物理世界。"

---

**步骤2：知识讲解（15分钟）** `#中负荷-操练` `#IFC-即时`

**教师话术**
> "首先认识我们的主角——**ESP32掌控板**！
>
> **什么是ESP32？**
> - 一块小型计算机，可以运行MicroPython代码
> - 内置WiFi和蓝牙，可以联网
> - 有很多**引脚(Pin)**，用来连接传感器和执行器
>
> **引脚类型**：
> ```
> VCC (3.3V) - 电源正极，给传感器供电
> GND        - 电源负极，接地
> P0-P20     - 数字/模拟引脚，连接传感器
> ```
>
> **电路基础**：
> - 电流从VCC流出，经过元件，流回GND
> - 必须形成**闭合回路**才能工作
> - **短路**：VCC直接接GND，会烧毁开发板！"

**核心代码模式**

```python
# MicroPython基础导入
from mpython import *
import time

# 控制板载LED
led.on()   # 开灯
led.off()  # 关灯

# 控制板载蜂鸣器
buzzer.on()   # 响
buzzer.off()  # 停
```

**变体示例**

| 学生情况 | 调整方案 | 说明 |
|----------|----------|------|
| 不理解引脚 | 用插座类比 | "引脚就像插座，传感器插上去就能用" |
| 混淆VCC和GND | 用水流类比 | "VCC是水龙头，GND是下水道" |
| 想知道为什么用3.3V | 解释电压 | "ESP32是3.3V系统，5V会烧坏" |

---

**步骤3：硬件认知（20分钟）** `#高负荷-产出` `#IFC-即时`

**教师话术**
> "现在我们来认识开发板上的各个部件：
>
> 1. **USB接口**：连接电脑，上传代码
> 2. **复位按钮**：重启开发板
> 3. **板载LED**：可以用代码控制的小灯
> 4. **板载蜂鸣器**：可以发出声音
> 5. **OLED屏幕**：显示文字和图形
> 6. **引脚排**：连接外部传感器
>
> **安全规则（必须牢记）**：
> - 接线前必须断电
> - 红线接VCC，黑线接GND
> - 不确定时先问老师"

**禁忌提醒**
❌ **带电接线**——会短路烧毁开发板
❌ **VCC直接接GND**——这是短路，绝对禁止
❌ **开发板放金属表面通电**——底部引脚会短路

---

**步骤4：编程体验（30分钟）** `#高负荷-产出` `#IFC-即时`

**教师话术**
> "让我们写第一个硬件控制程序——让LED闪烁！
>
> ```python
> from mpython import *
> import time
>
> while True:
>     led.on()
>     time.sleep(0.5)  # 亮0.5秒
>     led.off()
>     time.sleep(0.5)  # 灭0.5秒
> ```
>
> 上传代码后，观察LED是不是在闪烁？"

**变体示例**

| 学生情况 | 调整方案 | 说明 |
|----------|----------|------|
| 代码上传失败 | 检查USB连接 | 确认选择了正确的串口 |
| LED不闪烁 | 检查代码缩进 | while循环内的代码要缩进 |
| 想改变闪烁速度 | 修改sleep参数 | "把0.5改成0.1会怎样？" |

---

**步骤5：成果展示（10分钟）** `#低负荷-热身` `#IFC-复盘`

**教师话术**
> "谁的LED闪烁成功了？试着让蜂鸣器也响起来！
>
> ```python
> buzzer.on()
> time.sleep(0.1)
> buzzer.off()
> ```"

---

**核心知识点**
- ESP32是可编程的小型计算机，运行MicroPython
- 引脚类型：VCC(电源)、GND(接地)、P0-P20(信号)
- 电路必须形成闭合回路才能工作
- 安全第一：接线前断电，避免短路

**底层逻辑**
- **软硬结合**：代码 → 硬件动作
- **物联网基础**：感知 → 处理 → 执行

`#执行层` `#测评项`
[UID: PYAI-14-01-001]
[关联: STEM-S3-004 STEM大班智能硬件（前置基础）]

---

### 1-4-2 按钮控制LED

#### 课程基本信息

| 项目 | 内容 |
|------|------|
| **课程编号** | 1-4-2 |
| **课程名称** | 按钮控制LED |
| **认知负荷** | 中 |
| **核心技能** | GPIO输入、button.value()、消抖处理 |

#### 详细教学流程

**步骤1：课程回顾（5分钟）** `#低负荷-热身` `#IFC-预防`

**教师话术**
> "上节课我们学会了用代码控制LED闪烁。但那是自动的，如果我想用按钮来控制呢？今天学习**GPIO输入**——让开发板'感知'按钮状态！"

---

**步骤2：知识讲解（15分钟）** `#中负荷-操练` `#IFC-即时`

**教师话术**
> "**GPIO输入模式**：之前LED是输出(OUT)，按钮是���入(IN)
>
> ```python
> import machine
>
> # LED是输出
> led = machine.Pin(2, machine.Pin.OUT)
>
> # 按钮是输入
> button = machine.Pin(4, machine.Pin.IN)
> ```
>
> **读取按钮状态**：用`value()`方法
> ```python
> state = button.value()
> # 返回 0 表示按下（低电平）
> # 返回 1 表示松开（高电平）
> ```
>
> **为什么按下是0？**
> - 按钮接地(GND)，按下时引脚接地，电压为0
> - 松开时引脚悬空或接高电平，电压为1"

**核心代码模式**

```python
import machine
import time

# 初始化引脚
led = machine.Pin(2, machine.Pin.OUT)
button = machine.Pin(4, machine.Pin.IN)

while True:
    if button.value() == 0:  # 按钮按下
        led.value(1)         # 开灯
    else:
        led.value(0)         # 关灯
    time.sleep_ms(20)        # 消抖延时
```

**变体示例**

| 学生情况 | 调整方案 | 说明 |
|----------|----------|------|
| 不理解0和1 | 用开关类比 | "按下接通=0，松开断开=1" |
| 按钮不灵敏 | 检查接线 | 确认按钮一端接引脚，一端接GND |
| 想做切换功能 | 引导状态变量 | 用变量记录当前灯的状态 |

---

**步骤3：硬件搭建（20分钟）** `#高负荷-产出` `#IFC-即时`

**教师话术**
> "今天的接线很简单：
>
> **按钮接线**：
> ```
> 按钮一端 → P4引脚
> 按钮另一端 → GND
> ```
>
> **LED接线**（如果用外部LED）：
> ```
> LED正极 → P2引脚
> LED负极 → GND（通过电阻）
> ```
>
> **消抖处理**：按钮按下时会有机械抖动，产生多次0-1变化。加入`time.sleep_ms(20)`延时可以消除抖动。"

**禁忌提醒**
❌ **按钮两端都接VCC**——无法检测按下
❌ **忘记消抖**——按一次可能触发多次
❌ **LED不串电阻**——可能烧毁LED

---

**步骤4：编程调试（30分钟）** `#高负荷-产出` `#IFC-即时`

**教师话术**
> "现在来做一个**切换开关**——按一次开灯，再按一次关灯：
>
> ```python
> import machine
> import time
>
> led = machine.Pin(2, machine.Pin.OUT)
> button = machine.Pin(4, machine.Pin.IN)
>
> light_on = False  # 记录灯的状态
> last_state = 1    # 记录上次按钮状态
>
> while True:
>     current_state = button.value()
>
>     # 检测按下瞬间（从1变成0）
>     if current_state == 0 and last_state == 1:
>         light_on = not light_on  # 切换状态
>         led.value(1 if light_on else 0)
>         time.sleep_ms(200)  # 防止连续触发
>
>     last_state = current_state
>     time.sleep_ms(20)
> ```"

**变体示例**

| 学生情况 | 调整方案 | 说明 |
|----------|----------|------|
| 切换不灵 | 检查边沿检测 | 确认是检测"按下瞬间"而非"按住" |
| 想加多个按钮 | 扩展引脚 | 每个按钮用不同引脚 |
| 想做长按功能 | 计时检测 | 记录按下时长，超过1秒执行不同操作 |

---

**步骤5：成果展示（10分钟）** `#低负荷-热身` `#IFC-复盘`

**教师话术**
> "谁的按钮开关做好了？演示一下！
>
> 挑战：能不能做一个'双击'功能？双击按钮切换不同颜色的RGB灯。"

---

**核心知识点**
- GPIO输入模式：`machine.Pin(pin, machine.Pin.IN)`
- 读取状态：`button.value()` 返回0或1
- 消抖处理：加入短暂延时消除机械抖动
- 边沿检测：检测状态变化的瞬间

**底层逻辑**
- **输入输出**：GPIO既可以输出控制设备，也可以输入感知状态
- **状态机**：用变量记录状态，实现切换功能

`#执行层` `#测评项`
[UID: PYAI-14-02-001]

---

### 1-4-3 智能光控(1)

#### 课程基本信息

| 项目 | 内容 |
|------|------|
| **课程编号** | 1-4-3 |
| **课程名称** | 智能光控(1) - 光控灯搭建 |
| **认知负荷** | 中-高 |
| **核心技能** | mpython_conn库、LED/RGB控制、光线传感器 |

#### 详细教学流程

**步骤1：课程回顾（5分钟）** `#低负荷-热身` `#IFC-预防`

**教师话术**
> "上节课我们认识了ESP32开发板。今天我们要连接第一个外部传感器——**光线传感器**！它能感知环境的亮度。"

---

**步骤2：知识讲解（15分钟）** `#中负荷-操练` `#IFC-即时`

**教师话术**
> "**光线传感器**的工作原理：
> - 内部有一个光敏电阻
> - 光线越强，电阻越小，输出值越大
> - 光线越弱，电阻越大，输出值越小
>
> **RGB灯**可以显示任意颜色：
> ```python
> from mpython import *
>
> # RGB灯控制 - 三个参数分别是红、绿、蓝（0-255）
> rgb[0] = (255, 0, 0)    # 红色
> rgb[1] = (0, 255, 0)    # 绿色
> rgb[2] = (0, 0, 255)    # 蓝色
> rgb.write()             # 更新显示
> ```
>
> **颜色混合**：
> - (255, 255, 0) = 黄色（红+绿）
> - (255, 0, 255) = 紫色（红+蓝）
> - (0, 255, 255) = 青色（绿+蓝）
> - (255, 255, 255) = 白色"

**核心代码模式**

```python
from mpython import *
import time

# 读取光线传感器
light_value = light.read()
print(f"当前光线值: {light_value}")

# 控制RGB灯
rgb[0] = (255, 100, 0)  # 橙色
rgb.write()

# 关闭RGB灯
rgb.fill((0, 0, 0))
rgb.write()
```

**变体示例**

| 学生情况 | 调整方案 | 说明 |
|----------|----------|------|
| 不理解RGB | 用调色盘类比 | "红绿蓝三种颜料混合" |
| 颜色不对 | 检查参数顺序 | 顺序是(红, 绿, 蓝) |
| 忘记write() | 强调更新 | "设置颜色后必须write()才生效" |

---

**步骤3：硬件搭建（20分钟）** `#高负荷-产出` `#IFC-即时`

**教师话术**
> "今天我们使用板载的光线传感器，不需要额外接线！
>
> 但如果使用外部光线传感器模块，接线方式是：
> ```
> VCC → 3.3V（红线）
> GND → GND（黑线）
> OUT → P0（信号线）
> ```
>
> **接线口诀**：红接红，黑接黑，信号线接P引脚。"

**禁忌提醒**
❌ **接反VCC和GND**——会烧毁传感器
❌ **信号线接错引脚**——读取不到数据
❌ **带电插拔**——可能损坏接口

---

**步骤4：编程调试（30分钟）** `#高负荷-产出` `#IFC-即时`

**教师话术**
> "现在我们来写一个光控灯程序：
>
> ```python
> from mpython import *
> import time
>
> while True:
>     # 读取光线值
>     light_value = light.read()
>     print(f'光线值: {light_value}')
>
>     # 根据光线调整RGB亮度
>     brightness = int(light_value / 16)  # 0-4095 映射到 0-255
>     rgb.fill((brightness, brightness, brightness))
>     rgb.write()
>
>     time.sleep(0.1)
> ```
>
> 用手遮住光线传感器，观察RGB灯的变化！"

**变体示例**

| 学生情况 | 调整方案 | 说明 |
|----------|----------|------|
| 灯不变化 | 检查传感器 | 用print确认light.read()有变化 |
| 想要彩色效果 | 修改RGB参数 | 根据光线值改变颜色而非亮度 |
| 变化太快 | 增加延时 | 把sleep改成0.5秒 |

---

**步骤5：成果展示（10分钟）** `#低负荷-热身` `#IFC-复盘`

**教师话术**
> "谁能让RGB灯根据光线变化显示不同颜色？比如：
> - 光线强 → 蓝色（白天）
> - 光线弱 → 橙色（傍晚）
> - 很暗 → 红色（夜晚）"

---

**核心知识点**
- 光线传感器：`light.read()` 返回0-4095
- RGB灯控制：`rgb[n] = (R, G, B)` + `rgb.write()`
- 颜色混合：红+绿=黄，红+蓝=紫，绿+蓝=青

**底层逻辑**
- **传感器输入**：环境信息 → 数字信号
- **执行器输出**：数字信号 → 物理效果

`#执行层` `#测评项`
[UID: PYAI-14-03-001]

---

### 1-4-4 智能光控(2)（典型案例）

#### 课程基本信息

| 项目 | 内容 |
|------|------|
| **课程编号** | 1-4-4 |
| **课程名称** | 智能光控(2) - 自动夜灯 |
| **认知负荷** | 中-高 |
| **核心技能** | 模拟量读取、阈值判断、自动化控制 |

#### 详细教学流程

**步骤1：课程回顾（5分钟）** `#低负荷-热身` `#IFC-预防`

**教师话术**
> "上节课我们学习了如何用Python控制LED灯。今天我们要让灯变得更聪明——能自动感知环境亮度！大家还记得光线传感器是怎么工作的吗？"

---

**步骤2：知识讲解（15分钟）** `#中负荷-操练` `#IFC-即时`

**教师话术**
> "光线传感器返回的是一个数字，叫做**模拟量**。数值范围是0-4095：
> - 0 表示完全黑暗
> - 4095 表示非常明亮
>
> 我们用 `get_analog()` 函数读取这个数值：
> ```python
> light_value = light_sensor.get_analog()
> print(light_value)
> ```
>
> 然后用**阈值判断**来决定是否开灯：
> ```python
> if light_value < 500:
>     led.on()  # 光线暗，开灯
> else:
>     led.off()  # 光线亮，关灯
> ```"

**变体示例**

| 学生情况 | 调整方案 | 说明 |
|----------|----------|------|
| 不理解模拟量 | 用温度计类比 | "温度计显示25度，就是一个模拟量" |
| 阈值概念模糊 | 用门槛类比 | "500就是一个门槛，低于它就开灯" |
| 想调整灵敏度 | 引导修改阈值 | "试试把500改成300会怎样？" |

---

**步骤3：硬件搭建（20分钟）** `#高负荷-产出` `#IFC-即时`

**教师话术**
> "现在开始接线！**注意：必须先断电再接线！**
>
> 接线步骤：
> 1. 光线传感器的VCC接3.3V（红线）
> 2. GND接GND（黑线）
> 3. 信号线接P0引脚
> 4. LED灯接P1引脚"

**禁忌提醒**
❌ **带电接线**——会短路烧毁开发板
❌ **VCC直接接GND**——这是短路，会烧板子
❌ **接错引脚**——先检查再通电

---

**步骤4：编程调试（30分钟）** `#高负荷-产出` `#IFC-即时`

**教师话术**
> "代码写好了，现在测试一下。用手遮住光线传感器，看看LED会不会亮起来？"
>
> "如果没反应，我们来调试：
> 1. 先用print()打印光线值，看看传感器有没有工作
> 2. 检查阈值设置是否合理
> 3. 检查接线是否正确"

**变体示例**

| 学生情况 | 调整方案 | 说明 |
|----------|----------|------|
| LED不亮 | 检查接线和引脚 | 确认LED正负极没接反 |
| 传感器数值不变 | 检查传感器接线 | 信号线可能接错引脚 |
| 想增加功能 | 加入RGB渐变 | 根据亮度调整RGB颜色 |

---

**步骤5：成果展示（10分钟）** `#低负荷-热身` `#IFC-复盘`

**教师话术**
> "谁的自动夜灯做好了？上来演示一下！告诉大家你设置的阈值是多少，为什么选这个数值？"

---

**核心知识点**
- 模拟量读取：`get_analog()` 返回0-4095
- 阈值判断：`if value < 500` 触发动作
- 自动化控制：光线低于阈值自动点亮LED

**底层逻辑**
- **物联网架构**：感知（传感器）→ 处理（Python判断）→ 执行（LED）
- **反馈控制**：环境变化 → 系统响应

`#执行层` `#测评项`
[UID: PYAI-14-04-001]

---

### 1-4-5 智能通风

#### 课程基本信息

| 项目 | 内容 |
|------|------|
| **课程编号** | 1-4-5 |
| **课程名称** | 智能通风 - 气体检测系统 |
| **认知负荷** | 高 |
| **核心技能** | MQ-2B气体传感器、电机控制、安全阈值 |

#### 详细教学流程

**步骤1：课程导入（5分钟）** `#低负荷-热身` `#IFC-预防`

**教师话术**
> "同学们，家里的燃气报警器见过吗？今天我们要做一个类似的智能通风系统——检测到有害气体就自动开启风扇！"

---

**步骤2：知识讲解（15分钟）** `#中负荷-操练` `#IFC-即时`

**教师话术**
> "**MQ-2B气体传感器**可以检测：
> - 可燃气体（天然气、液化气）
> - 烟雾
> - 酒精蒸汽
>
> **工作原理**：
> - 传感器内部有加热丝，需要预热1-2分钟
> - 检测到气体时，输出值会升高
> - 正常空气：100-300
> - 检测到气体：500以上
>
> **电机控制**：
> ```python
> from mpython import *
>
> # 电机连接到P8引脚
> motor = Pin(Pin.P8, Pin.OUT)
>
> motor.write_digital(1)  # 开启电机
> motor.write_digital(0)  # 关闭电机
> ```"

**核心代码模式**

```python
from mpython import *
import time

# 气体传感器连接到P0
gas_sensor = Pin(Pin.P0, Pin.IN)

# 电机连接到P8
motor = Pin(Pin.P8, Pin.OUT)

# 安全阈值
DANGER_THRESHOLD = 500

while True:
    # 读取气体浓度
    gas_value = gas_sensor.read_analog()
    print(f"气体浓度: {gas_value}")

    # 判断是否超标
    if gas_value > DANGER_THRESHOLD:
        motor.write_digital(1)  # 开启风扇
        rgb.fill((255, 0, 0))   # 红色警告
        buzzer.on()             # 蜂鸣器报警
    else:
        motor.write_digital(0)  # 关闭风扇
        rgb.fill((0, 255, 0))   # 绿色安全
        buzzer.off()

    rgb.write()
    time.sleep(0.5)
```

**变体示例**

| 学生情况 | 调整方案 | 说明 |
|----------|----------|------|
| 传感器数值不稳定 | 等待预热 | MQ-2B需要预热1-2分钟 |
| 想测试效果 | 用酒精棉球 | 靠近传感器可触发检测 |
| 阈值不合适 | 观察正常值 | 先记录正常空气的数值 |

---

**步骤3：硬件搭建（20分钟）** `#高负荷-产出` `#IFC-即时`

**教师话术**
> "今天的接线比较复杂，请仔细听：
>
> **气体传感器接线**：
> ```
> VCC → 5V（注意：MQ-2B需要5V供电）
> GND → GND
> AO  → P0（模拟输出）
> ```
>
> **电机模块接线**：
> ```
> VCC → 5V
> GND → GND
> IN  → P8（控制信号）
> ```
>
> **重要**：MQ-2B传感器会发热，这是正常的！"

**禁忌提醒**
❌ **触摸发热的传感器**——会烫伤
❌ **用明火测试**——危险！用酒精棉球代替
❌ **电机反接**——可能烧毁驱动模块
❌ **忘记预热**——数值不准确

---

**步骤4：编程调试（30分钟）** `#高负荷-产出` `#IFC-即时`

**教师话术**
> "代码上传后，先观察正常空气的数值是多少。
>
> 然后用酒精棉球靠近传感器测试：
> 1. 数值是否升高？
> 2. 风扇是否启动？
> 3. 蜂鸣器是否响起？
>
> 如果没反应，检查：
> - 传感器是否预热完成
> - 阈值设置是否合理
> - 接线是否正确"

**变体示例**

| 学生情况 | 调整方案 | 说明 |
|----------|----------|------|
| 风扇不转 | 检查电机接线 | 确认IN接到正确引脚 |
| 一直报警 | 降低阈值 | 可能环境本身气体浓度高 |
| 想加显示 | 用OLED显示 | 在屏幕上显示当前数值 |

---

**步骤5：成果展示（10分钟）** `#低负荷-热身` `#IFC-复盘`

**教师话术**
> "谁的智能通风系统做好了？演示一下！
>
> 思考：这个系统还能怎么改进？
> - 加入OLED显示当前气体浓度
> - 加入WiFi功能，远程报警
> - 记录历史数据"

---

**核心知识点**
- MQ-2B气体传感器：检测可燃气体和烟雾
- 传感器预热：需要1-2分钟预热才能准确
- 电机控制：`write_digital(1/0)` 开关控制
- 安全阈值：根据实际环境调整

**底层逻辑**
- **安全系统设计**：检测 → 判断 → 响应
- **多输出联动**：风扇 + 灯光 + 声音

`#执行层` `#测评项`
[UID: PYAI-14-05-001]

---

### 1-4-6~8 智能门禁系列

#### 课程基本信息

| 项目 | 内容 |
|------|------|
| **课程编号** | 1-4-6/7/8 |
| **课程名称** | 智能门禁（人脸识别开门） |
| **认知负荷** | 高 |
| **核心技能** | OpenCV视觉、灰度处理、特征匹配、舵机控制 |

#### 详细教学流程（跨3节课）

**第6课：人脸捕捉相机**

**教师话术**
> "今天我们开始做智能门禁系统！第一步是让电脑'看见'人脸。
>
> 我们用OpenCV库来控制摄像头：
> ```python
> import cv2
> cap = cv2.VideoCapture(0)  # 0表示第一个摄像头
> ret, frame = cap.read()    # 读取一帧图像
> cv2.imshow('Camera', frame)  # 显示图像
> ```"

**禁忌提醒**
❌ 忘记释放摄像头——程序结束前要调用 `cap.release()`
❌ 摄像头被占用——确保没有其他程序在使用摄像头

---

**第7课：人脸比对算法**

**教师话术**
> "现在我们要让电脑'认识'人脸。步骤是：
>
> 1. **灰度处理**：把彩色图变成黑白图，减少计算量
> ```python
> gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
> ```
>
> 2. **特征匹配**：把当前人脸和保存的人脸对比
> ```python
> result = cv2.matchTemplate(gray, template, cv2.TM_CCOEFF_NORMED)
> ```
>
> 相似度越高，说明是同一个人！"

**变体示例**

| 学生情况 | 调整方案 | 说明 |
|----------|----------|------|
| 不理解灰度 | 用黑白照片类比 | "灰度就像老照片，只有黑白" |
| 匹配不准 | 调整阈值 | "相似度0.8以上才算匹配成功" |
| 想识别多人 | 引导使用列表 | 保存多个人脸模板 |

---

**第8课：刷脸开门**

**教师话术**
> "最后一步，把AI和硬件连接起来！
>
> 如果人脸匹配成功，就控制舵机转动，打开门：
> ```python
> if similarity > 0.8:
>     servo.write_angle(90)  # 开门
>     time.sleep(3)
>     servo.write_angle(0)   # 关门
> ```"

**禁忌提醒**
❌ **强行扭动舵机**——会损坏内部齿轮
❌ 舵机角度超范围——通常是0-180度，超出会卡死

---

**核心知识点**
- AI视觉流程：采集 → 处理 → 输出
- 灰度处理：降低计算量
- 特征匹配：计算相似度数值
- 系统集成：AI判断 + 舵机控制

`#执行层` `#测评项`
[UID: PYAI-14-06-001]

---

### 1-4-9 音强流水灯

#### 课程基本信息

| 项目 | 内容 |
|------|------|
| **课程编号** | 1-4-9 |
| **课程名称** | 音强流水灯 |
| **认知负荷** | 中-高 |
| **核心技能** | NeoPixel灯带、声音传感器、流水灯算法 |

#### 详细教学流程

**步骤1：课程导入（5分钟）** `#低负荷-热身` `#IFC-预防`

**教师话术**
> "同学们见过KTV里跟着音乐闪烁的灯光吗？今天我们来做一个**音乐律动灯**——灯光会随着声音的强弱变化！"

---

**步骤2：知识讲解（15分钟）** `#中负荷-操练` `#IFC-即时`

**教师话术**
> "**NeoPixel灯带**：可以单独控制每颗LED的颜色
>
> ```python
> import neopixel
> from machine import Pin
>
> NUM_LEDS = 30  # 灯珠数量
> np = neopixel.NeoPixel(Pin(4), NUM_LEDS)
>
> # 设置第一颗灯为红色
> np[0] = (255, 0, 0)  # (R, G, B)
> np.write()  # 更新显示
> ```
>
> **声音传感器**：检测环境音量
> ```python
> from machine import Pin, ADC
>
> mic = ADC(Pin(34))
> mic.atten(ADC.ATTN_11DB)  # 设置量程
>
> sound_level = mic.read()  # 读取音量值（0-4095）
> ```
>
> **流水灯算法**：让颜色像水一样流动
> ```python
> # 核心思想：列表元素向右偏移
> colors = [(255,0,0), (0,255,0), (0,0,255), ...]
>
> # 每次循环，最后一个颜色移到最前面
> last_color = colors.pop()  # 取出最后一个
> colors.insert(0, last_color)  # 插入到最前面
> ```"

**核心代码模式**

```python
import neopixel
import time
from machine import Pin, ADC

# 初始化
NUM_LEDS = 30
np = neopixel.NeoPixel(Pin(4), NUM_LEDS)
mic = ADC(Pin(34))
mic.atten(ADC.ATTN_11DB)

# 初始化颜色列表（渐变色）
colors = []
for i in range(NUM_LEDS):
    # 生成彩虹渐变
    hue = int(i * 255 / NUM_LEDS)
    colors.append((hue, 255 - hue, 128))

while True:
    # 读取音量
    sound = mic.read()

    # 根据音量调整亮度
    brightness = min(255, sound // 16)

    # 应用颜色到灯带
    for i in range(NUM_LEDS):
        r = colors[i][0] * brightness // 255
        g = colors[i][1] * brightness // 255
        b = colors[i][2] * brightness // 255
        np[i] = (r, g, b)
    np.write()

    # 流水效果：颜色向右移动
    last = colors.pop()
    colors.insert(0, last)

    time.sleep_ms(50)
```

**变体示例**

| 学生情况 | 调整方案 | 说明 |
|----------|----------|------|
| 灯带不亮 | 检查供电 | NeoPixel需要5V供电，电流较大 |
| 音量检测不灵敏 | 调整阈值 | 根据环境噪音调整基准值 |
| 想要不同效果 | 修改算法 | 可以做呼吸灯、闪烁、追逐等效果 |

---

**步骤3：硬件搭建（20分钟）** `#高负荷-产出` `#IFC-即时`

**教师话术**
> "今天的硬件：
>
> **NeoPixel灯带接线**：
> ```
> VCC → 5V（外部电源，不要用ESP32的5V）
> GND → GND（与ESP32共地）
> DIN → P4（数据输入）
> ```
>
> **声音传感器接线**：
> ```
> VCC → 3.3V
> GND → GND
> AO  → P34（模拟输出）
> ```
>
> **重要**：灯带耗电大，30颗灯全亮可能需要1.8A电流，必须用外部电源！"

**禁忌提醒**
❌ **灯带直接接ESP32的5V**——电流不够，可能烧毁USB口
❌ **忘记共地**——灯带和ESP32的GND必须连接
❌ **数据线接错**——DIN是输入，DOUT是输出（级联用）

---

**步骤4：编程调试（30分钟）** `#高负荷-产出` `#IFC-即时`

**教师话术**
> "调试步骤：
>
> 1. **先测试灯带**：
>    ```python
>    # 让所有灯亮红色
>    for i in range(NUM_LEDS):
>        np[i] = (255, 0, 0)
>    np.write()
>    ```
>
> 2. **再测试声音传感器**：
>    ```python
>    while True:
>        print(mic.read())
>        time.sleep_ms(100)
>    ```
>    对着传感器说话，观察数值变化
>
> 3. **最后联调**：
>    - 安静时灯光暗
>    - 声音大时灯光亮
>    - 颜色在流动"

**变体示例**

| 学生情况 | 调整方案 | 说明 |
|----------|----------|------|
| 灯光闪烁不稳定 | 添加平滑处理 | 用移动平均值平滑音量数据 |
| 想做音乐节奏灯 | 检测节拍 | 检测音量的突变作为节拍 |
| 想控制更多灯 | 级联灯带 | 多条灯带可以串联 |

---

**步骤5：成果展示（10分钟）** `#低负荷-热身` `#IFC-复盘`

**教师话术**
> "谁的音乐律动灯做好了？放一首歌试试效果！
>
> 思考：如何让灯光效果更炫酷？
> - 不同音量对应不同颜色
> - 低音和高音分开显示
> - 添加闪烁效果"

---

**核心知识点**
- NeoPixel灯带：可单独控制每颗LED颜色
- 声音传感器：ADC读取模拟音量值
- 流水灯算法：列表元素循环移位
- 亮度映射：音量值映射到亮度

**底层逻辑**
- **数据驱动显示**：传感器数据 → 视觉效果
- **列表操作**：pop()和insert()实现循环移位

`#执行层` `#测评项`
[UID: PYAI-14-09-001]

---

### 1-4-10 智能花房(1)

#### 课程基本信息

| 项目 | 内容 |
|------|------|
| **课程编号** | 1-4-10 |
| **课程名称** | 智能花房(1) - 自动浇水系统 |
| **认知负荷** | 中-高 |
| **核心技能** | 土壤湿度传感器、水泵控制、自动化灌溉 |

#### 详细教学流程

**步骤1：课程导入（5分钟）** `#低负荷-热身` `#IFC-预防`

**教师话术**
> "同学们养过植物吗？最头疼的是不是忘记浇水？今天我们来做一个**自动浇水系统**，让植物自己'喝水'！"

---

**步骤2：知识讲解（15分钟）** `#中负荷-操练` `#IFC-即时`

**教师话术**
> "**土壤湿度传感器**的工作原理：
> - 两个金属探针插入土壤
> - 土壤越湿，导电性越好，数值越低
> - 土壤越干，导电性越差，数值越高
>
> **数值范围**（参考）：
> - 0-300：非常湿润（刚浇过水）
> - 300-700：适中
> - 700-1000：偏干
> - 1000以上：很干（需要浇水）
>
> **水泵控制**：
> ```python
> from mpython import *
>
> # 水泵连接到P8（通过继电器）
> pump = Pin(Pin.P8, Pin.OUT)
>
> pump.write_digital(1)  # 开启水泵
> time.sleep(2)          # 浇水2秒
> pump.write_digital(0)  # 关闭水泵
> ```"

**核心代码模式**

```python
from mpython import *
import time

# 土壤湿度传感器连接到P0
soil_sensor = Pin(Pin.P0, Pin.IN)

# 水泵连接到P8
pump = Pin(Pin.P8, Pin.OUT)

# 干燥阈值
DRY_THRESHOLD = 800

while True:
    # 读取土壤湿度
    soil_value = soil_sensor.read_analog()
    print(f"土壤湿度: {soil_value}")

    # 判断是否需要浇水
    if soil_value > DRY_THRESHOLD:
        print("土壤干燥，开始浇水...")
        pump.write_digital(1)
        time.sleep(3)  # 浇水3秒
        pump.write_digital(0)
        print("浇水完成，等待30秒...")
        time.sleep(30)  # 等待水分渗透
    else:
        print("土壤湿润，无需浇水")

    time.sleep(5)  # 每5秒检测一次
```

**变体示例**

| 学生情况 | 调整方案 | 说明 |
|----------|----------|------|
| 数值不稳定 | 检查探针接触 | 探针要完全插入土壤 |
| 阈值不准 | 实际测量 | 先测干土和湿土的数值 |
| 想防止过度浇水 | 加冷却时间 | 浇水后等待一段时间再检测 |

---

**步骤3：硬件搭建（20分钟）** `#高负荷-产出` `#IFC-即时`

**教师话术**
> "今天的硬件包括：
>
> **土壤湿度传感器接线**：
> ```
> VCC → 3.3V
> GND → GND
> AO  → P0（模拟输出）
> ```
>
> **水泵模块接线**（通过继电器）：
> ```
> 继电器 VCC → 5V
> 继电器 GND → GND
> 继电器 IN  → P8
> 水泵接继电器的常开端
> ```
>
> **注意**：水泵需要单独供电，不能直接接ESP32！"

**禁忌提醒**
❌ **水泵直接接ESP32**——电流太大会烧毁
❌ **传感器长时间通电**——会加速腐蚀
❌ **水溅到电路板**——会短路
❌ **水管脱落**——会漏水

---

**步骤4：编程调试（30分钟）** `#高负荷-产出` `#IFC-即时`

**教师话术**
> "测试步骤：
>
> 1. 先测试传感器：
>    - 探针在空气中的数值
>    - 探针插入干土的数值
>    - 探针插入湿土的数值
>
> 2. 再测试水泵：
>    - 手动控制开关
>    - 确认水流正常
>
> 3. 最后联调：
>    - 把探针插入干土
>    - 观察是否自动浇水"

**变体示例**

| 学生情况 | 调整方案 | 说明 |
|----------|----------|------|
| 水泵不工作 | 检查继电器 | 听继电器是否有"咔嗒"声 |
| 浇水太多 | 减少浇水时间 | 把3秒改成1秒 |
| 想加指示灯 | 用RGB显示状态 | 绿色=湿润，红色=干燥 |

---

**步骤5：成果展示（10分钟）** `#低负荷-热身` `#IFC-复盘`

**教师话术**
> "谁的自动浇水系统做好了？演示一下！
>
> 思考：真正的智能花房还需要什么？
> - 光照检测（是否需要补光）
> - 温度检测（是否需要加热）
> - 远程监控（手机查看状态）"

---

**核心知识点**
- 土壤湿度传感器：数值越高越干燥
- 水泵控制：通过继电器间接控制
- 防过度浇水：加入冷却等待时间
- 阈值校准：根据实际土壤调整

**底层逻辑**
- **农业物联网**：感知土壤 → 智能决策 → 自动执行
- **反馈控制**：检测 → 执行 → 等待 → 再检测

`#执行层` `#测评项`
[UID: PYAI-14-10-001]

---

### 1-4-11 智能花房(2)

#### 课程基本信息

| 项目 | 内容 |
|------|------|
| **课程编号** | 1-4-11 |
| **课程名称** | 智能花房(2) - 可视化智能灌溉 |
| **认知负荷** | 高 |
| **核心技能** | OLED屏幕显示、数据可视化、多传感器融合 |

#### 详细教学流程

**步骤1：课程回顾（5分钟）** `#低负荷-热身` `#IFC-预防`

**教师话术**
> "上节课我们做了自动浇水系统。但是，我们只能通过电脑看数据。今天我们要把数据显示在**OLED屏幕**上，让花房更智能！"

---

**步骤2：知识讲解（15分钟）** `#中负荷-操练` `#IFC-即时`

**教师话术**
> "**OLED屏幕**是一种小型显示屏：
> - 分辨率：128×64像素
> - 可以显示文字、数字、图形
> - 自发光，不需要背光
>
> **显示函数**：
> ```python
> from mpython import *
>
> # 清屏
> oled.fill(0)
>
> # 显示文字（x坐标, y坐标, 内容）
> oled.DispChar('土壤湿度:', 0, 0)
> oled.DispChar('750', 0, 16)
>
> # 显示英文
> oled.DispChar('Soil: 750', 0, 32)
>
> # 更新显示
> oled.show()
> ```
>
> **进度条显示**：
> ```python
> # 画矩形框（x, y, 宽, 高, 颜色）
> oled.rect(0, 50, 128, 10, 1)
>
> # 填充进度（根据湿度百分比）
> progress = int(soil_value / 1024 * 128)
> oled.fill_rect(0, 50, progress, 10, 1)
> ```"

**核心代码模式**

```python
from mpython import *
import time

# 传感器
soil_sensor = Pin(Pin.P0, Pin.IN)
pump = Pin(Pin.P8, Pin.OUT)

DRY_THRESHOLD = 800

def update_display(soil_value, status):
    """更新OLED显示"""
    oled.fill(0)  # 清屏

    # 标题
    oled.DispChar('智能花房', 32, 0)

    # 土壤湿度
    oled.DispChar(f'湿度: {soil_value}', 0, 20)

    # 状态
    oled.DispChar(f'状态: {status}', 0, 36)

    # 进度条
    oled.rect(0, 52, 128, 10, 1)
    progress = min(128, int((1024 - soil_value) / 1024 * 128))
    oled.fill_rect(0, 52, progress, 10, 1)

    oled.show()

while True:
    soil_value = soil_sensor.read_analog()

    if soil_value > DRY_THRESHOLD:
        update_display(soil_value, '浇水中...')
        pump.write_digital(1)
        time.sleep(2)
        pump.write_digital(0)
        update_display(soil_value, '等待渗透')
        time.sleep(30)
    else:
        update_display(soil_value, '湿润正常')

    time.sleep(2)
```

**变体示例**

| 学生情况 | 调整方案 | 说明 |
|----------|----------|------|
| 中文显示乱码 | 检查字体 | 确认使用DispChar而非text |
| 进度条方向反 | 调整计算 | 湿度高时进度条应该长 |
| 想加更多信息 | 分屏显示 | 用按键切换不同页面 |

---

**步骤3：硬件搭建（20分钟）** `#高负荷-产出` `#IFC-即时`

**教师话术**
> "今天使用板载OLED屏幕，不需要额外接线！
>
> 硬件连接和上节课一样：
> - 土壤湿度传感器 → P0
> - 水泵继电器 → P8
>
> 如果想加入更多传感器：
> - 光线传感器 → 板载
> - 温度传感器 → P1"

---

**步骤4：编程调试（30分钟）** `#高负荷-产出` `#IFC-即时`

**教师话术**
> "调试重点：
>
> 1. **屏幕显示**：
>    - 文字位置是否合适
>    - 中文是否正常显示
>    - 进度条是否正确
>
> 2. **数据更新**：
>    - 数值是否实时变化
>    - 状态是否正确切换
>
> 3. **整体联调**：
>    - 浇水时屏幕显示'浇水中'
>    - 正常时显示'湿润正常'"

**变体示例**

| 学生情况 | 调整方案 | 说明 |
|----------|----------|------|
| 屏幕闪烁 | 减少刷新频率 | 不要每次循环都清屏 |
| 想加图标 | 用画图函数 | oled.pixel()画点，oled.line()画线 |
| 想记录历史 | 用列表存储 | 保存最近10次的数值 |

---

**步骤5：成果展示（10分钟）** `#低负荷-热身` `#IFC-复盘`

**教师话术**
> "谁的可视化花房做好了？展示一下你的屏幕界面！
>
> 挑战：能不能加入更多功能？
> - 显示当前时间
> - 显示累计浇水次数
> - 显示光照强度"

---

**核心知识点**
- OLED显示：`oled.DispChar()` 显示文字
- 清屏和更新：`oled.fill(0)` + `oled.show()`
- 进度条：`oled.rect()` 画框 + `oled.fill_rect()` 填充
- 数据可视化：把数值转换为图形

**底层逻辑**
- **人机交互**：数据 → 可视化 → 用户理解
- **系统集成**：传感器 + 执行器 + 显示器

`#执行层` `#测评项`
[UID: PYAI-14-11-001]

---

### 1-4-12 家居回顾

#### 课程基本信息

| 项目 | 内容 |
|------|------|
| **课程编号** | 1-4-12 |
| **课程名称** | 家居回顾 - 物联网架构复盘 |
| **认知负荷** | 中 |
| **核心技能** | 物联网架构、AI流程、系统设计思维 |

#### 详细教学流程

**步骤1：课程导入（5分钟）** `#低负荷-热身` `#IFC-预防`

**教师话术**
> "同学们，这个单元我们做了很多智能硬件项目。今天我们来回顾总结，看看这些项目有什么共同点！"

---

**步骤2：知识回顾（20分钟）** `#中负荷-操练` `#IFC-即时`

**教师话术**
> "**物联网三层架构**：
>
> ```
> ┌─────────────────────────────────────┐
> │           应用层（执行）              │
> │   LED、RGB、蜂鸣器、电机、舵机、屏幕   │
> └─────────────────────────────────────┘
>                    ↑
> ┌─────────────────────────────────────┐
> │           处理层（决策）              │
> │      ESP32 + Python代码              │
> │      if判断、阈值比较、AI算法         │
> └─────────────────────────────────────┘
>                    ↑
> ┌─────────────────────────────────────┐
> │           感知层（输入）              │
> │   光线传感器、气体传感器、土壤传感器   │
> │   摄像头、温度传感器、按键            │
> └─────────────────────────────────────┘
> ```
>
> **我们做过的项目**：
>
> | 项目 | 感知层 | 处理层 | 应用层 |
> |------|--------|--------|--------|
> | 智能夜灯 | 光线传感器 | 阈值判断 | LED/RGB |
> | 智能通风 | 气体传感器 | 阈值判断 | 电机+蜂鸣器 |
> | 智能门禁 | 摄像头 | AI人脸识别 | 舵机 |
> | 智能花房 | 土壤传感器 | 阈值判断 | 水泵+OLED |"

**核心代码模式**

```python
# 物联网项目通用模板
from mpython import *
import time

# 1. 感知层：初始化传感器
sensor = Pin(Pin.P0, Pin.IN)

# 2. 应用层：初始化执行器
actuator = Pin(Pin.P8, Pin.OUT)

# 3. 处理层：设置阈值
THRESHOLD = 500

while True:
    # 感知：读取传感器
    value = sensor.read_analog()

    # 处理：判断决策
    if value > THRESHOLD:
        # 应用：执行动作
        actuator.write_digital(1)
    else:
        actuator.write_digital(0)

    time.sleep(1)
```

**变体示例**

| 学生情况 | 调整方案 | 说明 |
|----------|----------|------|
| 概念混淆 | 用具体例子 | "光线传感器是感知层，LED是应用层" |
| 想设计新项目 | 引导思考 | "你想感知什么？执行什么？" |
| 忘记某个项目 | 快速回顾 | 展示之前的代码和硬件 |

---

**步骤3：AI流程复盘（15分钟）** `#中负荷-操练` `#IFC-即时`

**教师话术**
> "**AI视觉流程**（智能门禁）：
>
> ```
> 摄像头采集 → 灰度处理 → 特征提取 → 模板匹配 → 决策输出
>     ↓            ↓           ↓           ↓          ↓
>   frame      cvtColor    matchTemplate  相似度    开门/拒绝
> ```
>
> **AI的本质**：
> - 输入：传感器数据（图像、声音、数值）
> - 处理：算法分析（匹配、分类、预测）
> - 输出：决策结果（开门、报警、浇水）
>
> **AI和普通程序的区别**：
> - 普通程序：固定规则（if value > 500）
> - AI程序：学习规则（从数据中学习判断标准）"

---

**步骤4：方案设计（25分钟）** `#高负荷-产出` `#IFC-即时`

**教师话术**
> "现在请设计一个**智能家居方案**！
>
> 要求：
> 1. 选择至少2个传感器
> 2. 选择至少2个执行器
> 3. 画出系统架构图
> 4. 写出核心代码逻辑
>
> 示例：**智能卧室**
> - 感知：光线传感器 + 温度传感器
> - 处理：ESP32判断
> - 应用：窗帘电机 + 空调控制 + 夜灯
>
> 逻辑：
> - 光线暗 + 晚上 → 开夜灯
> - 温度高 → 开空调
> - 早上 + 光线亮 → 开窗帘"

**变体示例**

| 学生情况 | 调整方案 | 说明 |
|----------|----------|------|
| 没有思路 | 提供场景 | "想想厨房/浴室/客厅需要什么" |
| 方案太简单 | 引导扩展 | "能不能加入手机控制？" |
| 方案太复杂 | 简化聚焦 | "先实现最核心的功能" |

---

**步骤5：成果展示（15分钟）** `#低负荷-热身` `#IFC-复盘`

**教师话术**
> "请上来展示你的智能家居方案！
>
> 评价标准：
> - 创意性：解决了什么实际问题？
> - 可行性：技术上能否实现？
> - 完整性：三层架构是否完整？"

---

**核心知识点**
- 物联网三层架构：感知层 → 处理层 → 应用层
- AI视觉流程：采集 → 处理 → 匹配 → 决策
- 系统设计思维：从需求出发，分层设计

**底层逻辑**
- **系统思维**：把复杂问题分解为三层
- **工程思维**：从设计到实现的完整流程

`#执行层` `#测评项`
[UID: PYAI-14-12-001]
[关联: PYAI-24-001 PythonAI计算机视觉（进阶衔接）]

---

## 教学禁忌清单（硬件安全红线）

| 序号 | 禁忌 | 原因 | 正确做法 |
|------|------|------|----------|
| 1 | ❌ **带电接线** | 短路烧毁开发板 | 必须断电后再接线 |
| 2 | ❌ **短路（VCC直接接GND）** | 烧毁开发板 | 红线(VCC)和黑线(GND)绝对不能直接连接 |
| 3 | ❌ **开发板放金属表面通电** | 底部引脚短路 | 放在绝缘表面（桌面、纸板） |
| 4 | ❌ **强行扭动舵机** | 损坏内部齿轮 | 不要用力手动扭转舵机摆臂 |
| 5 | ❌ **在boot.py写死循环无延时** | 开发板无法重新连接 | 谨慎编辑启动文件 |
| 6 | ❌ **忘记释放摄像头** | 下次无法使用 | 程序结束前调用cap.release() |

`#执行层` `#测评项`
[UID: PYAI-TABOO-14]

---

## 教学注意事项

| 类别 | 注意事项 |
|------|----------|
| **硬件保护** | 开发板不要放在金属表面通电；接线前必须断电 |
| **舵机使用** | 通电或未通电状态下不要强行手动扭转 |
| **库导入** | 建议使用standard形式（如import machine），避免命名空间污染 |
| **调试技巧** | 用print()输出传感器数值，确认硬件正常工作 |

---

## 底层教育学原理

| 原理 | 说明 | 在本单元的应用 |
|------|------|----------------|
| **物联网架构** | 感知层-网络层-应用层 | 传感器→ESP32/Python→执行器 |
| **AI视觉流程** | 采集-处理-输出 | 摄像头→灰度/匹配→舵机控制 |
| **软硬结合** | 代码驱动物理硬件 | Python控制LED、电机、舵机 |
| **项目制学习** | 完整项目驱动学习 | 智能夜灯、智能门禁、智能花房 |

`#执行层` `#测评项`
[UID: PYAI-THEORY-14]

---

**质量评估**：10/10（原子化萃取版，10节课完整萃取）
**已补充**：认知负荷标签、IFC标签、变体示例、详细教师话术、硬件安全禁忌、核心代码模式
**课程覆盖**：1-4-1, 1-4-3, 1-4-4, 1-4-5, 1-4-6/7/8, 1-4-10, 1-4-11, 1-4-12 全部10节课

---

**最后更新**：2026-02-09
