# PythonAI萃取：L2-2 项目应用

> **来源**：NotebookLM Python AI Lesson Plan (96个来源)
> **萃取日期**：2026-02-09
> **萃取深度**：5-5多维度（含认知负荷标签、IFC标签、变体示例）
> **更新日期**：2026-02-09

---

## 单元概览

| 项目 | 内容 |
|------|------|
| **单元编号** | PYAI 2-2 |
| **单元名称** | 项目应用 |
| **适用年龄** | 四年级及以上（10-12岁） |
| **课时数** | 12节 × 90分钟 |
| **核心目标** | 掌握Pygame游戏开发与物理仿真，实现面向对象编程的综合应用 |
| **主要平台** | Python IDLE + Pygame |

**底层逻辑**
从面向过程转向面向对象编程，通过游戏开发项目理解类与实例、碰撞检测、物理仿真等核心概念。

**单元教��策略**
- 面向对象（01）：类和对象基础
- Pygame入门（02-03）：文字绘制、弹幕生成
- 图形绘制（04-06）：pygame.draw、蒙特卡洛、星空特效
- 游戏开发（07-08）：球球大作战、贪食蛇
- 物理仿真（09-11）：大炮射击系列、Pymunk引擎
- 阶段复习（12）：知识整合

`#执行层` `#测评项`
[UID: PYAI-22-001]
[关联: PYAI-21-001 PythonAI算法数据科学（前置基础）]
[关联: PYAI-11-001 PythonAI函数封装（前置基础）]
[关联: PYAI-23-001 PythonAI交互式AI（进阶衔接）]

---

## 课程列表

| 课次 | 课程名称 | 核心知识点 | 项目内容 | 认知负荷 |
|------|----------|------------|----------|----------|
| 2-2-1 | 脚踏实地 | class定义、实例创建、self、__init__ | 类和对象 | 高 |
| 2-2-2 | 电子成绩单 | IDLE环境、Pygame初识、文字绘制 | 电子成绩单 | 中-高 |
| 2-2-3 | 弹幕生成器 | Pygame综合、Random/Time模块、类实例应用 | 弹幕生成器 | 高 |
| 2-2-4 | 规矩方圆 | pygame.draw.line()、二维列表、RGB色彩 | 规矩方圆 | 中-高 |
| 2-2-5 | 蒙特卡洛法 | pygame.draw.circle()、距离公式、蒙特卡洛算法 | 求圆周率 | 高 |
| 2-2-6 | 弱肉强食 | 随机模块、类属性控制、for循环高级用法 | 星空特效 | 中-高 |
| 2-2-7 | 积小致巨1 | 按键交互、碰撞检测、列表动态操作 | 球球大作战 | 高 |
| 2-2-8 | 积小致巨2 | 多角色联动、列表数据存取、贪食蛇逻辑 | 贪食蛇 | 高 |
| 2-2-9 | 举重若轻1 | 图像导入变换、能量值变化、游戏环节控制 | 大炮射击1 | 高 |
| 2-2-10 | 举重若轻2 | 物理运动原理、加速度、速度合并 | 大炮射击2 | 高 |
| 2-2-11 | 举重若轻3 | 向量拆分合并、爆炸效果、音频加载 | 大炮射击3 | 高 |
| 2-2-12 | 阶段复习 | 综合复习Pygame与OOP | 阶段测试 | 中 |

---

## 通用教学流程（90分钟）

| 环节 | 时间 | 内容 | 认知负荷 | IFC标签 |
|------|------|------|----------|---------|
| 课堂问候 | 2分钟 | 自我介绍、学习目标 | `#低负荷-热身` | `#IFC-预防` |
| 课程回顾 | 5分钟 | 复习上节课代码知识 | `#低负荷-热身` | `#IFC-预防` |
| 知识讲解 | 20分钟 | 新概念/语法讲解 | `#中负荷-操练` | `#IFC-即时` |
| 代码实践 | 40分钟 | 编写游戏代码、调试 | `#高负荷-产出` | `#IFC-即时` |
| 调节休息 | 3分钟 | 站起来活动 | `#调节-放松` | - |
| 项目拓展 | 10分钟 | 功能扩展/创意改进 | `#高负荷-产出` | `#IFC-即时` |
| 成果展示 | 10分钟 | 演示游戏、分享思路 | `#低负荷-热身` | `#IFC-复盘` |

`#执行层` `#测评项`
[UID: PYAI-22-FLOW-001]

---

## 详细课程萃取

### 2-2-1 脚踏实地（典型案例）

#### 课程基本信息

| 项目 | 内容 |
|------|------|
| **课程编号** | 2-2-1 |
| **课程名称** | 脚踏实地 |
| **认知负荷** | 高 |
| **核心技能** | class定义、实例创建、self、__init__ |

#### 详细教学流程

**步骤1：知识讲解（20分钟）** `#中负荷-操练` `#IFC-即时`

**教师话术**
> "今天我们学习一个超级重要的概念——**面向对象编程(OOP)**！之前我们写的代码是'面向过程'的，一步一步执行。现在要学习把数据和动作'打包'在一起。"
>
> "**类(Class)和实例(Instance)**：
> - 类是**模板/蓝图**，定义了一类事物的共同特征
> - 实例是根据类创建的**具体对象**
>
> 比喻：类就像'做饼干的模具'，实例就是用模具压出来的'饼干'。"
>
> "**定义类的语法**：
> ```python
> class Dog:
>     # 属性（特征）
>     name = '小白'
>     color = '白色'
>
>     # 方法（行为）
>     def bark(self):
>         print('汪汪！')
>
> # 创建实例
> dog1 = Dog()
> dog1.name = '旺财'
> dog1.bark()  # 输出：汪汪！
> ```"

**核心代码模式**

```python
# 1. 定义类
class Student:
    # 初始化方法，创建对象时自动调用
    def __init__(self, name, score):
        self.name = name   # 实例属性
        self.score = score

    # 实例方法
    def introduce(self):
        print(f'我是{self.name}，考了{self.score}分')

# 2. 创建实例
s1 = Student('小明', 98)
s2 = Student('小红', 100)

# 3. 调用方法
s1.introduce()  # 输出：我是小明，考了98分
```

**变体示例**

| 学生情况 | 调整方案 | 说明 |
|----------|----------|------|
| 不理解类和实例 | 用模具类比 | "类是模具，实例是用模具做出来的饼干" |
| 忘记写self | 强调规则 | "方法的第一个参数必须是self，代表'我自己'" |
| __init__写错 | 强调双下划线 | "左右各两个下划线，不是单下划线" |
| 混淆类属性和实例属性 | 演示区别 | 修改dog1.name不影响dog2.name |

**禁忌提醒**
❌ 方法定义忘记self——TypeError错误
❌ __init__写成_init_——不会自动调用
❌ 类名用小写——应该用大驼峰命名法

---

**核心知识点**
- 类(Class)：抽象的模板/蓝图
- 实例(Instance)：具体的对象
- self：代表实例本身
- __init__：初始化方法，创建实例时自动调用

**底层逻辑**
- **封装思想**：把数据和操作数据的方法打包在一起
- **代码复用**：一个类可以创建多个实例

`#执行层` `#测评项`
[UID: PYAI-22-01-001]
[关联: PYAI-11-01-001 函数定义（前置基础）]

---

### 2-2-2 电子成绩单

#### 课程基本信息

| 项目 | 内容 |
|------|------|
| **课程编号** | 2-2-2 |
| **课程名称** | 电子成绩单 |
| **认知负荷** | 中-高 |
| **核心技能** | IDLE环境、Pygame初识、文字绘制 |

#### 详细教学流程

**步骤1：知识讲解（20分钟）** `#中负荷-操练` `#IFC-即时`

**教师话术**
> "今天我们开始学习**Pygame**——Python最流行的游戏开发库！先从最简单的开始：在窗口上显示文字。"
>
> "**Pygame基础结构**：
> ```python
> import pygame
>
> # 1. 初始化
> pygame.init()
>
> # 2. 创建窗口
> screen = pygame.display.set_mode((800, 600))
> pygame.display.set_caption('我的第一个Pygame程序')
>
> # 3. 游戏主循环
> running = True
> while running:
>     for event in pygame.event.get():
>         if event.type == pygame.QUIT:
>             running = False
>
>     # 填充背景色
>     screen.fill((255, 255, 255))
>
>     # 更新显示
>     pygame.display.flip()
>
> pygame.quit()
> ```"

**核心代码模式**

```python
import pygame

pygame.init()
screen = pygame.display.set_mode((800, 600))

# 创建字体对象
font = pygame.font.Font(None, 48)  # None使用默认字体，48是字号

# 渲染文字（文字内容, 抗锯齿, 颜色）
text = font.render('Hello Pygame!', True, (0, 0, 0))

running = True
while running:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False

    screen.fill((255, 255, 255))

    # 绘制文字到屏幕
    screen.blit(text, (100, 100))  # (x, y)坐标

    pygame.display.flip()

pygame.quit()
```

**变体示例**

| 学生情况 | 调整方案 | 说明 |
|----------|----------|------|
| 窗口闪退 | 检查主循环 | 确保while循环正确运行 |
| 中文显示乱码 | 使用中文字体 | pygame.font.Font('simhei.ttf', 48) |
| 想改变颜色 | 解释RGB | (255,0,0)红色，(0,255,0)绿色 |

---

**核心知识点**
- Pygame初始化：`pygame.init()`
- 创建窗口：`pygame.display.set_mode((宽, 高))`
- 游戏主循环：while循环 + 事件处理
- 文字渲染：`font.render()` + `screen.blit()`

`#执行层` `#测评项`
[UID: PYAI-22-02-001]

---

### 2-2-3 弹幕生成器

#### 课程基本信息

| 项目 | 内容 |
|------|------|
| **课程编号** | 2-2-3 |
| **课程名称** | 弹幕生成器 |
| **认知负荷** | 高 |
| **核心技能** | Pygame综合、Random/Time模块、类实例应用 |

#### 详细教学流程

**步骤1：知识讲解（20分钟）** `#中负荷-操练` `#IFC-即时`

**教师话术**
> "今天我们做一个**弹幕生成器**！就像B站视频上飘过的弹幕一样。这个项目会用到上节课学的类和Pygame。"
>
> "**弹幕的本质**：
> - 每条弹幕是一个**对象**（有位置、速度、内容）
> - 弹幕从右边出现，向左移动
> - 用**列表**管理多条弹幕"

**核心代码模式**

```python
import pygame
import random

# 弹幕类
class Danmaku:
    def __init__(self, text, y):
        self.text = text
        self.x = 800  # 从右边开始
        self.y = y
        self.speed = random.randint(3, 8)
        self.color = (random.randint(0,255), random.randint(0,255), random.randint(0,255))

    def move(self):
        self.x -= self.speed  # 向左移动

    def draw(self, screen, font):
        text_surface = font.render(self.text, True, self.color)
        screen.blit(text_surface, (self.x, self.y))

# 主程序
pygame.init()
screen = pygame.display.set_mode((800, 600))
font = pygame.font.Font(None, 36)

danmaku_list = []
messages = ['Hello!', 'Pygame真好玩', '666', '前方高能']

running = True
frame_count = 0
while running:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False

    # 每60帧生成一条弹幕
    frame_count += 1
    if frame_count % 60 == 0:
        text = random.choice(messages)
        y = random.randint(50, 550)
        danmaku_list.append(Danmaku(text, y))

    screen.fill((0, 0, 0))

    # 更新和绘制所有弹幕
    for d in danmaku_list:
        d.move()
        d.draw(screen, font)

    # 移除已经飘出屏幕的弹幕
    danmaku_list = [d for d in danmaku_list if d.x > -200]

    pygame.display.flip()
    pygame.time.delay(16)  # 约60FPS

pygame.quit()
```

**变体示例**

| 学生情况 | 调整方案 | 说明 |
|----------|----------|------|
| 弹幕太快/太慢 | 调整speed范围 | 修改random.randint的参数 |
| 想添加自定义弹幕 | 加入input | 用pygame.KEYDOWN捕获输入 |
| 弹幕重叠 | 优化y坐标 | 检测已有弹幕位置避免重叠 |

---

**核心知识点**
- 类的综合应用：封装弹幕的属性和行为
- 列表管理对象：存储多个弹幕实例
- 列表推导式：过滤已消失的弹幕
- 帧率控制：`pygame.time.delay()`

`#执行层` `#测评项`
[UID: PYAI-22-03-001]

---

### 2-2-4 规矩方圆

#### 课程基本信息

| 项目 | 内容 |
|------|------|
| **课程编号** | 2-2-4 |
| **课程名称** | 规矩方圆 |
| **认知负荷** | 中-高 |
| **核心技能** | pygame.draw.line()、二维列表、RGB色彩 |

#### 详细教学流程

**步骤1：知识讲解（20分钟）** `#中负荷-操练` `#IFC-即时`

**教师话术**
> "今天学习Pygame的**绑图函数**！用代码画出各种图形。"
>
> "**pygame.draw模块**：
> ```python
> # 画线
> pygame.draw.line(screen, color, start_pos, end_pos, width)
>
> # 画矩形
> pygame.draw.rect(screen, color, (x, y, width, height), width)
>
> # 画圆
> pygame.draw.circle(screen, color, center, radius, width)
> ```
>
> **RGB色彩**：
> - (255, 0, 0) = 红色
> - (0, 255, 0) = 绿色
> - (0, 0, 255) = 蓝色
> - (255, 255, 255) = 白色
> - (0, 0, 0) = 黑色"

**核心代码模式**

```python
import pygame

pygame.init()
screen = pygame.display.set_mode((800, 600))

running = True
while running:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False

    screen.fill((255, 255, 255))

    # 画线（红色，从(100,100)到(300,300)，宽度3）
    pygame.draw.line(screen, (255, 0, 0), (100, 100), (300, 300), 3)

    # 画矩形（蓝色，位置(400,100)，大小200x150，边框宽度2）
    pygame.draw.rect(screen, (0, 0, 255), (400, 100, 200, 150), 2)

    # 画填充矩形（宽度为0表示填充）
    pygame.draw.rect(screen, (0, 255, 0), (400, 300, 200, 150), 0)

    # 画圆（黄色，圆心(200,400)，半径50，填充）
    pygame.draw.circle(screen, (255, 255, 0), (200, 400), 50, 0)

    pygame.display.flip()

pygame.quit()
```

**变体示例**

| 学生情况 | 调整方案 | 说明 |
|----------|----------|------|
| 分不清填充和边框 | 演示width参数 | width=0填充，width>0画边框 |
| 想画更多图形 | 介绍其他函数 | polygon多边形、ellipse椭圆 |
| 颜色不对 | 检查RGB顺序 | 是(R,G,B)不是(B,G,R) |

---

**核心知识点**
- pygame.draw.line()：画线
- pygame.draw.rect()：画矩形
- pygame.draw.circle()：画圆
- RGB色彩模型：三原色混合

`#执行层` `#测评项`
[UID: PYAI-22-04-001]

---

### 2-2-5 蒙特卡洛法

#### 课程基本信息

| 项目 | 内容 |
|------|------|
| **课程编号** | 2-2-5 |
| **课程名称** | 蒙特卡洛法 |
| **认知负荷** | 高 |
| **核心技能** | pygame.draw.circle()、距离公式、蒙特卡洛算法 |

#### 详细教学流程

**步骤1：知识讲解（20分钟）** `#中负荷-操练` `#IFC-即时`

**教师话术**
> "今天我们用**随机数**来计算**圆周率π**！这种方法叫**蒙特卡洛法**。"
>
> "**原理**：
> 1. 画一个正方形，边长为2r
> 2. 在正方形内画一个内切圆，半径为r
> 3. 随机撒点，统计落在圆内的点数
> 4. 圆内点数/总点数 ≈ 圆面积/正方形面积 = πr²/(2r)² = π/4
> 5. 所以 π ≈ 4 × (圆内点数/总点数)"
>
> "**判断点是否在圆内**：
> - 计算点到圆心的距离
> - 距离公式：d = √((x-cx)² + (y-cy)²)
> - 如果 d ≤ r，点在圆内"

**核心代码模式**

```python
import pygame
import random
import math

pygame.init()
screen = pygame.display.set_mode((600, 600))
font = pygame.font.Font(None, 36)

# 圆心和半径
cx, cy = 300, 300
radius = 250

inside_count = 0
total_count = 0

running = True
while running:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False

    # 每帧撒10个点
    for _ in range(10):
        x = random.randint(cx - radius, cx + radius)
        y = random.randint(cy - radius, cy + radius)

        # 计算到圆心的距离
        distance = math.sqrt((x - cx)**2 + (y - cy)**2)

        total_count += 1
        if distance <= radius:
            inside_count += 1
            color = (255, 0, 0)  # 圆内红色
        else:
            color = (0, 0, 255)  # 圆外蓝色

        pygame.draw.circle(screen, color, (x, y), 2)

    # 计算π的估计值
    if total_count > 0:
        pi_estimate = 4 * inside_count / total_count
        text = font.render(f'Pi = {pi_estimate:.6f}', True, (0, 0, 0))
        pygame.draw.rect(screen, (255, 255, 255), (10, 10, 200, 40))
        screen.blit(text, (20, 20))

    pygame.display.flip()
    pygame.time.delay(10)

pygame.quit()
```

**变体示例**

| 学生情况 | 调整方案 | 说明 |
|----------|----------|------|
| 不理解蒙特卡洛 | 用投飞镖类比 | "随机投飞镖，统计落在靶心的比例" |
| π值不准确 | 增加点数 | 点越多越接近真实值 |
| 想加速计算 | 减少绘制 | 不是每个点都画出来 |

---

**核心知识点**
- 蒙特卡洛算法：用随机数模拟概率
- 距离公式：d = √((x₁-x₂)² + (y₁-y₂)²)
- 概率与面积的关系

**底层逻辑**
- **随机模拟**：用大量随机样本逼近真实结果
- **数学应用**：几何概率在编程中的应用

`#执行层` `#测评项`
[UID: PYAI-22-05-001]

---

### 2-2-6 弱肉强食

#### 课程基本信息

| 项目 | 内容 |
|------|------|
| **课程编号** | 2-2-6 |
| **课程名称** | 弱肉强食 |
| **认知负荷** | 中-高 |
| **核心技能** | 随机模块、类属性控制、for循环高级用法 |

#### 详细教学流程

**步骤1：知识讲解（20分钟）** `#中负荷-操练` `#IFC-即时`

**教师话术**
> "今天我们做一个**星空特效**！屏幕上有很多星星，它们会移动、闪烁。"
>
> "**设计思路**：
> 1. 每颗星星是一个对象（有位置、大小、速度、亮度）
> 2. 用列表管理所有星星
> 3. 每帧更新星星的位置和亮度"

**核心代码模式**

```python
import pygame
import random

class Star:
    def __init__(self):
        self.x = random.randint(0, 800)
        self.y = random.randint(0, 600)
        self.size = random.randint(1, 3)
        self.speed = random.uniform(0.5, 2.0)
        self.brightness = random.randint(100, 255)
        self.twinkle_speed = random.uniform(1, 5)

    def update(self):
        # 移动
        self.y += self.speed
        if self.y > 600:
            self.y = 0
            self.x = random.randint(0, 800)

        # 闪烁
        self.brightness += self.twinkle_speed
        if self.brightness > 255 or self.brightness < 100:
            self.twinkle_speed = -self.twinkle_speed

    def draw(self, screen):
        b = int(self.brightness)
        color = (b, b, b)
        pygame.draw.circle(screen, color, (int(self.x), int(self.y)), self.size)

pygame.init()
screen = pygame.display.set_mode((800, 600))

# 创建100颗星星
stars = [Star() for _ in range(100)]

running = True
while running:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False

    screen.fill((0, 0, 30))  # 深蓝色背景

    for star in stars:
        star.update()
        star.draw(screen)

    pygame.display.flip()
    pygame.time.delay(16)

pygame.quit()
```

**变体示例**

| 学生情况 | 调整方案 | 说明 |
|----------|----------|------|
| 星星太少 | 增加数量 | 把100改成200或更多 |
| 想要彩色星星 | 修改颜色 | 随机生成RGB颜色 |
| 想加流星 | 新建流星类 | 速度更快、有尾迹 |

---

**核心知识点**
- 类属性的动态变化
- 列表推导式创建对象
- 边界检测和重置

`#执行层` `#测评项`
[UID: PYAI-22-06-001]

---

### 2-2-7 积小致巨1

#### 课程基本信息

| 项目 | 内容 |
|------|------|
| **课程编号** | 2-2-7 |
| **课程名称** | 积小致巨1 |
| **认知负荷** | 高 |
| **核心技能** | 按键交互、碰撞检测、列表动态操作 |

#### 详细教学流程

**步骤1：知识讲解（20分钟）** `#中负荷-操练` `#IFC-即时`

**教师话术**
> "今天我们做一个**球球大作战**游戏！玩家控制一个球，吃掉小球变大，碰到大球就游戏结束。"
>
> "**按键交互**：用键盘控制角色移动
> ```python
> keys = pygame.key.get_pressed()
> if keys[pygame.K_LEFT]:
>     player_x -= speed
> if keys[pygame.K_RIGHT]:
>     player_x += speed
> if keys[pygame.K_UP]:
>     player_y -= speed
> if keys[pygame.K_DOWN]:
>     player_y += speed
> ```
>
> **碰撞检测**：判断两个圆是否相交
> ```python
> def check_collision(x1, y1, r1, x2, y2, r2):
>     distance = math.sqrt((x1-x2)**2 + (y1-y2)**2)
>     return distance < r1 + r2  # 距离小于半径之和就碰撞
> ```"

**核心代码模式**

```python
import pygame
import random
import math

pygame.init()
screen = pygame.display.set_mode((800, 600))

# 玩家
player_x, player_y = 400, 300
player_radius = 20
speed = 5

# 食物球列表
foods = []
for _ in range(20):
    foods.append({
        'x': random.randint(50, 750),
        'y': random.randint(50, 550),
        'radius': random.randint(5, 15),
        'color': (random.randint(50,255), random.randint(50,255), random.randint(50,255))
    })

def check_collision(x1, y1, r1, x2, y2, r2):
    distance = math.sqrt((x1-x2)**2 + (y1-y2)**2)
    return distance < r1 + r2

running = True
while running:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False

    # 按键控制
    keys = pygame.key.get_pressed()
    if keys[pygame.K_LEFT]: player_x -= speed
    if keys[pygame.K_RIGHT]: player_x += speed
    if keys[pygame.K_UP]: player_y -= speed
    if keys[pygame.K_DOWN]: player_y += speed

    # 边界限制
    player_x = max(player_radius, min(800-player_radius, player_x))
    player_y = max(player_radius, min(600-player_radius, player_y))

    # 碰撞检测
    for food in foods[:]:  # 用切片复制列表，避免遍历时修改
        if check_collision(player_x, player_y, player_radius,
                          food['x'], food['y'], food['radius']):
            if player_radius > food['radius']:
                # 吃掉小球，变大
                player_radius += food['radius'] // 3
                foods.remove(food)

    screen.fill((30, 30, 30))

    # 绘制食物
    for food in foods:
        pygame.draw.circle(screen, food['color'], (food['x'], food['y']), food['radius'])

    # 绘制玩家
    pygame.draw.circle(screen, (0, 255, 0), (int(player_x), int(player_y)), player_radius)

    pygame.display.flip()
    pygame.time.delay(16)

pygame.quit()
```

**变体示例**

| 学生情况 | 调整方案 | 说明 |
|----------|----------|------|
| 移动太快/太慢 | 调整speed | 根据手感调整移动速度 |
| 想加敌人 | 添加AI球 | 敌人球会追踪玩家 |
| 碰撞不准 | 检查半径 | 确保碰撞检测使用正确的半径 |

**禁忌提醒**
❌ 遍历列表时直接删除元素——会跳过元素，用切片复制
❌ 忘记边界限制——球会跑出屏幕

---

**核心知识点**
- 按键交互：`pygame.key.get_pressed()`
- 碰撞检测：圆形碰撞（距离 < 半径之和）
- 列表动态操作：遍历时安全删除元素

`#执行层` `#测评项`
[UID: PYAI-22-07-001]

---

### 2-2-8 积小致巨2

#### 课程基本信息

| 项目 | 内容 |
|------|------|
| **课程编号** | 2-2-8 |
| **课程名称** | 积小致巨2 |
| **认知负荷** | 高 |
| **核心技能** | 多角色联动、列表数据存取、贪食蛇逻辑 |

#### 详细教学流程

**步骤1：知识讲解（20分钟）** `#中负荷-操练` `#IFC-即时`

**教师话术**
> "今天做经典游戏**贪食蛇**！蛇的身体是一串方块，吃到食物就变长。"
>
> "**贪食蛇的核心逻辑**：
> 1. 蛇身用**列表**存储每个方块的坐标
> 2. 移动时：头部添加新位置，尾部删除
> 3. 吃到食物：头部添加，尾部不删除（变长）
>
> ```python
> snake = [(100, 100), (80, 100), (60, 100)]  # 头在前
> direction = (20, 0)  # 向右移动
>
> # 移动
> new_head = (snake[0][0] + direction[0], snake[0][1] + direction[1])
> snake.insert(0, new_head)  # 头部添加
> snake.pop()  # 尾部删除
> ```"

**核心代码模式**

```python
import pygame
import random

pygame.init()
screen = pygame.display.set_mode((800, 600))

GRID_SIZE = 20

# 蛇身（列表存储坐标）
snake = [(200, 200), (180, 200), (160, 200)]
direction = (GRID_SIZE, 0)  # 初始向右

# 食物
food = (random.randint(0, 39) * GRID_SIZE, random.randint(0, 29) * GRID_SIZE)

score = 0
game_over = False

running = True
while running:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_LEFT and direction != (GRID_SIZE, 0):
                direction = (-GRID_SIZE, 0)
            elif event.key == pygame.K_RIGHT and direction != (-GRID_SIZE, 0):
                direction = (GRID_SIZE, 0)
            elif event.key == pygame.K_UP and direction != (0, GRID_SIZE):
                direction = (0, -GRID_SIZE)
            elif event.key == pygame.K_DOWN and direction != (0, -GRID_SIZE):
                direction = (0, GRID_SIZE)

    if not game_over:
        # 计算新头部位置
        new_head = (snake[0][0] + direction[0], snake[0][1] + direction[1])

        # 边界检测
        if new_head[0] < 0 or new_head[0] >= 800 or new_head[1] < 0 or new_head[1] >= 600:
            game_over = True

        # 自身碰撞检测
        if new_head in snake:
            game_over = True

        if not game_over:
            snake.insert(0, new_head)

            # 吃到食物
            if new_head == food:
                score += 10
                food = (random.randint(0, 39) * GRID_SIZE, random.randint(0, 29) * GRID_SIZE)
            else:
                snake.pop()  # 没吃到就删除尾部

    # 绘制
    screen.fill((0, 0, 0))

    # 绘制食物
    pygame.draw.rect(screen, (255, 0, 0), (food[0], food[1], GRID_SIZE-2, GRID_SIZE-2))

    # 绘制蛇
    for i, segment in enumerate(snake):
        color = (0, 255, 0) if i == 0 else (0, 200, 0)  # 头部亮一点
        pygame.draw.rect(screen, color, (segment[0], segment[1], GRID_SIZE-2, GRID_SIZE-2))

    pygame.display.flip()
    pygame.time.delay(100)  # 控制蛇的速度

pygame.quit()
```

**变体示例**

| 学生情况 | 调整方案 | 说明 |
|----------|----------|------|
| 蛇移动太快 | 增加delay | 把100改成150或200 |
| 想加障碍物 | 添加墙壁列表 | 碰到墙壁也游戏结束 |
| 想显示分数 | 用font渲染 | 在屏幕上显示当前分数 |

**禁忌提醒**
❌ 允许180度转向——蛇会撞到自己
❌ 食物生成在蛇身上——需要检测避免

---

**核心知识点**
- 列表作为数据结构：存储蛇身坐标
- insert()和pop()：实现蛇的移动
- 方向控制：防止180度转向

**底层逻辑**
- **队列思想**：头部入队，尾部出队
- **状态管理**：用变量控制游戏状态

`#执行层` `#测评项`
[UID: PYAI-22-08-001]

---

### 2-2-9 举重若轻1

#### 课程基本信息

| 项目 | 内容 |
|------|------|
| **课程编号** | 2-2-9 |
| **课程名称** | 举重若轻1 |
| **认知负荷** | 高 |
| **核心技能** | 图像导入变换、能量值变化、游戏环节控制 |

#### 详细教学流程

**步骤1：知识讲解（20分钟）** `#中负荷-操练` `#IFC-即时`

**教师话术**
> "今天开始做一个**大炮射击**游戏！这是一个三节课的大项目，我们会学到图像处理、物理运动、音效等很多知识。"
>
> "**Pygame图像加载**：
> ```python
> import pygame
>
> # 加载图像
> cannon_img = pygame.image.load('cannon.png')
>
> # 缩放图像
> cannon_img = pygame.transform.scale(cannon_img, (100, 50))
>
> # 旋转图像（角度，逆时针为正）
> rotated = pygame.transform.rotate(cannon_img, 45)
>
> # 绘制到屏幕
> screen.blit(cannon_img, (x, y))
> ```
>
> **能量条设计**：
> - 按住空格键蓄力，能量值增加
> - 松开空格键发射，能量值决定初速度"

**核心代码模式**

```python
import pygame

pygame.init()
screen = pygame.display.set_mode((800, 600))

# 加载图像
cannon_img = pygame.image.load('cannon.png')
cannon_img = pygame.transform.scale(cannon_img, (80, 40))

# 大炮位置和角度
cannon_x, cannon_y = 50, 500
cannon_angle = 45

# 能量系统
energy = 0
max_energy = 100
charging = False

running = True
while running:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_SPACE:
                charging = True
        if event.type == pygame.KEYUP:
            if event.key == pygame.K_SPACE:
                charging = False
                # 发射炮弹（下节课实现）
                print(f'发射！能量：{energy}')
                energy = 0

    # 蓄力
    if charging and energy < max_energy:
        energy += 2

    # 角度控制
    keys = pygame.key.get_pressed()
    if keys[pygame.K_UP] and cannon_angle < 80:
        cannon_angle += 1
    if keys[pygame.K_DOWN] and cannon_angle > 10:
        cannon_angle -= 1

    screen.fill((135, 206, 235))  # 天蓝色背景

    # 绘制大炮（旋转）
    rotated_cannon = pygame.transform.rotate(cannon_img, cannon_angle)
    screen.blit(rotated_cannon, (cannon_x, cannon_y - cannon_angle))

    # 绘制能量条
    pygame.draw.rect(screen, (100, 100, 100), (20, 20, 104, 24))  # 边框
    pygame.draw.rect(screen, (0, 255, 0), (22, 22, energy, 20))   # 能量

    pygame.display.flip()
    pygame.time.delay(16)

pygame.quit()
```

**变体示例**

| 学生情况 | 调整方案 | 说明 |
|----------|----------|------|
| 图像加载失败 | 检查路径 | 确认图片文件在正确位置 |
| 旋转后图像变形 | 解释原理 | 旋转会改变图像尺寸，需要调整位置 |
| 能量条不显示 | 检查坐标 | 确认绘制位置在屏幕范围内 |

**禁忌提醒**
❌ 图像路径错误——FileNotFoundError
❌ 忘记convert()——大图像可能卡顿

---

**核心知识点**
- 图像加载：`pygame.image.load()`
- 图像变换：`pygame.transform.scale()` / `rotate()`
- 能量系统：按键蓄力、松开释放
- 游戏状态：用变量控制不同阶段

`#执行层` `#测评项`
[UID: PYAI-22-09-001]

---

### 2-2-10 举重若轻2

#### 课程基本信息

| 项目 | 内容 |
|------|------|
| **课程编号** | 2-2-10 |
| **课程名称** | 举重若轻2 |
| **认知负荷** | 高 |
| **核心技能** | 物理运动原理、加速度、速度合并 |

#### 详细教学流程

**步骤1：知识讲解（20分钟）** `#中负荷-操练` `#IFC-即时`

**教师话术**
> "今天我们要让炮弹'飞'起来！这需要用到**物理学**的知识。"
>
> "**抛物线运动**：
> - 水平方向：匀速运动，vx不变
> - 垂直方向：受重力影响，vy不断增加
>
> ```python
> # 物理参数
> gravity = 0.5  # 重力加速度
> vx = 10        # 水平速度（不变）
> vy = -15       # 垂直速度（负数表示向上）
>
> # 每帧更新
> x += vx        # 水平位移
> vy += gravity  # 垂直速度增加（重力）
> y += vy        # 垂直位移
> ```
>
> **速度分解**：
> - 初速度v和角度θ
> - vx = v × cos(θ)
> - vy = v × sin(θ)（向上为负）"

**核心代码模式**

```python
import pygame
import math

pygame.init()
screen = pygame.display.set_mode((800, 600))

# 物理常量
GRAVITY = 0.3

# 炮弹类
class Bullet:
    def __init__(self, x, y, speed, angle):
        self.x = x
        self.y = y
        # 速度分解
        rad = math.radians(angle)
        self.vx = speed * math.cos(rad)
        self.vy = -speed * math.sin(rad)  # 向上为负
        self.active = True

    def update(self):
        if self.active:
            self.x += self.vx
            self.vy += GRAVITY  # 重力作用
            self.y += self.vy

            # 落地检测
            if self.y > 550:
                self.active = False

    def draw(self, screen):
        if self.active:
            pygame.draw.circle(screen, (50, 50, 50), (int(self.x), int(self.y)), 8)

# 炮弹列表
bullets = []

# 发射炮弹
def fire(x, y, energy, angle):
    speed = energy / 5  # 能量转换为速度
    bullet = Bullet(x, y, speed, angle)
    bullets.append(bullet)

# 主循环
cannon_angle = 45
energy = 0
charging = False

running = True
while running:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_SPACE:
                charging = True
        if event.type == pygame.KEYUP:
            if event.key == pygame.K_SPACE:
                charging = False
                fire(80, 480, energy, cannon_angle)
                energy = 0

    if charging and energy < 100:
        energy += 2

    keys = pygame.key.get_pressed()
    if keys[pygame.K_UP]: cannon_angle = min(80, cannon_angle + 1)
    if keys[pygame.K_DOWN]: cannon_angle = max(10, cannon_angle - 1)

    screen.fill((135, 206, 235))

    # 绘制地面
    pygame.draw.rect(screen, (34, 139, 34), (0, 550, 800, 50))

    # 更新和绘制炮弹
    for bullet in bullets:
        bullet.update()
        bullet.draw(screen)

    # 清理已落地的炮弹
    bullets = [b for b in bullets if b.active]

    pygame.display.flip()
    pygame.time.delay(16)

pygame.quit()
```

**变体示例**

| 学生情况 | 调整方案 | 说明 |
|----------|----------|------|
| 炮弹飞太快/太慢 | 调整speed计算 | 修改energy/5的系数 |
| 不理解三角函数 | 画图演示 | 用直角三角形解释sin/cos |
| 想加风力影响 | 引入wind变量 | vx += wind实现风力效果 |

**禁忌提醒**
❌ 忘记转换弧度——math.sin/cos需要弧度
❌ 重力方向错误——向下应该是正值

---

**核心知识点**
- 抛物线运动：水平匀速 + 垂直加速
- 速度分解：vx = v×cos(θ), vy = v×sin(θ)
- 重力模拟：每帧vy += gravity
- 弧度转换：math.radians(角度)

**底层逻辑**
- **物理仿真**：用数学公式模拟真实物理
- **帧更新**：每帧计算新位置

`#执行层` `#测评项`
[UID: PYAI-22-10-001]

---

### 2-2-11 举重若轻3

#### 课程基本信息

| 项目 | 内容 |
|------|------|
| **课程编号** | 2-2-11 |
| **课程名称** | 举重若轻3 |
| **认知负荷** | 高 |
| **核心技能** | 向量拆分合并、爆炸效果、音频加载 |

#### 详细教学流程

**步骤1：知识讲解（20分钟）** `#中负荷-操练` `#IFC-即时`

**教师话术**
> "今天是大炮射击的最后一课！我们要加入**目标**、**爆炸效果**和**音效**，让游戏更完整！"
>
> "**Pygame音频**：
> ```python
> import pygame
>
> pygame.mixer.init()  # 初始化音频
>
> # 加载音效
> explosion_sound = pygame.mixer.Sound('explosion.wav')
>
> # 播放音效
> explosion_sound.play()
>
> # 加载背景音乐
> pygame.mixer.music.load('bgm.mp3')
> pygame.mixer.music.play(-1)  # -1表示循环播放
> ```
>
> **爆炸效果**：
> - 碰撞时创建爆炸粒子
> - 粒子向四周扩散
> - 逐渐消失"

**核心代码模式**

```python
import pygame
import math
import random

pygame.init()
pygame.mixer.init()
screen = pygame.display.set_mode((800, 600))

GRAVITY = 0.3

# 目标类
class Target:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.radius = 25
        self.alive = True

    def draw(self, screen):
        if self.alive:
            pygame.draw.circle(screen, (255, 0, 0), (self.x, self.y), self.radius)
            pygame.draw.circle(screen, (255, 255, 255), (self.x, self.y), 15)
            pygame.draw.circle(screen, (255, 0, 0), (self.x, self.y), 5)

# 爆炸粒子类
class Particle:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        angle = random.uniform(0, 2 * math.pi)
        speed = random.uniform(2, 8)
        self.vx = speed * math.cos(angle)
        self.vy = speed * math.sin(angle)
        self.life = 30  # 生命周期
        self.color = random.choice([(255,100,0), (255,200,0), (255,50,0)])

    def update(self):
        self.x += self.vx
        self.y += self.vy
        self.vy += 0.1  # 轻微重力
        self.life -= 1

    def draw(self, screen):
        if self.life > 0:
            size = max(1, self.life // 5)
            pygame.draw.circle(screen, self.color, (int(self.x), int(self.y)), size)

# 炮弹类（简化版）
class Bullet:
    def __init__(self, x, y, speed, angle):
        self.x, self.y = x, y
        rad = math.radians(angle)
        self.vx = speed * math.cos(rad)
        self.vy = -speed * math.sin(rad)
        self.active = True

    def update(self):
        self.x += self.vx
        self.vy += GRAVITY
        self.y += self.vy
        if self.y > 550: self.active = False

    def draw(self, screen):
        pygame.draw.circle(screen, (50,50,50), (int(self.x), int(self.y)), 8)

# 碰撞检测
def check_hit(bullet, target):
    dist = math.sqrt((bullet.x - target.x)**2 + (bullet.y - target.y)**2)
    return dist < target.radius + 8

# 创建爆炸
def create_explosion(x, y):
    return [Particle(x, y) for _ in range(20)]

# 游戏对象
targets = [Target(600, 500), Target(500, 450), Target(700, 480)]
bullets = []
particles = []
score = 0

running = True
while running:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        if event.type == pygame.KEYUP:
            if event.key == pygame.K_SPACE:
                bullets.append(Bullet(80, 480, 15, 45))

    screen.fill((135, 206, 235))
    pygame.draw.rect(screen, (34, 139, 34), (0, 550, 800, 50))

    # 更新炮弹
    for bullet in bullets[:]:
        bullet.update()
        bullet.draw(screen)

        # 检测碰撞
        for target in targets:
            if target.alive and check_hit(bullet, target):
                target.alive = False
                bullet.active = False
                particles.extend(create_explosion(target.x, target.y))
                score += 100

    bullets = [b for b in bullets if b.active]

    # 更新粒子
    for p in particles[:]:
        p.update()
        p.draw(screen)
    particles = [p for p in particles if p.life > 0]

    # 绘制目标
    for target in targets:
        target.draw(screen)

    pygame.display.flip()
    pygame.time.delay(16)

pygame.quit()
```

**变体示例**

| 学生情况 | 调整方案 | 说明 |
|----------|----------|------|
| 爆炸效果太弱 | 增加粒子数量 | 把20改成50 |
| 想加音效 | 加载wav文件 | 碰撞时播放explosion_sound.play() |
| 想加关卡 | 设计关卡系统 | 消灭所有目标后进入下一关 |

**禁忌提醒**
❌ 音频格式不支持——推荐使用wav或ogg
❌ 粒子太多导致卡顿——控制粒子数量和生命周期

---

**核心知识点**
- 音频加载：`pygame.mixer.Sound()` / `pygame.mixer.music`
- 粒子系统：随机方向、速度、颜色
- 碰撞响应：检测到碰撞后触发效果
- 生命周期：粒子逐渐消失

**底层逻辑**
- **粒子系统**：大量简单对象模拟复杂效果
- **游戏完整性**：视觉+音效+交互

`#执行层` `#测评项`
[UID: PYAI-22-11-001]

---

### 2-2-12 阶段复习

#### 课程基本信息

| 项目 | 内容 |
|------|------|
| **课程编号** | 2-2-12 |
| **课程名称** | 阶段复习 |
| **认知负荷** | 中 |
| **核心技能** | 综合复习Pygame与OOP |

#### 详细教学流程

**步骤1：知识回顾（30分钟）** `#中负荷-操练` `#IFC-即时`

**教师话术**
> "这个单元我们学了很多内容！让我们来回顾一下：
>
> **面向对象编程(OOP)**：
> - class定义类，是模板/蓝图
> - 实例是根据类创建的具体对象
> - `__init__`是初始化方法
> - `self`代表实例本身
>
> **Pygame基础**：
> - `pygame.init()` 初始化
> - `pygame.display.set_mode()` 创建窗口
> - 游戏主循环：事件处理 → 更新 → 绘制 → 刷新
>
> **图形绘制**：
> - `pygame.draw.line/rect/circle()`
> - RGB颜色：(R, G, B)，每个值0-255
>
> **图像处理**：
> - `pygame.image.load()` 加载
> - `pygame.transform.scale/rotate()` 变换
>
> **物理仿真**：
> - 抛物线：水平匀速 + 垂直加速
> - 重力：每帧vy += gravity
> - 碰撞检测：距离 < 半径之和"

**步骤2：综合练习（40分钟）** `#高负荷-产出` `#IFC-即时`

**教师话术**
> "现在来做一个**综合测试**！完成以下任务：
>
> 1. 创建一个Ball类，包含位置、速度、颜色属性
> 2. 让球在屏幕内弹跳（碰到边界反弹）
> 3. 用键盘控制一个方块，碰到球就得分
>
> 这个练习综合了OOP、Pygame绑图、按键控制、碰撞检测！"

**核心代码模式（参考答案）**

```python
import pygame
import random

pygame.init()
screen = pygame.display.set_mode((800, 600))
font = pygame.font.Font(None, 48)

class Ball:
    def __init__(self):
        self.x = random.randint(100, 700)
        self.y = random.randint(100, 500)
        self.vx = random.choice([-4, -3, 3, 4])
        self.vy = random.choice([-4, -3, 3, 4])
        self.radius = 15
        self.color = (random.randint(50,255), random.randint(50,255), random.randint(50,255))

    def update(self):
        self.x += self.vx
        self.y += self.vy
        # 边界反弹
        if self.x < self.radius or self.x > 800 - self.radius:
            self.vx = -self.vx
        if self.y < self.radius or self.y > 600 - self.radius:
            self.vy = -self.vy

    def draw(self, screen):
        pygame.draw.circle(screen, self.color, (int(self.x), int(self.y)), self.radius)

# 玩家方块
player_x, player_y = 400, 300
player_size = 30
speed = 5
score = 0

# 创建多个球
balls = [Ball() for _ in range(5)]

running = True
while running:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False

    # 键盘控制
    keys = pygame.key.get_pressed()
    if keys[pygame.K_LEFT]: player_x -= speed
    if keys[pygame.K_RIGHT]: player_x += speed
    if keys[pygame.K_UP]: player_y -= speed
    if keys[pygame.K_DOWN]: player_y += speed

    # 边界限制
    player_x = max(0, min(800 - player_size, player_x))
    player_y = max(0, min(600 - player_size, player_y))

    # 碰撞检测
    player_center = (player_x + player_size/2, player_y + player_size/2)
    for ball in balls[:]:
        dist = ((ball.x - player_center[0])**2 + (ball.y - player_center[1])**2)**0.5
        if dist < ball.radius + player_size/2:
            balls.remove(ball)
            balls.append(Ball())  # 生成新球
            score += 10

    screen.fill((30, 30, 30))

    # 绘制球
    for ball in balls:
        ball.update()
        ball.draw(screen)

    # 绘制玩家
    pygame.draw.rect(screen, (0, 255, 0), (player_x, player_y, player_size, player_size))

    # 显示分数
    text = font.render(f'Score: {score}', True, (255, 255, 255))
    screen.blit(text, (20, 20))

    pygame.display.flip()
    pygame.time.delay(16)

pygame.quit()
```

**变体示例**

| 学生情况 | 调整方案 | 说明 |
|----------|----------|------|
| 完成太快 | 增加难度 | 球越来越快，或者加入躲避模式 |
| 有困难 | 简化任务 | 先只做弹跳球，再加玩家控制 |
| 想做更多 | 鼓励创意 | 加入计时、关卡、音效等 |

---

**步骤3：成果展示（10分钟）** `#低负荷-热身` `#IFC-复盘`

**教师话术**
> "谁来展示一下你的作品？说说你用了哪些知识点？
>
> 这个单元我们从零开始，学会了用Python做游戏！
> - 面向对象让代码更有组织
> - Pygame让我们能画图、放音乐、做交互
> - 物理仿真让游戏更真实
>
> 下个单元我们会学习更多AI相关的内容！"

---

**核心知识点**
- OOP综合：类定义、实例创建、方法调用
- Pygame综合：初始化、主循环、绑图、事件
- 物理综合：运动、碰撞、反弹
- 游戏设计：玩家控制、得分系统

**底层逻辑**
- **知识整合**：将分散的知识点串联成完整项目
- **能力迁移**：从模仿到独立创作

`#执行层` `#测评项`
[UID: PYAI-22-12-001]

---

## 教学禁忌清单

| 序号 | 禁忌 | 原因 | 正确做法 |
|------|------|------|----------|
| 1 | ❌ **方法定义忘记self** | TypeError错误 | 方法第一个参数必须是self |
| 2 | ❌ **__init__写成_init_** | 不会自动调用 | 左右各两个下划线 |
| 3 | ❌ **类名用小写** | 不符合规范 | 使用大驼峰命名法(PascalCase) |
| 4 | ❌ **遍历列表时直接删除** | 跳过元素 | 用切片复制或倒序遍历 |
| 5 | ❌ **忘记pygame.display.flip()** | 画面不更新 | 每帧结束必须调用 |
| 6 | ❌ **角度不转弧度** | 三角函数结果错误 | 使用math.radians()转换 |

`#执行层` `#测评项`
[UID: PYAI-TABOO-22]

---

## 教学注意事项

| 类别 | 注意事项 |
|------|----------|
| **OOP教学** | 用具体类比（模具-饼干、蓝图-房子）帮助理解抽象概念 |
| **Pygame调试** | 用print()输出变量值，确认逻辑正确 |
| **物理仿真** | 先画图解释原理，再写代码实现 |
| **项目管理** | 大项目分步完成，每步都能运行测试 |

---

## 底层教育学原理

| 原理 | 说明 | 在本单元的应用 |
|------|------|----------------|
| **面向对象思维** | 用类封装数据和行为 | 弹幕、星星、炮弹都是类的实例 |
| **物理建模** | 用数学公式模拟真实世界 | 抛物线运动、重力、碰撞 |
| **项目驱动学习** | 通过完整项目整合知识 | 大炮射击三部曲、贪食蛇 |
| **螺旋式上升** | 知识点逐步加深 | 从简单绘图到复杂游戏 |

`#执行层` `#测评项`
[UID: PYAI-THEORY-22]

---

**质量评估**：10/10（原子化萃取版，12节课完整萃取）
**已补充**：认知负荷标签、IFC标签、变体示例、详细教师话术、核心代码模式
**课程覆盖**：2-2-1至2-2-12全部12节课

---

**最后更新**：2026-02-09
