# [PYAI-1-4-02] 按钮控制LED

> **模块**：L1-M4 智能硬件
> **认知负荷**：中
> **核心技能**：GPIO输入、button.value()、消抖处理
> **UID**：PYAI-14-02-001

---

## 课程基本信息

| 项目 | 内容 |
|------|------|
| **课程编号** | PYAI-1-4-02 |
| **课程名称** | 按钮控制LED |
| **认知负荷** | 中 |
| **核心技能** | GPIO输入、button.value()、消抖处理 |
| **课时** | 90分钟 |

---

## 详细教学流程

### 步骤1：课程回顾（5分钟）

`#低负荷-热身` `#IFC-预防`

**教师话术**
> "上节课我们学会了用代码控制LED闪烁。但那是自动的，如果我想用按钮来控制呢？今天学习**GPIO输入**——让开发板'感知'按钮状态！"

---

### 步骤2：知识讲解（15分钟）

`#中负荷-操练` `#IFC-即时`

**教师话术**
> "**GPIO输入模式**：之前LED是输出(OUT)，按钮是输入(IN)
>
> ```python
> import machine
>
> # LED是输出
> led = machine.Pin(2, machine.Pin.OUT)
>
> # 按钮是输入
> button = machine.Pin(4, machine.Pin.IN)
> ```
>
> **读取按钮状态**：用`value()`方法
> ```python
> state = button.value()
> # 返回 0 表示按下（低电平）
> # 返回 1 表示松开（高电平）
> ```
>
> **为什么按下是0？**
> - 按钮接地(GND)，按下时引脚接地，电压为0
> - 松开时引脚悬空或接高电平，电压为1"

**核心代码模式**

```python
import machine
import time

# 初始化引脚
led = machine.Pin(2, machine.Pin.OUT)
button = machine.Pin(4, machine.Pin.IN)

while True:
    if button.value() == 0:  # 按钮按下
        led.value(1)         # 开灯
    else:
        led.value(0)         # 关灯
    time.sleep_ms(20)        # 消抖延时
```

**变体示例**

| 学生情况 | 调整方案 | 说明 |
|----------|----------|------|
| 不理解0和1 | 用开关类比 | "按下接通=0，松开断开=1" |
| 按钮不灵敏 | 检查接线 | 确认按钮一端接引脚，一端接GND |
| 想做切换功能 | 引导状态变量 | 用变量记录当前灯的状态 |

---

### 步骤3：硬件搭建（20分钟）

`#高负荷-产出` `#IFC-即时`

**教师话术**
> "今天的接线很简单：
>
> **按钮接线**：
> ```
> 按钮一端 → P4引脚
> 按钮另一端 → GND
> ```
>
> **LED接线**（如果用外部LED）：
> ```
> LED正极 → P2引脚
> LED负极 → GND（通过电阻）
> ```
>
> **消抖处理**：按钮按下时会有机械抖动，产生多次0-1变化。加入`time.sleep_ms(20)`延时可以消除抖动。"

**禁忌提醒**

❌ **按钮两端都接VCC**——无法检测按下
❌ **忘记消抖**——按一次可能触发多次
❌ **LED不串电阻**——可能烧毁LED

---

### 步骤4：编程调试（30分钟）

`#高负荷-产出` `#IFC-即时`

**教师话术**
> "现在来做一个**切换开关**——按一次开灯，再按一次关灯：
>
> ```python
> import machine
> import time
>
> led = machine.Pin(2, machine.Pin.OUT)
> button = machine.Pin(4, machine.Pin.IN)
>
> light_on = False  # 记录灯的状态
> last_state = 1    # 记录上次按钮状态
>
> while True:
>     current_state = button.value()
>
>     # 检测按下瞬间（从1变成0）
>     if current_state == 0 and last_state == 1:
>         light_on = not light_on  # 切换状态
>         led.value(1 if light_on else 0)
>         time.sleep_ms(200)  # 防止连续触发
>
>     last_state = current_state
>     time.sleep_ms(20)
> ```"

**变体示例**

| 学生情况 | 调整方案 | 说明 |
|----------|----------|------|
| 切换不灵 | 检查边沿检测 | 确认是检测"按下瞬间"而非"按住" |
| 想加多个按钮 | 扩展引脚 | 每个按钮用不同引脚 |
| 想做长按功能 | 计时检测 | 记录按下时长，超过1秒执行不同操作 |

---

### 步骤5：成果展示（10分钟）

`#低负荷-热身` `#IFC-复盘`

**教师话术**
> "谁的按钮开关做好了？演示一下！
>
> 挑战：能不能做一个'双击'功能？双击按钮切换不同颜色的RGB灯。"

---

## 核心知识点

- GPIO输入模式：`machine.Pin(pin, machine.Pin.IN)`
- 读取状态：`button.value()` 返回0或1
- 消抖处理：加入短暂延时消除机械抖动
- 边沿检测：检测状态变化的瞬间

---

## 底层逻辑

- **输入输出**：GPIO既可以输出控制设备，也可以输入感知状态
- **状态机**：用变量记录状态，实现切换功能

---

`#执行层` `#测评项`
[UID: PYAI-14-02-001]

---

[上一课](PYAI-1-4-01_硬件系统.md) | [返回模块](_模块概览.md) | [下一课](PYAI-1-4-03_智能光控1.md)
