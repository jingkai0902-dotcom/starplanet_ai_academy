# [PYAI-2-1-03] 自我复制

> **模块**：L2-M1 算法数据科学
> **认知负荷**：高
> **核心技能**：递归函数、递归终止条件、调用栈
> **UID**：PYAI-21-03-001

---

## 课程基本信息

| 项目 | 内容 |
|------|------|
| **课程编号** | 2-1-3 |
| **课程名称** | 自我复制 |
| **认知负荷** | 高 |
| **核心技能** | 递归函数、递归终止条件、调用栈 |
| **项目内容** | 阶乘与斐波那契 |

---

## 详细教学流程

**步骤1：知识讲解（25分钟）** `#中负荷-操练` `#IFC-即时`

**教师话术**
> "今天学习一个神奇的概念——**递归**：函数调用自己！"
>
> "想象俄罗斯套娃，打开一个娃娃里面还有一个，直到最小的那个。
>
> **递归三要素**：
> 1. **递归调用**：函数调用自己
> 2. **终止条件**：什么时候停止（最重要！）
> 3. **问题缩小**：每次调用问题要变小
>
> **阶乘示例**：n! = n × (n-1)!
> ```python
> def factorial(n):
>     # 终止条件
>     if n <= 1:
>         return 1
>     # 递归调用
>     return n * factorial(n - 1)
>
> print(factorial(5))  # 120 = 5×4×3×2×1
> ```
>
> **斐波那契数列**：F(n) = F(n-1) + F(n-2)
> ```python
> def fibonacci(n):
>     if n <= 1:
>         return n
>     return fibonacci(n-1) + fibonacci(n-2)
>
> # 0, 1, 1, 2, 3, 5, 8, 13, 21...
> ```"

**步骤2：代码实践（35分钟）** `#高负荷-产出` `#IFC-即时`

**教师话术**
> "用递归解决这些问题：
> 1. 计算1+2+3+...+n的和
> 2. 计算x的n次方
> 3. 打印倒计时：5, 4, 3, 2, 1, 发射！"

---

## 变体示例

| 学生情况 | 调整方案 | 说明 |
|----------|----------|------|
| 无限递归 | 检查终止条件 | 确保有明确的停止条件 |
| 不理解调用栈 | 画图演示 | 画出函数调用的层层嵌套 |
| 斐波那契太慢 | 解释原因 | 重复计算太多，后面学优化 |

---

## 核心代码模式

```python
def recursive_template(problem):
    # 1. 终止条件（必须有！）
    if is_base_case(problem):
        return base_solution

    # 2. 缩小问题
    smaller_problem = reduce(problem)

    # 3. 递归调用
    sub_result = recursive_template(smaller_problem)

    # 4. 组合结果
    return combine(sub_result)
```

---

## 禁忌提醒

- 忘记终止条件——导致无限递归，程序崩溃
- 问题没有缩小——同样导致无限递归
- 递归层数太深——Python默认限制1000层

---

## 核心知识点

- 递归函数：函数调用自己
- 终止条件：递归必须有停止条件
- 调用栈：递归调用的层层嵌套结构

---

`#执行层` `#测评项`
[UID: PYAI-21-03-001]

---

[上一课](PYAI-2-1-02_笔走龙蛇.md) | [下一课](PYAI-2-1-04_分而治之.md) | [返回模块概览](_模块概览.md)
