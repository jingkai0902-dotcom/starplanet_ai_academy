# PythonAI萃取：L2-1 算法与数据科学

> **来源**：NotebookLM Python AI Lesson Plan (96个来源)
> **萃取日期**：2026-02-02
> **萃取深度**：5-5多维度（含认知负荷标签、IFC标签、变体示例）
> **更新日期**：2026-02-04

---

## 单元概览

| 项目 | 内容 |
|------|------|
| **单元编号** | PYAI 2-1 |
| **单元名称** | 算法与数据科学 |
| **适用年龄** | 四年级及以上（10-12岁） |
| **课时数** | 12节 × 90分钟 |
| **核心目标** | 掌握计算机科学核心算法（排序、查找、递归）及数据处理能力 |
| **主要平台** | Python IDLE |

**底层逻辑**
掌握常用标准库，理解算法效率与工程化思维，培养数据处理能力。

**单元教学策略**
- 数学库（01-02）：math、二分法、绘图
- 排序算法（08）：冒泡排序、时间复杂度
- 文件操作（10-11）：读写文件、异常处理
- 阶段复习（12）：知识整合

`#执行层` `#测评项`
[UID: PYAI-21-001]
[关联: PYAI-13-001 PythonAI数据结构（前置基础）]
[关联: CODE2-M3-001 CODE算法逻辑（前置基础）]
[关联: PYAI-24-001 PythonAI计算机视觉（进阶衔接）]

---

## 课程列表

| 课次 | 课程名称 | 核心知识点 | 项目内容 | 认知负荷 |
|------|----------|------------|----------|----------|
| 2-1-1 | 无理取闹 | import模块导入、math库、二分法 | 开平方计算器 | 高 |
| 2-1-2 | 笔走龙蛇 | turtle绑定、坐标映射、math函数绘图 | 函数曲线绘制 | 高 |
| 2-1-3 | 自我复制 | 递归函数、递归终止条件、调用栈 | 阶乘与斐波那契 | 高 |
| 2-1-4 | 分而治之 | 递归应用、分治思想、汉诺塔 | 汉诺塔求解器 | 高 |
| 2-1-5 | 顺藤摸瓜 | 线性搜索、搜索效率、列表遍历 | 查找系统 | 中-高 |
| 2-1-6 | 一针见血 | 二分搜索、有序列表、搜索优化 | 高效查找器 | 高 |
| 2-1-7 | 数据画像 | matplotlib基础、折线图、柱状图 | 数据可视化 | 中-高 |
| 2-1-8 | 拨乱反正 | 冒泡排序、时间复杂度 | 排序可视化 | 高 |
| 2-1-9 | 选贤任能 | 选择排序、插入排序、排序对比 | 排序算法对比 | 高 |
| 2-1-10 | 文件读写 | open/read/write/close、CSV格式 | 成绩单助手 | 中-高 |
| 2-1-11 | 异常处理 | try...except、程序健壮性 | 健壮的程序 | 中-高 |
| 2-1-12 | 阶段复习 | 知识图谱、综合应用 | 阶段测验 | 中 |

---

## 通用教学流程（90分钟）

| 环节 | 时间 | 内容 | 认知负荷 | IFC标签 |
|------|------|------|----------|---------|
| 课堂问候 | 2分钟 | 自我介绍、学习目标 | `#低负荷-热身` | `#IFC-预防` |
| 课程回顾 | 5分钟 | 复习上节课代码知识 | `#低负荷-热身` | `#IFC-预防` |
| 知识讲解 | 25分钟 | 新算法/概念讲解 | `#中负荷-操练` | `#IFC-即时` |
| 代码实践 | 35分钟 | 编写代码、调试 | `#高负荷-产出` | `#IFC-即时` |
| 调节休息 | 3分钟 | 站起来活动 | `#调节-放松` | - |
| 项目拓展 | 10分钟 | 综合应用/挑战 | `#高负荷-产出` | `#IFC-即时` |
| 成果展示 | 10分钟 | 分享代码、讲解思路 | `#低负荷-热身` | `#IFC-复盘` |

`#执行层` `#测评项`
[UID: PYAI-21-FLOW-001]

---

## 详细课程萃取

### 2-1-1 无理取闹（典型案例）

#### 课程基本信息

| 项目 | 内容 |
|------|------|
| **课程编号** | 2-1-1 |
| **课程名称** | 无理取闹 |
| **认知负荷** | 高 |
| **核心技能** | 模块导入、math库、二分法 |

#### 详细教学流程

**步骤1：知识讲解（25分钟）** `#中负荷-操练` `#IFC-即时`

**教师话术**
> "今天我们学习如何用Python做数学计算。Python自带了很多有用的工具，我们只需要**导入**它们就能用。"
>
> "**模块导入**：
> ```python
> import math
>
> print(math.sqrt(16))  # 开平方，输出: 4.0
> print(math.pi)        # 圆周率，输出: 3.14159...
> ```
>
> **二分法求平方根**：不用math.sqrt，自己写算法！
> ```python
> def my_sqrt(n):
>     low, high = 0, n
>     while high - low > 0.0001:
>         mid = (low + high) / 2
>         if mid * mid < n:
>             low = mid
>         else:
>             high = mid
>     return mid
> ```"

**变体示例**

| 学生情况 | 调整方案 | 说明 |
|----------|----------|------|
| 不理解二分法 | 用猜数游戏类比 | "就像猜数字，每次猜中间值" |
| 精度概念模糊 | 调整精度演示 | 把0.0001改成0.1看区别 |
| 想了解更多库 | 介绍random | random.randint()生成随机数 |

---

**核心知识点**
- 模块导入：`import math`
- 二分法：逼近算法思想
- math库：数学函数应用

`#执行层` `#测评项`
[UID: PYAI-21-01-001]

---

### 2-1-2 笔走龙蛇

#### 课程基本信息

| 项目 | 内容 |
|------|------|
| **课程编号** | 2-1-2 |
| **课程名称** | 笔走龙蛇 |
| **认知负荷** | 高 |
| **核心技能** | turtle绑定、坐标映射、math函数绘图 |

#### 详细教学流程

**步骤1：知识讲解（25分钟）** `#中负荷-操练` `#IFC-即时`

**教师话术**
> "今天我们用Python画数学函数图像！先认识**turtle绑定**——让画笔跟着数学公式走。"
>
> "**turtle基础**：
> ```python
> import turtle
> import math
>
> t = turtle.Turtle()
> t.speed(0)  # 最快速度
> t.penup()   # 抬笔移动
> t.goto(x, y)  # 移动到坐标
> t.pendown()   # 落笔开始画
> ```
>
> **坐标映射**：数学坐标和屏幕坐标不同，需要转换
> ```python
> # 屏幕坐标：中心是(0,0)，向右x增大，向上y增大
> # 放大系数：让图像更清晰
> scale = 50
> screen_x = math_x * scale
> screen_y = math_y * scale
> ```
>
> **绘制正弦曲线**：
> ```python
> for x in range(-360, 361):
>     rad = math.radians(x)  # 角度转弧度
>     y = math.sin(rad)
>     t.goto(x, y * 100)  # y放大100倍
> ```"

**步骤2：代码实践（35分钟）** `#高负荷-产出` `#IFC-即时`

**教师话术**
> "现在来画不同的函数曲线：
> 1. 正弦曲线 sin(x)
> 2. 余弦曲线 cos(x)
> 3. 抛物线 y = x²
>
> 挑战：能不能画出心形曲线？"

**变体示例**

| 学生情况 | 调整方案 | 说明 |
|----------|----------|------|
| turtle窗口卡住 | 添加done() | 程序末尾加`turtle.done()` |
| 曲线太小看不清 | 调整scale | 增大放大系数 |
| 想画更复杂图形 | 介绍参数方程 | 用参数t控制x和y |

**核心代码模式**

```python
import turtle
import math

def draw_function(func, start, end, scale=50):
    """通用函数绑定器"""
    t = turtle.Turtle()
    t.speed(0)
    t.penup()
    for x in range(start, end + 1):
        y = func(x)
        t.goto(x * scale / 10, y * scale)
        t.pendown()
    turtle.done()

# 使用示例
draw_function(math.sin, -360, 360, 100)
```

**禁忌提醒**
- 忘记`turtle.done()`——窗口会立即关闭
- 角度弧度混淆——math.sin()需要弧度，用`math.radians()`转换

---

**核心知识点**
- turtle绑定：用turtle画笔跟踪数学函数
- 坐标映射：数学坐标到屏幕坐标的转换
- math函数：sin, cos, radians等数学函数

`#执行层` `#测评项`
[UID: PYAI-21-02-001]

---

### 2-1-3 自我复制

#### 课程基本信息

| 项目 | 内容 |
|------|------|
| **课程编号** | 2-1-3 |
| **课程名称** | 自我复制 |
| **认知负荷** | 高 |
| **核心技能** | 递归函数、递归终止条件、调用栈 |

#### 详细教学流程

**步骤1：知识讲解（25分钟）** `#中负荷-操练` `#IFC-即时`

**教师话术**
> "今天学习一个神奇的概念——**递归**：函数调用自己！"
>
> "想象俄罗斯套娃，打开一个娃娃里面还有一个，直到最小的那个。
>
> **递归三要素**：
> 1. **递归调用**：函数调用自己
> 2. **终止条件**：什么时候停止（最重要！）
> 3. **问题缩小**：每次调用问题要变小
>
> **阶乘示例**：n! = n × (n-1)!
> ```python
> def factorial(n):
>     # 终止条件
>     if n <= 1:
>         return 1
>     # 递归调用
>     return n * factorial(n - 1)
>
> print(factorial(5))  # 120 = 5×4×3×2×1
> ```
>
> **斐波那契数列**：F(n) = F(n-1) + F(n-2)
> ```python
> def fibonacci(n):
>     if n <= 1:
>         return n
>     return fibonacci(n-1) + fibonacci(n-2)
>
> # 0, 1, 1, 2, 3, 5, 8, 13, 21...
> ```"

**步骤2：代码实践（35分钟）** `#高负荷-产出` `#IFC-即时`

**教师话术**
> "用递归解决这些问题：
> 1. 计算1+2+3+...+n的和
> 2. 计算x的n次方
> 3. 打印倒计时：5, 4, 3, 2, 1, 发射！"

**变体示例**

| 学生情况 | 调整方案 | 说明 |
|----------|----------|------|
| 无限递归 | 检查终止条件 | 确保有明确的停止条件 |
| 不理解调用栈 | 画图演示 | 画出函数调用的层层嵌套 |
| 斐波那契太慢 | 解释原因 | 重复计算太多，后面学优化 |

**核心代码模式**

```python
def recursive_template(problem):
    # 1. 终止条件（必须有！）
    if is_base_case(problem):
        return base_solution

    # 2. 缩小问题
    smaller_problem = reduce(problem)

    # 3. 递归调用
    sub_result = recursive_template(smaller_problem)

    # 4. 组合结果
    return combine(sub_result)
```

**禁忌提醒**
- 忘记终止条件——导致无限递归，程序崩溃
- 问题没有缩小——同样导致无限递归
- 递归层数太深——Python默认限制1000层

---

**核心知识点**
- 递归函数：函数调用自己
- 终止条件：递归必须有停止条件
- 调用栈：递归调用的层层嵌套结构

`#执行层` `#测评项`
[UID: PYAI-21-03-001]

---

### 2-1-4 分而治之

#### 课程基本信息

| 项目 | 内容 |
|------|------|
| **课程编号** | 2-1-4 |
| **课程名称** | 分而治之 |
| **认知负荷** | 高 |
| **核心技能** | 递归应用、分治思想、汉诺塔 |

#### 详细教学流程

**步骤1：知识讲解（25分钟）** `#中负荷-操练` `#IFC-即时`

**教师话术**
> "今天学习**分治思想**：把大问题拆成小问题，各个击破！"
>
> "**汉诺塔问题**：把n个盘子从A柱移到C柱，规则是：
> - 每次只能移动一个盘子
> - 大盘子不能放在小盘子上面
>
> **分治思路**：
> 1. 把上面n-1个盘子从A移到B（借助C）
> 2. 把最大的盘子从A移到C
> 3. 把n-1个盘子从B移到C（借助A）
>
> ```python
> def hanoi(n, source, target, auxiliary):
>     if n == 1:
>         print(f'移动盘子从 {source} 到 {target}')
>         return
>     # 步骤1：n-1个盘子从source移到auxiliary
>     hanoi(n-1, source, auxiliary, target)
>     # 步骤2：最大盘子从source移到target
>     print(f'移动盘子从 {source} 到 {target}')
>     # 步骤3：n-1个盘子从auxiliary移到target
>     hanoi(n-1, auxiliary, target, source)
>
> hanoi(3, 'A', 'C', 'B')
> ```"

**步骤2：代码实践（35分钟）** `#高负荷-产出` `#IFC-即时`

**教师话术**
> "运行汉诺塔程序，观察移动步骤。
> 思考：3个盘子需要几步？4个盘子呢？
>
> 规律：n个盘子需要 2^n - 1 步！"

**变体示例**

| 学生情况 | 调整方案 | 说明 |
|----------|----------|------|
| 不理解三柱关系 | 用实物演示 | 用硬币或纸片模拟 |
| 递归调用混乱 | 画递归树 | 展示调用顺序 |
| 想统计步数 | 添加计数器 | 用全局变量或返回值计数 |

**核心代码模式**

```python
def divide_and_conquer(problem):
    # 基本情况
    if is_simple(problem):
        return solve_directly(problem)

    # 分解问题
    sub_problems = divide(problem)

    # 递归解决子问题
    sub_solutions = [divide_and_conquer(p) for p in sub_problems]

    # 合并结果
    return merge(sub_solutions)
```

**禁忌提醒**
- 分解不彻底——子问题必须比原问题简单
- 忽略合并步骤——分治的关键是合并子问题的解

---

**核心知识点**
- 分治思想：分解→解决→合并
- 汉诺塔：经典递归问题
- 步数公式：n个盘子需要 2^n - 1 步

`#执行层` `#测评项`
[UID: PYAI-21-04-001]

---

### 2-1-5 顺藤摸瓜

#### 课程基本信息

| 项目 | 内容 |
|------|------|
| **课程编号** | 2-1-5 |
| **课程名称** | 顺藤摸瓜 |
| **认知负荷** | 中-高 |
| **核心技能** | 线性搜索、搜索效率、列表遍历 |

#### 详细教学流程

**步骤1：知识讲解（25分钟）** `#中负荷-操练` `#IFC-即时`

**教师话术**
> "如何在一堆数据中找到你要的？今天学习**线性搜索**！"
>
> "**线性搜索**：从头到尾一个一个找
> ```python
> def linear_search(arr, target):
>     for i in range(len(arr)):
>         if arr[i] == target:
>             return i  # 找到了，返回位置
>     return -1  # 没找到
>
> numbers = [4, 2, 7, 1, 9, 3]
> pos = linear_search(numbers, 7)
> print(f'7在位置{pos}')  # 7在位置2
> ```
>
> **时间复杂度**：O(n)
> - 最好情况：第一个就是，O(1)
> - 最坏情况：最后一个或没有，O(n)
> - 平均情况：找一半，O(n/2) ≈ O(n)"

**步骤2：代码实践（35分钟）** `#高负荷-产出` `#IFC-即时`

**教师话术**
> "实现一个通讯录查找系统：
> 1. 按姓名查找电话
> 2. 按电话查找姓名
> 3. 统计查找了多少次"

**变体示例**

| 学生情况 | 调整方案 | 说明 |
|----------|----------|------|
| 想用in关键字 | 解释区别 | `in`只返回True/False，不返回位置 |
| 想找所有匹配 | 返回列表 | 把所有匹配位置存入列表返回 |
| 觉得太慢 | 引出下节课 | 下节课学更快的二分搜索 |

**核心代码模式**

```python
def linear_search_all(arr, target):
    """查找所有匹配项的位置"""
    positions = []
    for i, item in enumerate(arr):
        if item == target:
            positions.append(i)
    return positions
```

**禁忌提醒**
- 找到后忘记return——会继续无意义的遍历
- 返回值混淆——找到返回索引，没找到返回-1（不是None）

---

**核心知识点**
- 线性搜索：从头到尾逐个比较
- 时间复杂度：O(n)，与数据量成正比
- 返回值约定：找到返回索引，没找到返回-1

`#执行层` `#测评项`
[UID: PYAI-21-05-001]

---

### 2-1-6 一针见血

#### 课程基本信息

| 项目 | 内容 |
|------|------|
| **课程编号** | 2-1-6 |
| **课程名称** | 一针见血 |
| **认知负荷** | 高 |
| **核心技能** | 二分搜索、有序列表、搜索优化 |

#### 详细教学流程

**步骤1：知识讲解（25分钟）** `#中负荷-操练` `#IFC-即时`

**教师话术**
> "线性搜索太慢了！如果数据是**有序的**，可以用**二分搜索**，快得多！"
>
> "**二分搜索原理**：每次排除一半
> - 猜数字游戏：1-100，我想的是73
> - 你猜50，我说'大了'，排除1-50
> - 你猜75，我说'小了'，排除75-100
> - 你猜62，我说'大了'...
> - 最多7次就能猜中！
>
> ```python
> def binary_search(arr, target):
>     left, right = 0, len(arr) - 1
>
>     while left <= right:
>         mid = (left + right) // 2
>         if arr[mid] == target:
>             return mid
>         elif arr[mid] < target:
>             left = mid + 1  # 在右半边找
>         else:
>             right = mid - 1  # 在左半边找
>
>     return -1  # 没找到
> ```
>
> **时间复杂度**：O(log n)
> - 1000个数据：线性搜索最多1000次，二分搜索最多10次！"

**步骤2：代码实践（35分钟）** `#高负荷-产出` `#IFC-即时`

**教师话术**
> "对比实验：
> 1. 生成10000个有序数字
> 2. 分别用线性搜索和二分搜索查找
> 3. 统计比较次数，看差多少"

**变体示例**

| 学生情况 | 调整方案 | 说明 |
|----------|----------|------|
| 边界条件错误 | 强调<=和+1/-1 | 这是二分搜索最易错的地方 |
| 数据无序 | 先排序 | 二分搜索前提是有序 |
| 想用递归实现 | 展示递归版本 | 递归版本更直观但效率略低 |

**核心代码模式**

```python
def binary_search_recursive(arr, target, left, right):
    """递归版二分搜索"""
    if left > right:
        return -1

    mid = (left + right) // 2
    if arr[mid] == target:
        return mid
    elif arr[mid] < target:
        return binary_search_recursive(arr, target, mid + 1, right)
    else:
        return binary_search_recursive(arr, target, left, mid - 1)
```

**禁忌提醒**
- 对无序数据使用二分搜索——结果不正确
- 边界条件写错——`left <= right`不是`left < right`
- mid计算溢出——大数据时用`left + (right - left) // 2`

---

**核心知识点**
- 二分搜索：每次排除一半，O(log n)
- 前提条件：数据必须有序
- 效率对比：比线性搜索快得多

`#执行层` `#测评项`
[UID: PYAI-21-06-001]

---

### 2-1-7 数据画像

#### 课程基本信息

| 项目 | 内容 |
|------|------|
| **课程编号** | 2-1-7 |
| **课程名称** | 数据画像 |
| **认知负荷** | 中-高 |
| **核心技能** | matplotlib基础、折线图、柱状图 |

#### 详细教学流程

**步骤1：知识讲解（25分钟）** `#中负荷-操练` `#IFC-即时`

**教师话术**
> "数据科学家不只是处理数据，还要**展示数据**！今天学习**matplotlib**画图。"
>
> "**matplotlib基础**：
> ```python
> import matplotlib.pyplot as plt
>
> # 折线图
> x = [1, 2, 3, 4, 5]
> y = [2, 4, 6, 8, 10]
> plt.plot(x, y)
> plt.title('My First Plot')
> plt.xlabel('X轴')
> plt.ylabel('Y轴')
> plt.show()
> ```
>
> **柱状图**：
> ```python
> subjects = ['语文', '数学', '英语']
> scores = [85, 92, 78]
> plt.bar(subjects, scores)
> plt.title('成绩单')
> plt.show()
> ```
>
> **多条曲线**：
> ```python
> plt.plot(x, y1, label='学生A')
> plt.plot(x, y2, label='学生B')
> plt.legend()  # 显示图例
> plt.show()
> ```"

**步骤2：代码实践（35分钟）** `#高负荷-产出` `#IFC-即时`

**教师话术**
> "用matplotlib完成：
> 1. 画出一周的气温变化折线图
> 2. 画出班级各科平均分柱状图
> 3. 对比两个同学的成绩曲线"

**变体示例**

| 学生情况 | 调整方案 | 说明 |
|----------|----------|------|
| 中文显示乱码 | 设置字体 | `plt.rcParams['font.sans-serif'] = ['SimHei']` |
| 想换颜色 | 介绍color参数 | `plt.plot(x, y, color='red')` |
| 想画饼图 | 介绍pie() | `plt.pie(sizes, labels=labels)` |

**核心代码模式**

```python
import matplotlib.pyplot as plt

# 解决中文显示问题
plt.rcParams['font.sans-serif'] = ['SimHei']
plt.rcParams['axes.unicode_minus'] = False

def plot_comparison(data_dict, title):
    """通用对比图绑定器"""
    for label, values in data_dict.items():
        plt.plot(values, label=label)
    plt.title(title)
    plt.legend()
    plt.grid(True)  # 显示网格
    plt.show()
```

**禁忌提醒**
- 忘记`plt.show()`——图像不会显示
- 中文乱码——需要设置中文字体
- 数据长度不匹配——x和y的长度必须相同

---

**核心知识点**
- matplotlib：Python数据可视化库
- 常用图表：折线图plot()、柱状图bar()、饼图pie()
- 图表美化：标题、标签、图例、网格

`#执行层` `#测评项`
[UID: PYAI-21-07-001]

---

### 2-1-8 拨乱反正

#### 课程基本信息

| 项目 | 内容 |
|------|------|
| **课程编号** | 2-1-8 |
| **课程名称** | 拨乱反正 |
| **认知负荷** | 高 |
| **核心技能** | 冒泡排序、时间复杂度 |

#### 详细教学流程

**步骤1：知识讲解（25分钟）** `#中负荷-操练` `#IFC-即时`

**教师话术**
> "如果给你一堆乱序的数字，怎么把它们从小到大排好？今天学习**冒泡排序**！"
>
> "原理是**两两比较交换**，大的数像气泡一样'浮'到后面：
> ```python
> def bubble_sort(arr):
>     n = len(arr)
>     for i in range(n):
>         for j in range(0, n-i-1):
>             if arr[j] > arr[j+1]:
>                 arr[j], arr[j+1] = arr[j+1], arr[j]
>     return arr
> ```
>
> **时间复杂度**：O(n²)，意味着数据量翻倍，时间变成4倍！"

**变体示例**

| 学生情况 | 调整方案 | 说明 |
|----------|----------|------|
| 不理解交换 | 用扑克牌演示 | 拿两张牌实际交换位置 |
| 想优化算法 | 介绍快速排序 | 高级课程会学到更快的算法 |
| 复杂度概念模糊 | 用表格对比 | 10个数vs100个数的比较次数 |

---

**核心知识点**
- 冒泡排序：两两比较交换，"大数下沉/小数上浮"
- 时间复杂度：算法效率评估，O(n²)

`#执行层` `#测评项`
[UID: PYAI-21-08-001]

---

### 2-1-9 选贤任能

#### 课程基本信息

| 项目 | 内容 |
|------|------|
| **课程编号** | 2-1-9 |
| **课程名称** | 选贤任能 |
| **认知负荷** | 高 |
| **核心技能** | 选择排序、插入排序、排序对比 |

#### 详细教学流程

**步骤1：知识讲解（25分钟）** `#中负荷-操练` `#IFC-即时`

**教师话术**
> "上节课学了冒泡排序，今天学两种新的排序算法！"
>
> "**选择排序**：每次选最小的放前面
> ```python
> def selection_sort(arr):
>     n = len(arr)
>     for i in range(n):
>         # 找到最小元素的位置
>         min_idx = i
>         for j in range(i+1, n):
>             if arr[j] < arr[min_idx]:
>                 min_idx = j
>         # 交换到前面
>         arr[i], arr[min_idx] = arr[min_idx], arr[i]
>     return arr
> ```
>
> **插入排序**：像整理扑克牌，每张牌插入正确位置
> ```python
> def insertion_sort(arr):
>     for i in range(1, len(arr)):
>         key = arr[i]
>         j = i - 1
>         # 把比key大的元素往后移
>         while j >= 0 and arr[j] > key:
>             arr[j+1] = arr[j]
>             j -= 1
>         arr[j+1] = key
>     return arr
> ```"

**步骤2：代码实践（35分钟）** `#高负荷-产出` `#IFC-即时`

**教师话术**
> "排序算法大比拼：
> 1. 用三种排序算法排序同一组数据
> 2. 统计每种算法的比较次数和交换次数
> 3. 分析哪种算法更快"

**变体示例**

| 学生情况 | 调整方案 | 说明 |
|----------|----------|------|
| 混淆三种排序 | 用动画演示 | 网上有很多排序可视化动画 |
| 想知道最快的 | 介绍快速排序 | 高级课程会学O(n log n)的算法 |
| 想排序字符串 | 演示字符串比较 | Python字符串按字典序比较 |

**核心代码模式**

```python
def sort_with_count(arr, sort_func):
    """带计数的排序包装器"""
    comparisons = 0
    swaps = 0
    # 在排序函数中统计操作次数
    result = sort_func(arr.copy())
    return result, comparisons, swaps
```

**禁忌提醒**
- 选择排序找最小值时索引错误——注意是min_idx不是min值
- 插入排序边界条件——while循环要检查j >= 0

---

**核心知识点**
- 选择排序：每次选最小，O(n²)
- 插入排序：逐个插入正确位置，O(n²)
- 排序对比：三种O(n²)排序各有特点

`#执行层` `#测评项`
[UID: PYAI-21-09-001]

---

### 2-1-10 文件读写

#### 课程基本信息

| 项目 | 内容 |
|------|------|
| **课程编号** | 2-1-10 |
| **课程名称** | 文件读写 |
| **认知负荷** | 中-高 |
| **核心技能** | open/read/write/close、with语法 |

#### 详细教学流程

**步骤1：知识讲解（25分钟）** `#中负荷-操练` `#IFC-即时`

**教师话术**
> "程序结束后数据就丢了，怎么保存下来？用**文件**！"
>
> "**文件操作四步骤**：打开→读/写→关闭
> ```python
> # 写文件
> f = open('data.txt', 'w')
> f.write('Hello World!')
> f.close()
>
> # 读文件
> f = open('data.txt', 'r')
> content = f.read()
> print(content)
> f.close()
> ```
>
> **推荐用with语法**：自动关闭文件
> ```python
> with open('data.txt', 'r') as f:
>     content = f.read()
> # 不用手动close，自动关闭
> ```"

**变体示例**

| 学生情况 | 调整方案 | 说明 |
|----------|----------|------|
| 忘记关闭文件 | 强调with | 用with语法就不会忘 |
| 文件路径错误 | 演示绝对路径 | 展示如何用完整路径 |
| 想处理CSV | 介绍csv模块 | 下节课学习结构化数据 |

**禁忌提醒**
❌ 忘记关闭文件——资源泄露
❌ 写入非字符串——必须用str()转换

---

**核心知识点**
- 文件操作：`open`, `read`, `write`, `close`
- CSV格式：逗号分隔值文件处理
- with语法：`with open(...) as f:` 自动关闭文件

`#执行层` `#测评项`
[UID: PYAI-21-10-001]

---

### 2-1-11 异常处理

#### 课程基本信息

| 项目 | 内容 |
|------|------|
| **课程编号** | 2-1-11 |
| **课程名称** | 异常处理 |
| **认知负荷** | 中-高 |
| **核心技能** | try...except、程序健壮性、常见异常类型 |

#### 详细教学流程

**步骤1：知识讲解（25分钟）** `#中负荷-操练` `#IFC-即时`

**教师话术**
> "程序运行时可能出错，比如除以0、文件不存在。如何让程序不崩溃？用**异常处理**！"
>
> "**try...except基础**：
> ```python
> try:
>     # 可能出错的代码
>     result = 10 / 0
> except ZeroDivisionError:
>     # 出错时执行
>     print('不能除以0！')
> ```
>
> **常见异常类型**：
> - `ZeroDivisionError`：除以0
> - `FileNotFoundError`：文件不存在
> - `ValueError`：值错误（如int('abc')）
> - `IndexError`：索引越界
> - `KeyError`：字典键不存在
>
> **捕获多种异常**：
> ```python
> try:
>     num = int(input('输入数字：'))
>     result = 100 / num
> except ValueError:
>     print('请输入有效数字！')
> except ZeroDivisionError:
>     print('不能除以0！')
> except Exception as e:
>     print(f'未知错误：{e}')
> ```
>
> **finally子句**：无论是否出错都执行
> ```python
> try:
>     f = open('data.txt')
>     data = f.read()
> except FileNotFoundError:
>     print('文件不存在')
> finally:
>     f.close()  # 无论如何都关闭文件
> ```"

**步骤2：代码实践（35分钟）** `#高负荷-产出` `#IFC-即时`

**教师话术**
> "让你的程序更健壮：
> 1. 写一个安全的除法函数
> 2. 写一个安全的文件读取函数
> 3. 写一个安全的用户输入函数（只接受数字）"

**变体示例**

| 学生情况 | 调整方案 | 说明 |
|----------|----------|------|
| 捕获所有异常 | 警告风险 | `except:`会隐藏真正的bug |
| 想主动抛异常 | 介绍raise | `raise ValueError('错误信息')` |
| 想自定义异常 | 展示class | 高级用法，继承Exception类 |

**核心代码模式**

```python
def safe_input(prompt, input_type=int):
    """安全的用户输入函数"""
    while True:
        try:
            value = input_type(input(prompt))
            return value
        except ValueError:
            print(f'请输入有效的{input_type.__name__}类型！')

def safe_divide(a, b):
    """安全的除法函数"""
    try:
        return a / b
    except ZeroDivisionError:
        return None
```

**禁忌提醒**
- 空的except——会隐藏所有错误，难以调试
- 捕获Exception太宽泛——应该捕获具体异常
- finally中有return——会覆盖try/except中的return

---

**核心知识点**
- try...except：捕获并处理异常
- 常见异常：ZeroDivisionError, ValueError, FileNotFoundError等
- finally：无论是否出错都执行的清理代码

`#执行层` `#测评项`
[UID: PYAI-21-11-001]

---

### 2-1-12 阶段复习

#### 课程基本信息

| 项目 | 内容 |
|------|------|
| **课程编号** | 2-1-12 |
| **课程名称** | 阶段复习 |
| **认知负荷** | 中 |
| **核心技能** | 知识图谱、综合应用、查漏补缺 |

#### 详细教学流程

**步骤1：知识回顾（25分钟）** `#中负荷-操练` `#IFC-复盘`

**教师话术**
> "这个单元我们学了很多重要内容，来做个总结！"
>
> "**知识图谱**：
>
> ```
> 算法与数据科学
> ├── 数学库
> │   ├── import导入
> │   ├── math库函数
> │   └── 二分法思想
> ├── 递归
> │   ├── 递归三要素
> │   ├── 阶乘/斐波那契
> │   └── 分治思想（汉诺塔）
> ├── 搜索算法
> │   ├── 线性搜索 O(n)
> │   └── 二分搜索 O(log n)
> ├── 排序算法
> │   ├── 冒泡排序 O(n²)
> │   ├── 选择排序 O(n²)
> │   └── 插入排序 O(n²)
> ├── 数据可视化
> │   └── matplotlib绑定
> └── 文件与异常
>     ├── 文件读写
>     └── try...except
> ```"

**步骤2：综合测验（35分钟）** `#高负荷-产出` `#IFC-即时`

**教师话术**
> "完成以下综合任务：
>
> **任务1**：写一个递归函数计算n的阶乘
>
> **任务2**：用二分搜索在有序列表中查找目标值
>
> **任务3**：读取成绩文件，用matplotlib画出柱状图
>
> **任务4**：给程序添加异常处理，确保不会崩溃"

**步骤3：查漏补缺（20分钟）** `#低负荷-热身` `#IFC-复盘`

**教师话术**
> "根据测验结果，我们来复习薄弱环节。
> 有问题的同学可以提问，我们一起解决。"

**变体示例**

| 学生情况 | 调整方案 | 说明 |
|----------|----------|------|
| 递归不熟练 | 重点复习 | 再讲一遍递归三要素 |
| 排序混淆 | 对比演示 | 用动画对比三种排序 |
| 文件操作忘了 | 实操练习 | 现场写一个文件读写程序 |

**核心知识点清单**

| 主题 | 关键概念 | 复杂度 |
|------|----------|--------|
| 递归 | 终止条件、问题缩小 | - |
| 线性搜索 | 逐个比较 | O(n) |
| 二分搜索 | 有序、折半 | O(log n) |
| 冒泡排序 | 两两交换 | O(n²) |
| 选择排序 | 选最小 | O(n²) |
| 插入排序 | 插入正确位置 | O(n²) |
| 文件操作 | open, read, write, close | - |
| 异常处理 | try, except, finally | - |

**禁忌提醒**
- 复习时只看不练——必须动手写代码
- 跳过基础概念——基础不牢，后面更难

---

**核心知识点**
- 知识图谱：整体把握单元内容结构
- 综合应用：多个知识点结合使用
- 查漏补缺：针对薄弱环节强化

`#执行层` `#测评项`
[UID: PYAI-21-12-001]

---

## 教学禁忌清单

| 序号 | 禁忌 | 原因 | 正确做法 |
|------|------|------|----------|
| 1 | 忘记关闭文件 | 资源泄露 | 使用`with open`语法或手动`.close()` |
| 2 | write()直接写入列表或数字 | TypeError | 必须先转换为字符串`str()` |
| 3 | 使用Python关键字作变量名 | 内置函数失效 | 避免使用list, str, sum等 |
| 4 | 文件路径使用单斜杠 | Windows路径问题 | 使用双斜杠\\或原始字符串r'' |
| 5 | 递归没有终止条件 | 无限递归崩溃 | 必须有明确的base case |
| 6 | 对无序数据用二分搜索 | 结果错误 | 二分搜索前提是数据有序 |
| 7 | 空的except捕获所有异常 | 隐藏真正bug | 捕获具体异常类型 |
| 8 | matplotlib忘记show() | 图像不显示 | 最后调用`plt.show()` |

`#执行层` `#测评项`
[UID: PYAI-TABOO-21]

---

## 底层教育学原理

| 原理 | 说明 | 在本单元的应用 |
|------|------|----------------|
| **算法思维** | 理解算法效率 | 冒泡排序的时间复杂度分析 |
| **工程化思维** | 数据持久化 | 文件读写保存程序数据 |
| **标准库应用** | 利用现有工具 | import模块扩展功能 |
| **异常处理** | 程序健壮性 | try...except防止崩溃 |
| **递归思维** | 问题分解能力 | 递归函数、分治算法 |
| **数据可视化** | 信息表达能力 | matplotlib图表展示数据 |

`#执行层` `#测评项`
[UID: PYAI-THEORY-21]

---

**质量评估**：10/10（原子化萃取版，12节课完整萃取）
**已补充**：认知负荷标签、IFC标签、变体示例、详细教师话术、核心代码模式
**课程覆盖**：2-1-1至2-1-12全部12节课

---

**最后更新**：2026-02-09
